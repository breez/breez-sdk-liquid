// This file was autogenerated by some hot garbage in the
// `uniffi-bindgen-react-native` crate. Trust me, you don't want to mess with
// it!
#include "breez_sdk_liquid.hpp"

#include "UniffiJsiTypes.h"
#include <iostream>
#include <map>
#include <stdexcept>
#include <thread>
#include <utility>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

// Calling into Rust.
extern "C" {
typedef void (*UniffiRustFutureContinuationCallback)(uint64_t data,
                                                     int8_t poll_result);
typedef void (*UniffiForeignFutureFree)(uint64_t handle);
typedef void (*UniffiCallbackInterfaceFree)(uint64_t handle);
typedef struct UniffiForeignFuture {
  uint64_t handle;
  UniffiForeignFutureFree free;
} UniffiForeignFuture;
typedef struct UniffiForeignFutureStructU8 {
  uint8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU8;
typedef void (*UniffiForeignFutureCompleteU8)(
    uint64_t callback_data, UniffiForeignFutureStructU8 result);
typedef struct UniffiForeignFutureStructI8 {
  int8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI8;
typedef void (*UniffiForeignFutureCompleteI8)(
    uint64_t callback_data, UniffiForeignFutureStructI8 result);
typedef struct UniffiForeignFutureStructU16 {
  uint16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU16;
typedef void (*UniffiForeignFutureCompleteU16)(
    uint64_t callback_data, UniffiForeignFutureStructU16 result);
typedef struct UniffiForeignFutureStructI16 {
  int16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI16;
typedef void (*UniffiForeignFutureCompleteI16)(
    uint64_t callback_data, UniffiForeignFutureStructI16 result);
typedef struct UniffiForeignFutureStructU32 {
  uint32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU32;
typedef void (*UniffiForeignFutureCompleteU32)(
    uint64_t callback_data, UniffiForeignFutureStructU32 result);
typedef struct UniffiForeignFutureStructI32 {
  int32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI32;
typedef void (*UniffiForeignFutureCompleteI32)(
    uint64_t callback_data, UniffiForeignFutureStructI32 result);
typedef struct UniffiForeignFutureStructU64 {
  uint64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU64;
typedef void (*UniffiForeignFutureCompleteU64)(
    uint64_t callback_data, UniffiForeignFutureStructU64 result);
typedef struct UniffiForeignFutureStructI64 {
  int64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI64;
typedef void (*UniffiForeignFutureCompleteI64)(
    uint64_t callback_data, UniffiForeignFutureStructI64 result);
typedef struct UniffiForeignFutureStructF32 {
  float return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF32;
typedef void (*UniffiForeignFutureCompleteF32)(
    uint64_t callback_data, UniffiForeignFutureStructF32 result);
typedef struct UniffiForeignFutureStructF64 {
  double return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF64;
typedef void (*UniffiForeignFutureCompleteF64)(
    uint64_t callback_data, UniffiForeignFutureStructF64 result);
typedef struct UniffiForeignFutureStructPointer {
  void *return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructPointer;
typedef void (*UniffiForeignFutureCompletePointer)(
    uint64_t callback_data, UniffiForeignFutureStructPointer result);
typedef struct UniffiForeignFutureStructRustBuffer {
  RustBuffer return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructRustBuffer;
typedef void (*UniffiForeignFutureCompleteRustBuffer)(
    uint64_t callback_data, UniffiForeignFutureStructRustBuffer result);
typedef struct UniffiForeignFutureStructVoid {
  RustCallStatus call_status;
} UniffiForeignFutureStructVoid;
typedef void (*UniffiForeignFutureCompleteVoid)(
    uint64_t callback_data, UniffiForeignFutureStructVoid result);
typedef void (*UniffiCallbackInterfaceEventListenerMethod0)(
    uint64_t uniffi_handle, RustBuffer e, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceLoggerMethod0)(
    uint64_t uniffi_handle, RustBuffer l, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfacePluginMethod0)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfacePluginMethod1)(
    uint64_t uniffi_handle, void *sdk, void *storage, void *event_emitter,
    void *uniffi_out_return, RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfacePluginMethod2)(
    uint64_t uniffi_handle, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod0)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod1)(
    uint64_t uniffi_handle, RustBuffer derivation_path,
    RustBuffer *uniffi_out_return, RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod2)(
    uint64_t uniffi_handle, RustBuffer msg, RustBuffer derivation_path,
    RustBuffer *uniffi_out_return, RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod3)(
    uint64_t uniffi_handle, RustBuffer msg, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod4)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod5)(
    uint64_t uniffi_handle, RustBuffer msg, RustBuffer derivation_path,
    RustBuffer *uniffi_out_return, RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod6)(
    uint64_t uniffi_handle, RustBuffer msg, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSignerMethod7)(
    uint64_t uniffi_handle, RustBuffer msg, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef struct UniffiVTableCallbackInterfaceEventListener {
  UniffiCallbackInterfaceEventListenerMethod0 on_event;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceEventListener;
typedef struct UniffiVTableCallbackInterfaceLogger {
  UniffiCallbackInterfaceLoggerMethod0 log;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceLogger;
typedef struct UniffiVTableCallbackInterfacePlugin {
  UniffiCallbackInterfacePluginMethod0 id;
  UniffiCallbackInterfacePluginMethod1 on_start;
  UniffiCallbackInterfacePluginMethod2 on_stop;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfacePlugin;
typedef struct UniffiVTableCallbackInterfaceSigner {
  UniffiCallbackInterfaceSignerMethod0 xpub;
  UniffiCallbackInterfaceSignerMethod1 derive_xpub;
  UniffiCallbackInterfaceSignerMethod2 sign_ecdsa;
  UniffiCallbackInterfaceSignerMethod3 sign_ecdsa_recoverable;
  UniffiCallbackInterfaceSignerMethod4 slip77_master_blinding_key;
  UniffiCallbackInterfaceSignerMethod5 hmac_sha256;
  UniffiCallbackInterfaceSignerMethod6 ecies_encrypt;
  UniffiCallbackInterfaceSignerMethod7 ecies_decrypt;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceSigner;
void *uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
    void *ptr, uint64_t listener, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
    void *ptr, RustBuffer req_data, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
    void *ptr, RustBuffer input, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
    void *ptr, RustBuffer webhook_url, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
    void *ptr, RustBuffer id, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
    void *ptr, RustBuffer req, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
    void *ptr, RustBuffer event, RustCallStatus *uniffi_out_err);
void *uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
    void *ptr, RustBuffer key, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
    void *ptr, RustBuffer key, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
    void *ptr, RustBuffer key, RustBuffer value,
    RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(
    UniffiVTableCallbackInterfaceEventListener *vtable);
void uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(
    UniffiVTableCallbackInterfaceLogger *vtable);
void uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(
    UniffiVTableCallbackInterfacePlugin *vtable);
void uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(
    UniffiVTableCallbackInterfaceSigner *vtable);
void *uniffi_breez_sdk_liquid_bindings_fn_func_connect(
    RustBuffer req, RustBuffer plugins, RustCallStatus *uniffi_out_err);
void *uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
    RustBuffer req, uint64_t signer, RustBuffer plugins,
    RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
    RustBuffer network, RustBuffer breez_api_key,
    RustCallStatus *uniffi_out_err);
RustBuffer uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
    RustBuffer input, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
    uint64_t logger, RustCallStatus *uniffi_out_err);
RustBuffer
ffi_breez_sdk_liquid_bindings_rustbuffer_alloc(uint64_t size,
                                               RustCallStatus *uniffi_out_err);
RustBuffer ffi_breez_sdk_liquid_bindings_rustbuffer_from_bytes(
    ForeignBytes bytes, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rustbuffer_free(
    RustBuffer buf, RustCallStatus *uniffi_out_err);
RustBuffer ffi_breez_sdk_liquid_bindings_rustbuffer_reserve(
    RustBuffer buf, uint64_t additional, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_u8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_u8(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_u8(
    /*handle*/ uint64_t handle);
uint8_t ffi_breez_sdk_liquid_bindings_rust_future_complete_u8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_i8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_i8(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_i8(
    /*handle*/ uint64_t handle);
int8_t ffi_breez_sdk_liquid_bindings_rust_future_complete_i8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_u16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_u16(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_u16(
    /*handle*/ uint64_t handle);
uint16_t ffi_breez_sdk_liquid_bindings_rust_future_complete_u16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_i16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_i16(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_i16(
    /*handle*/ uint64_t handle);
int16_t ffi_breez_sdk_liquid_bindings_rust_future_complete_i16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_u32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_u32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_u32(
    /*handle*/ uint64_t handle);
uint32_t ffi_breez_sdk_liquid_bindings_rust_future_complete_u32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_i32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_i32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_i32(
    /*handle*/ uint64_t handle);
int32_t ffi_breez_sdk_liquid_bindings_rust_future_complete_i32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_u64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_u64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_u64(
    /*handle*/ uint64_t handle);
uint64_t ffi_breez_sdk_liquid_bindings_rust_future_complete_u64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_i64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_i64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_i64(
    /*handle*/ uint64_t handle);
int64_t ffi_breez_sdk_liquid_bindings_rust_future_complete_i64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_f32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_f32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_f32(
    /*handle*/ uint64_t handle);
float ffi_breez_sdk_liquid_bindings_rust_future_complete_f32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_f64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_f64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_f64(
    /*handle*/ uint64_t handle);
double ffi_breez_sdk_liquid_bindings_rust_future_complete_f64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_pointer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_pointer(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_pointer(
    /*handle*/ uint64_t handle);
void *ffi_breez_sdk_liquid_bindings_rust_future_complete_pointer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_rust_buffer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_rust_buffer(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_rust_buffer(
    /*handle*/ uint64_t handle);
RustBuffer ffi_breez_sdk_liquid_bindings_rust_future_complete_rust_buffer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_liquid_bindings_rust_future_poll_void(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_liquid_bindings_rust_future_cancel_void(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_free_void(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_liquid_bindings_rust_future_complete_void(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_func_connect();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_func_default_config();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key();
uint16_t uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt();
uint16_t
uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt();
uint32_t ffi_breez_sdk_liquid_bindings_uniffi_contract_version();
}

namespace uniffi::breez_sdk_liquid {
template <typename T> struct Bridging;

using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <typename T> struct Bridging<ReferenceHolder<T>> {
  static jsi::Value jsNew(jsi::Runtime &rt) {
    auto holder = jsi::Object(rt);
    return holder;
  }
  static T fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
                  const jsi::Value &value) {
    auto obj = value.asObject(rt);
    if (obj.hasProperty(rt, "pointee")) {
      auto pointee = obj.getProperty(rt, "pointee");
      return uniffi::breez_sdk_liquid::Bridging<T>::fromJs(rt, callInvoker,
                                                           pointee);
    }
    throw jsi::JSError(rt,
                       "Expected ReferenceHolder to have a pointee property. "
                       "This is likely a bug in uniffi-bindgen-react-native");
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustBuffer> {
  static RustBuffer rustbuffer_alloc(int32_t size) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_breez_sdk_liquid_bindings_rustbuffer_alloc(size, &status);
  }

  static void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    ffi_breez_sdk_liquid_bindings_rustbuffer_free(buf, &status);
  }

  static RustBuffer rustbuffer_from_bytes(ForeignBytes bytes) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_breez_sdk_liquid_bindings_rustbuffer_from_bytes(bytes, &status);
  }

  static RustBuffer fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                           const jsi::Value &value) {
    try {
      auto buffer =
          uniffi_jsi::Bridging<jsi::ArrayBuffer>::value_to_arraybuffer(rt,
                                                                       value);
      auto bytes = ForeignBytes{
          .len = static_cast<int32_t>(buffer.length(rt)),
          .data = buffer.data(rt),
      };

      // This buffer is constructed from foreign bytes. Rust scaffolding copies
      // the bytes, to make the RustBuffer.
      auto buf = rustbuffer_from_bytes(bytes);
      // Once it leaves this function, the buffer is immediately passed back
      // into Rust, where it's used to deserialize into the Rust versions of the
      // arguments. At that point, the copy is destroyed.
      return buf;
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                         RustBuffer buf) {
    // We need to make a copy of the bytes from Rust's memory space into
    // Javascripts memory space. We need to do this because the two languages
    // manages memory very differently: a garbage collector needs to track all
    // the memory at runtime, Rust is doing it all closer to compile time.
    uint8_t *bytes = new uint8_t[buf.len];
    std::memcpy(bytes, buf.data, buf.len);

    // Construct an ArrayBuffer with copy of the bytes from the RustBuffer.
    auto payload = std::make_shared<uniffi_jsi::CMutableBuffer>(
        uniffi_jsi::CMutableBuffer((uint8_t *)bytes, buf.len));
    auto arrayBuffer = jsi::ArrayBuffer(rt, payload);

    // Once we have a Javascript version, we no longer need the Rust version, so
    // we can call into Rust to tell it it's okay to free that memory.
    rustbuffer_free(buf);

    // Finally, return the ArrayBuffer.
    return uniffi_jsi::Bridging<jsi::ArrayBuffer>::arraybuffer_to_value(
        rt, arrayBuffer);
    ;
  }
};

} // namespace uniffi::breez_sdk_liquid

namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustCallStatus> {
  static jsi::Value jsSuccess(jsi::Runtime &rt) {
    auto statusObject = jsi::Object(rt);
    statusObject.setProperty(rt, "code", jsi::Value(rt, UNIFFI_CALL_STATUS_OK));
    return statusObject;
  }
  static RustCallStatus rustSuccess(jsi::Runtime &rt) {
    return {UNIFFI_CALL_STATUS_OK};
  }
  static void copyIntoJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         const RustCallStatus status,
                         const jsi::Value &jsStatus) {
    auto statusObject = jsStatus.asObject(rt);
    if (status.error_buf.data != nullptr) {
      auto rbuf = Bridging<RustBuffer>::toJs(rt, callInvoker, status.error_buf);
      statusObject.setProperty(rt, "errorBuf", rbuf);
    }
    if (status.code != UNIFFI_CALL_STATUS_OK) {
      auto code =
          uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, status.code);
      statusObject.setProperty(rt, "code", code);
    }
  }

  static RustCallStatus fromJs(jsi::Runtime &rt,
                               std::shared_ptr<CallInvoker> invoker,
                               const jsi::Value &jsStatus) {
    RustCallStatus status;
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status.error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status.code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
    return status;
  }

  static void copyFromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> invoker,
                         const jsi::Value &jsStatus, RustCallStatus *status) {
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status->error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status->code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
  }
};

} // namespace uniffi::breez_sdk_liquid
// In other uniffi bindings, it is assumed that the foreign language holds on
// to the vtable, which the Rust just gets a pointer to.
// Here, we need to hold on to them, but also be able to clear them at just the
// right time so we can support hot-reloading.
namespace uniffi::breez_sdk_liquid::registry {
template <typename T> class VTableHolder {
public:
  T vtable;
  VTableHolder(T v) : vtable(v) {}
};

// Mutex to bind the storage and setting of vtable together.
// We declare it here, but the lock is taken by callers of the putTable
// method who are also sending a pointer to Rust.
static std::mutex vtableMutex;

// Registry to hold all vtables so they persist even when JS objects are GC'd.
// The only reason this exists is to prevent a dangling pointer in the
// Rust machinery: i.e. we don't need to access or write to this registry
// after startup.
// Registry to hold all vtables so they persist even when JS objects are GC'd.
// Maps string identifiers to vtable holders using type erasure
static std::unordered_map<std::string, std::shared_ptr<void>> vtableRegistry;

// Add a vtable to the registry with an identifier
template <typename T>
static T *putTable(std::string_view identifier, T vtable) {
  auto holder = std::make_shared<VTableHolder<T>>(vtable);
  // Store the raw pointer to the vtable before type erasure
  T *rawPtr = &(holder->vtable);
  // Store the holder using type erasure with the string identifier
  vtableRegistry[std::string(identifier)] = std::shared_ptr<void>(holder);
  return rawPtr;
}

// Clear the registry.
//
// Conceptually, this is called after teardown of the module (i.e. after
// teardown of the jsi::Runtime). However, because Rust is dropping callbacks
// because the Runtime is being torn down, we must keep the registry intact
// until after the runtime goes away.
//
// Therefore, in practice we should call this when the next runtime is
// being stood up.
static void clearRegistry() {
  std::lock_guard<std::mutex> lock(vtableMutex);
  vtableRegistry.clear();
}
} // namespace uniffi::breez_sdk_liquid::registry

// This calls into Rust.
// Implementation of callback function calling from Rust to JS
// RustFutureContinuationCallback

// Callback function:
// uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback::UniffiRustFutureContinuationCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, int8_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue, uint64_t rs_data,
                 int8_t rs_pollResult) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_data = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_data);
  auto js_pollResult =
      uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rs_pollResult);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_data, js_pollResult);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiRustFutureContinuationCallback: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_data, int8_t rs_pollResult) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_data, rs_pollResult);
}

static UniffiRustFutureContinuationCallback
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_data,
                                               int8_t rs_pollResult) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_data,
         rs_pollResult](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_data, rs_pollResult);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureFree, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureFree> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureFree rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureFree"), 1,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureFree func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
  // Implementation of free callback function CallbackInterfaceFree

// Callback function:
// uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::free

// Callback function:
// uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::
    vtablecallbackinterfaceeventlistener::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free

// Callback function:
// uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::
    vtablecallbackinterfacelogger::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free

// Callback function:
// uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::vtablecallbackinterfaceplugin::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::
    vtablecallbackinterfaceplugin::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::vtablecallbackinterfaceplugin::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::vtablecallbackinterfaceplugin::free

// Callback function:
// uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::vtablecallbackinterfacesigner::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::
    vtablecallbackinterfacesigner::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::vtablecallbackinterfacesigner::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::vtablecallbackinterfacesigner::free
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFuture> {
  static UniffiForeignFuture fromJs(jsi::Runtime &rt,
                                    std::shared_ptr<CallInvoker> callInvoker,
                                    const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFuture");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFuture rsObject;

    // Create the vtable from the js callbacks.
    rsObject.handle = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "handle"));
    rsObject.free = uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::
        free::makeCallbackFunction(rt, callInvoker,
                                   jsObject.getProperty(rt, "free"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU8> {
  static UniffiForeignFutureStructU8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU8, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_liquid::Bridging<UniffiForeignFutureStructU8>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI8> {
  static UniffiForeignFutureStructI8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI8, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_liquid::Bridging<UniffiForeignFutureStructI8>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU16> {
  static UniffiForeignFutureStructU16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructU16>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI16> {
  static UniffiForeignFutureStructI16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructI16>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU32> {
  static UniffiForeignFutureStructU32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructU32>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI32> {
  static UniffiForeignFutureStructI32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructI32>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU64> {
  static UniffiForeignFutureStructU64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructU64>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI64> {
  static UniffiForeignFutureStructI64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructI64>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF32> {
  static UniffiForeignFutureStructF32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<float>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructF32>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF64> {
  static UniffiForeignFutureStructF64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<double>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructF64>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructPointer> {
  static UniffiForeignFutureStructPointer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructPointer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructPointer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<void *>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompletePointer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompletePointer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompletePointer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompletePointer"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompletePointer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructPointer>::fromJs(rt, callInvoker,
                                                       args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructRustBuffer> {
  static UniffiForeignFutureStructRustBuffer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructRustBuffer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructRustBuffer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value =
        uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteRustBuffer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteRustBuffer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteRustBuffer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteRustBuffer"),
        2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteRustBuffer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructRustBuffer>::fromJs(rt, callInvoker,
                                                          args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructVoid> {
  static UniffiForeignFutureStructVoid
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructVoid");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructVoid rsObject;

    // Create the vtable from the js callbacks.
    rsObject.call_status =
        uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteVoid, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_liquid {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteVoid> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteVoid rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteVoid"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteVoid func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_liquid::Bridging<
             UniffiForeignFutureStructVoid>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_liquid
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceEventListenerMethod0

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfaceeventlistenermethod0::UniffiCallbackInterfaceEventListenerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfaceeventlistenermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_e,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_e = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_e);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_e);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceEventListenerMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_e,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_e, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceEventListenerMethod0
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfaceeventlistenermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_e,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_e, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_e,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_liquid::cb::callbackinterfaceeventlistenermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceLoggerMethod0

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfaceloggermethod0::UniffiCallbackInterfaceLoggerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfaceloggermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_l,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_l = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_l);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_l);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceLoggerMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_l,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_l, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceLoggerMethod0
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfaceloggermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_l,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_l, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_l,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfaceloggermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfacePluginMethod0

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0::UniffiCallbackInterfacePluginMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfacePluginMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfacePluginMethod0
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfacePluginMethod1

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod1::UniffiCallbackInterfacePluginMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, void *, void *, void *, void *,
                          RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, void *rs_sdk, void *rs_storage,
                 void *rs_eventEmitter, void *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_sdk = uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, rs_sdk);
  auto js_storage =
      uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, rs_storage);
  auto js_eventEmitter =
      uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, rs_eventEmitter);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_sdk, js_storage, js_eventEmitter);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfacePluginMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, void *rs_sdk, void *rs_storage,
                     void *rs_eventEmitter, void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_sdk, rs_storage, rs_eventEmitter,
           rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfacePluginMethod1
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, void *rs_sdk, void *rs_storage,
                 void *rs_eventEmitter, void *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_sdk, rs_storage,
         rs_eventEmitter, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_sdk,
               rs_storage, rs_eventEmitter, rs_uniffiOutReturn,
               uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfacePluginMethod2

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod2::UniffiCallbackInterfacePluginMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, void *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfacePluginMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfacePluginMethod2
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod0

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod0::UniffiCallbackInterfaceSignerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod0
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod1

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod1::UniffiCallbackInterfaceSignerMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_derivationPath,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_derivationPath = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_derivationPath);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_derivationPath);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_derivationPath,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_derivationPath, rs_uniffiOutReturn,
           uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod1
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_derivationPath,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_derivationPath,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_derivationPath, rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod2

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod2::UniffiCallbackInterfaceSignerMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer *,
                          RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer rs_derivationPath, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_msg = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_msg);
  auto js_derivationPath = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_derivationPath);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_msg, js_derivationPath);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                     RustBuffer rs_derivationPath,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_msg, rs_derivationPath, rs_uniffiOutReturn,
           uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod2
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer rs_derivationPath, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_msg, rs_derivationPath,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
               rs_derivationPath, rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod3

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod3::UniffiCallbackInterfaceSignerMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_msg = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_msg);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_msg);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod3: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_msg, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod3
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                             RustBuffer *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod4

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod4::UniffiCallbackInterfaceSignerMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod4: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod4
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod5

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod5::UniffiCallbackInterfaceSignerMethod5
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod5 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer *,
                          RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer rs_derivationPath, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_msg = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_msg);
  auto js_derivationPath = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_derivationPath);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_msg, js_derivationPath);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod5: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                     RustBuffer rs_derivationPath,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_msg, rs_derivationPath, rs_uniffiOutReturn,
           uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod5
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod5
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer rs_derivationPath, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_msg, rs_derivationPath,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
               rs_derivationPath, rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod5
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod6

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod6::UniffiCallbackInterfaceSignerMethod6
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod6 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_msg = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_msg);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_msg);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod6: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_msg, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod6
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod6
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                             RustBuffer *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod6
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSignerMethod7

// Callback function:
// uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod7::UniffiCallbackInterfaceSignerMethod7
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod7 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this…
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_msg = uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_msg);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_msg);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_liquid::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSignerMethod7: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_msg, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSignerMethod7
makeCallbackFunction( // uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod7
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_msg,
                             RustBuffer *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_msg,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkLiquid, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod7
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceEventListener> {
  static UniffiVTableCallbackInterfaceEventListener
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceEventListener");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceEventListener rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_event = uniffi::breez_sdk_liquid::cb::
        callbackinterfaceeventlistenermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onEvent"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::
            vtablecallbackinterfaceeventlistener::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceLogger> {
  static UniffiVTableCallbackInterfaceLogger
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceLogger");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceLogger rsObject;

    // Create the vtable from the js callbacks.
    rsObject.log = uniffi::breez_sdk_liquid::cb::
        callbackinterfaceloggermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "log"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::
            vtablecallbackinterfacelogger::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfacePlugin> {
  static UniffiVTableCallbackInterfacePlugin
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfacePlugin");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfacePlugin rsObject;

    // Create the vtable from the js callbacks.
    rsObject.id = uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0::
        makeCallbackFunction(rt, callInvoker, jsObject.getProperty(rt, "id"));
    rsObject.on_start = uniffi::breez_sdk_liquid::cb::
        callbackinterfacepluginmethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onStart"));
    rsObject.on_stop = uniffi::breez_sdk_liquid::cb::
        callbackinterfacepluginmethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onStop"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::
            vtablecallbackinterfaceplugin::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid
namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceSigner> {
  static UniffiVTableCallbackInterfaceSigner
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceSigner");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceSigner rsObject;

    // Create the vtable from the js callbacks.
    rsObject.xpub = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "xpub"));
    rsObject.derive_xpub = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "deriveXpub"));
    rsObject.sign_ecdsa = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signEcdsa"));
    rsObject.sign_ecdsa_recoverable = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signEcdsaRecoverable"));
    rsObject.slip77_master_blinding_key = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod4::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "slip77MasterBlindingKey"));
    rsObject.hmac_sha256 = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod5::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "hmacSha256"));
    rsObject.ecies_encrypt = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod6::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "eciesEncrypt"));
    rsObject.ecies_decrypt = uniffi::breez_sdk_liquid::cb::
        callbackinterfacesignermethod7::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "eciesDecrypt"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::
            vtablecallbackinterfacesigner::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_liquid

namespace uniffi::breez_sdk_liquid {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiRustFutureContinuationCallback> {
  static UniffiRustFutureContinuationCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &value) {
    try {
      return uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback::
          makeCallbackFunction(rt, callInvoker, value);
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }
};

} // namespace uniffi::breez_sdk_liquid

NativeBreezSdkLiquid::NativeBreezSdkLiquid(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker)
    : callInvoker(invoker), props() {
  // Map from Javascript names to the cpp names
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "fn_clone_bindingliquidsdk"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "accept_payment_proposed_fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_accept_payment_proposed_fees"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_"
        "event_listener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_add_event_listener"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "backup"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_backup"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_"
        "bitcoin"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_buy_bitcoin"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "check_message"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_check_message"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "create_bolt12_invoice"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_create_bolt12_invoice"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "disconnect"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_disconnect"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "fetch_fiat_rates"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_fetch_fiat_rates"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "fetch_lightning_limits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_fetch_lightning_limits"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "fetch_onchain_limits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_fetch_onchain_limits"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "fetch_payment_proposed_fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_fetch_payment_proposed_fees"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_"
        "info"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_get_info"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_"
        "payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_get_payment"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_"
        "fiat_currencies"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_list_fiat_currencies"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_"
        "payments"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_list_payments"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_"
        "refundables"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_list_refundables"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "lnurl_auth"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_lnurl_auth"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "lnurl_pay"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_lnurl_pay"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "lnurl_withdraw"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_lnurl_withdraw"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "parse"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_parse"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_"
        "onchain"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_pay_onchain"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_buy_bitcoin"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_prepare_buy_bitcoin"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_lnurl_pay"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_prepare_lnurl_pay"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_pay_onchain"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_prepare_pay_onchain"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_receive_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_prepare_receive_payment"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_refund"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_prepare_refund"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "prepare_send_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_prepare_send_payment"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "receive_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_receive_payment"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "recommended_fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_recommended_fees"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "refund"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_refund"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "register_webhook"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_register_webhook"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "remove_event_listener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_"
              "bindingliquidsdk_remove_event_listener"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "rescan_onchain_swaps"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_rescan_onchain_swaps"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "restore"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_restore"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_"
        "payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_send_payment"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_"
        "message"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_sign_message"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "sync"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_bindingliquidsdk_sync"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_"
        "unregister_webhook"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                "method_bindingliquidsdk_unregister_webhook"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "fn_clone_plugineventemitter"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "fn_free_plugineventemitter"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_"
        "broadcast"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_plugineventemitter_broadcast"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_"
        "item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_pluginstorage_get_item"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_"
        "item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_pluginstorage_remove_item"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_"
        "item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "method_pluginstorage_set_item"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_connect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_connect"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_liquid_bindings_fn_func_connect(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "fn_func_connect_with_signer"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_default_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_default_config"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_set_logger"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_set_logger"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_connect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_connect"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_connect(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_"
        "signer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_func_connect_with_signer"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_default_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "checksum_func_default_config"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_default_config(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "checksum_func_parse_invoice"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_accept_payment_proposed_fees"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_accept_payment_proposed_fees"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_add_event_listener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_add_event_listener"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_backup"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_bindingliquidsdk_backup"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_buy_bitcoin"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_buy_bitcoin"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_check_message"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_check_message"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_create_bolt12_invoice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_create_bolt12_invoice"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_disconnect"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_disconnect"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_fetch_fiat_rates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_fetch_fiat_rates"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_fetch_lightning_limits"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_fetch_lightning_limits"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_fetch_onchain_limits"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_fetch_onchain_limits"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_fetch_payment_proposed_fees"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_fetch_payment_proposed_fees"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_get_info"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_get_info"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_get_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_get_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_list_fiat_currencies"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_list_fiat_currencies"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_list_payments"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_list_payments"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_list_refundables"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_list_refundables"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_lnurl_auth"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_lnurl_auth"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_lnurl_pay"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_lnurl_pay"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_lnurl_withdraw"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_lnurl_withdraw"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_parse"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_bindingliquidsdk_parse"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_pay_onchain"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_bindingliquidsdk_pay_onchain"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_buy_bitcoin"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_prepare_buy_bitcoin"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_lnurl_pay"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_prepare_lnurl_pay"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_pay_onchain"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_prepare_pay_onchain"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_receive_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_prepare_receive_payment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_refund"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_prepare_refund"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_prepare_send_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_prepare_send_payment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_receive_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_receive_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_recommended_fees"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_recommended_fees"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_refund"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_bindingliquidsdk_refund"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_register_webhook"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_register_webhook"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_remove_event_listener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_remove_event_listener"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_rescan_onchain_swaps"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_rescan_onchain_swaps"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_restore"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_bindingliquidsdk_restore"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_send_payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_send_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_sign_message"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
              "bindingliquidsdk_sign_message"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_sync"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_bindingliquidsdk_sync"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "bindingliquidsdk_unregister_webhook"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
                  "bindingliquidsdk_unregister_webhook"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_"
        "plugineventemitter_broadcast"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_plugineventemitter_broadcast"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_"
        "get_item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_pluginstorage_get_item"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_"
        "remove_item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                "checksum_method_pluginstorage_remove_item"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_"
        "set_item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_pluginstorage_set_item"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_"
        "on_event"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_eventlistener_on_event"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "checksum_method_logger_log"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "checksum_method_plugin_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_"
        "start"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_plugin_on_start"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_"
        "stop"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_plugin_on_stop"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                        "checksum_method_signer_xpub"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_"
        "xpub"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_signer_derive_xpub"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_"
        "ecdsa"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_signer_sign_ecdsa"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_"
        "ecdsa_recoverable"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_"
              "sign_ecdsa_recoverable"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_"
        "master_blinding_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_"
              "slip77_master_blinding_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_"
        "sha256"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_signer_hmac_sha256"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_"
        "encrypt"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_signer_ecies_encrypt"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_"
        "decrypt"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_"
                                    "checksum_method_signer_ecies_decrypt"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt(
                rt, thisVal, args, count);
      });
  props["ubrn_ffi_breez_sdk_liquid_bindings_uniffi_contract_version"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_liquid_bindings_uniffi_contract_version"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_ffi_breez_sdk_liquid_bindings_uniffi_contract_version(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_"
        "eventlistener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "init_callback_vtable_eventlistener"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_"
        "logger"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "init_callback_vtable_logger"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_"
        "plugin"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "init_callback_vtable_plugin"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_"
        "signer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_liquid_bindings_fn_"
                                    "init_callback_vtable_signer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_bindingliquidsdk_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "bindingliquidsdk_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_bindingliquidsdk_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_plugineventemitter_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                    "plugineventemitter_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_plugineventemitter_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_pluginstorage_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "pluginstorage_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_pluginstorage_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
}

void NativeBreezSdkLiquid::registerModule(
    jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
  auto invoker =
      std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
  auto tm = std::make_shared<NativeBreezSdkLiquid>(rt, invoker);
  auto obj = rt.global().createFromHostObject(rt, tm);
  rt.global().setProperty(rt, "NativeBreezSdkLiquid", obj);
}

void NativeBreezSdkLiquid::unregisterModule(jsi::Runtime &rt) {
  uniffi::breez_sdk_liquid::registry::clearRegistry();
}

jsi::Value NativeBreezSdkLiquid::get(jsi::Runtime &rt,
                                     const jsi::PropNameID &name) {
  try {
    return jsi::Value(rt, props.at(name.utf8(rt)));
  } catch (std::out_of_range &e) {
    return jsi::Value::undefined();
  }
}

std::vector<jsi::PropNameID>
NativeBreezSdkLiquid::getPropertyNames(jsi::Runtime &rt) {
  std::vector<jsi::PropNameID> rval;
  for (auto &[key, value] : props) {
    rval.push_back(jsi::PropNameID::forUtf8(rt, key));
  }
  return rval;
}

void NativeBreezSdkLiquid::set(jsi::Runtime &rt, const jsi::PropNameID &name,
                               const jsi::Value &value) {
  props.insert_or_assign(name.utf8(rt), &value);
}

NativeBreezSdkLiquid::~NativeBreezSdkLiquid() {
  // Cleanup for callback function RustFutureContinuationCallback
  uniffi::breez_sdk_liquid::cb::rustfuturecontinuationcallback::cleanup();
  // Cleanup for "free" callback function CallbackInterfaceFree
  uniffi::breez_sdk_liquid::st::foreignfuture::foreignfuture::free::cleanup();
  uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceeventlistener::
      vtablecallbackinterfaceeventlistener::free::cleanup();
  uniffi::breez_sdk_liquid::st::vtablecallbackinterfacelogger::
      vtablecallbackinterfacelogger::free::cleanup();
  uniffi::breez_sdk_liquid::st::vtablecallbackinterfaceplugin::
      vtablecallbackinterfaceplugin::free::cleanup();
  uniffi::breez_sdk_liquid::st::vtablecallbackinterfacesigner::
      vtablecallbackinterfacesigner::free::cleanup();
  // Cleanup for callback function CallbackInterfaceEventListenerMethod0
  uniffi::breez_sdk_liquid::cb::callbackinterfaceeventlistenermethod0::
      cleanup();
  // Cleanup for callback function CallbackInterfaceLoggerMethod0
  uniffi::breez_sdk_liquid::cb::callbackinterfaceloggermethod0::cleanup();
  // Cleanup for callback function CallbackInterfacePluginMethod0
  uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod0::cleanup();
  // Cleanup for callback function CallbackInterfacePluginMethod1
  uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod1::cleanup();
  // Cleanup for callback function CallbackInterfacePluginMethod2
  uniffi::breez_sdk_liquid::cb::callbackinterfacepluginmethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod0
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod1
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod1::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod2
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod3
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod3::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod4
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod4::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod5
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod5::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod6
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod6::cleanup();
  // Cleanup for callback function CallbackInterfaceSignerMethod7
  uniffi::breez_sdk_liquid::cb::callbackinterfacesignermethod7::cleanup();
}

// Utility functions for serialization/deserialization of strings.
jsi::Value
NativeBreezSdkLiquid::cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_bytelength(rt, args[0]);
}

jsi::Value
NativeBreezSdkLiquid::cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_arraybuffer(rt, args[0]);
}

jsi::Value
NativeBreezSdkLiquid::cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::arraybuffer_to_string(rt, args[0]);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_internal_fn_method_bindingliquidsdk_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_internal_fn_method_plugineventemitter_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(pointer,
                                                                &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_internal_fn_method_pluginstorage_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}

// Methods calling directly into the uniffi generated C API of the Rust crate.
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(
              rt, callInvoker, args[1]),
          &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[2]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkLiquid::cpp_uniffi_breez_sdk_liquid_bindings_fn_func_connect(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_func_connect(
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[0]),
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[2]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[0]),
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[1]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
      uniffi::breez_sdk_liquid::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                             args[0]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_liquid::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                              value);
}
jsi::Value
NativeBreezSdkLiquid::cpp_uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::breez_sdk_liquid::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_connect(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_func_connect();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_default_config(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_func_default_config();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkLiquid::cpp_ffi_breez_sdk_liquid_bindings_uniffi_contract_version(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = ffi_breez_sdk_liquid_bindings_uniffi_contract_version();

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_liquid::Bridging<
      UniffiVTableCallbackInterfaceEventListener>::fromJs(rt, callInvoker,
                                                          args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_liquid::registry::vtableMutex);
  uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(
      uniffi::breez_sdk_liquid::registry::putTable(
          "UniffiVTableCallbackInterfaceEventListener", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_liquid::Bridging<
      UniffiVTableCallbackInterfaceLogger>::fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_liquid::registry::vtableMutex);
  uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(
      uniffi::breez_sdk_liquid::registry::putTable(
          "UniffiVTableCallbackInterfaceLogger", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_liquid::Bridging<
      UniffiVTableCallbackInterfacePlugin>::fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_liquid::registry::vtableMutex);
  uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(
      uniffi::breez_sdk_liquid::registry::putTable(
          "UniffiVTableCallbackInterfacePlugin", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkLiquid::
    cpp_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_liquid::Bridging<
      UniffiVTableCallbackInterfaceSigner>::fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_liquid::registry::vtableMutex);
  uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(
      uniffi::breez_sdk_liquid::registry::putTable(
          "UniffiVTableCallbackInterfaceSigner", vtableInstance));
  return jsi::Value::undefined();
}