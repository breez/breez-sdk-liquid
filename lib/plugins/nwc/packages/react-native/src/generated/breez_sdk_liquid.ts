// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceEventListener,
  type UniffiVTableCallbackInterfaceLogger,
  type UniffiVTableCallbackInterfacePlugin,
  type UniffiVTableCallbackInterfaceSigner,
} from './breez_sdk_liquid-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export function connect(
  req: ConnectRequest,
  plugins: Array<Plugin> | undefined
): BindingLiquidSdkInterface /*throws*/ {
  return FfiConverterTypeBindingLiquidSdk.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_connect(
          FfiConverterTypeConnectRequest.lower(req),
          FfiConverterOptionalArrayTypePlugin.lower(plugins),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function connectWithSigner(
  req: ConnectWithSignerRequest,
  signer: Signer,
  plugins: Array<Plugin> | undefined
): BindingLiquidSdkInterface /*throws*/ {
  return FfiConverterTypeBindingLiquidSdk.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
          FfiConverterTypeConnectWithSignerRequest.lower(req),
          FfiConverterTypeSigner.lower(signer),
          FfiConverterOptionalArrayTypePlugin.lower(plugins),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function defaultConfig(
  network: LiquidNetwork,
  breezApiKey: string | undefined
): Config /*throws*/ {
  return FfiConverterTypeConfig.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
          FfiConverterTypeLiquidNetwork.lower(network),
          FfiConverterOptionalString.lower(breezApiKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseInvoice(input: string): LnInvoice /*throws*/ {
  return FfiConverterTypeLNInvoice.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
        FfiConverterTypePaymentError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
          FfiConverterString.lower(input),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function setLogger(logger: Logger): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
        FfiConverterTypeLogger.lower(logger),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}

export interface EventListener {
  onEvent(e: SdkEvent): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventListener: {
  vtable: UniffiVTableCallbackInterfaceEventListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEvent: (uniffiHandle: bigint, e: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeEventListener.lift(uniffiHandle);
        return jsCallback.onEvent(FfiConverterTypeSdkEvent.lift(e));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EventListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEventListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(
      uniffiCallbackInterfaceEventListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventListener = new FfiConverterCallback<EventListener>();

export interface Logger {
  log(l: LogEntry): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogger: {
  vtable: UniffiVTableCallbackInterfaceLogger;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    log: (uniffiHandle: bigint, l: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeLogger.lift(uniffiHandle);
        return jsCallback.log(FfiConverterTypeLogEntry.lift(l));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Logger: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLogger.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(
      uniffiCallbackInterfaceLogger.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogger = new FfiConverterCallback<Logger>();

export interface Plugin {
  id(): string;
  onStart(
    sdk: BindingLiquidSdkInterface,
    storage: PluginStorageInterface,
    eventEmitter: PluginEventEmitterInterface
  ): void;
  onStop(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePlugin: {
  vtable: UniffiVTableCallbackInterfacePlugin;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    id: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): string => {
        const jsCallback = FfiConverterTypePlugin.lift(uniffiHandle);
        return jsCallback.id();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(uniffiResult, FfiConverterString.lower(obj));
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onStart: (
      uniffiHandle: bigint,
      sdk: bigint,
      storage: bigint,
      eventEmitter: bigint
    ) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypePlugin.lift(uniffiHandle);
        return jsCallback.onStart(
          FfiConverterTypeBindingLiquidSdk.lift(sdk),
          FfiConverterTypePluginStorage.lift(storage),
          FfiConverterTypePluginEventEmitter.lift(eventEmitter)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    onStop: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypePlugin.lift(uniffiHandle);
        return jsCallback.onStop();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Plugin: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePlugin.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(
      uniffiCallbackInterfacePlugin.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypePlugin = new FfiConverterCallback<Plugin>();

export interface Signer {
  xpub() /*throws*/ : Array</*u8*/ number>;
  deriveXpub(derivationPath: string) /*throws*/ : Array</*u8*/ number>;
  signEcdsa(
    msg: Array</*u8*/ number>,
    derivationPath: string
  ) /*throws*/ : Array</*u8*/ number>;
  signEcdsaRecoverable(
    msg: Array</*u8*/ number>
  ) /*throws*/ : Array</*u8*/ number>;
  slip77MasterBlindingKey() /*throws*/ : Array</*u8*/ number>;
  hmacSha256(
    msg: Array</*u8*/ number>,
    derivationPath: string
  ) /*throws*/ : Array</*u8*/ number>;
  eciesEncrypt(msg: Array</*u8*/ number>) /*throws*/ : Array</*u8*/ number>;
  eciesDecrypt(msg: Array</*u8*/ number>) /*throws*/ : Array</*u8*/ number>;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSigner: {
  vtable: UniffiVTableCallbackInterfaceSigner;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    xpub: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.xpub();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    deriveXpub: (uniffiHandle: bigint, derivationPath: Uint8Array) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.deriveXpub(FfiConverterString.lift(derivationPath));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    signEcdsa: (
      uniffiHandle: bigint,
      msg: Uint8Array,
      derivationPath: Uint8Array
    ) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.signEcdsa(
          FfiConverterArrayUInt8.lift(msg),
          FfiConverterString.lift(derivationPath)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    signEcdsaRecoverable: (uniffiHandle: bigint, msg: Uint8Array) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.signEcdsaRecoverable(
          FfiConverterArrayUInt8.lift(msg)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    slip77MasterBlindingKey: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.slip77MasterBlindingKey();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    hmacSha256: (
      uniffiHandle: bigint,
      msg: Uint8Array,
      derivationPath: Uint8Array
    ) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.hmacSha256(
          FfiConverterArrayUInt8.lift(msg),
          FfiConverterString.lift(derivationPath)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    eciesEncrypt: (uniffiHandle: bigint, msg: Uint8Array) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.eciesEncrypt(FfiConverterArrayUInt8.lift(msg));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    eciesDecrypt: (uniffiHandle: bigint, msg: Uint8Array) => {
      const uniffiMakeCall = (): Array</*u8*/ number> => {
        const jsCallback = FfiConverterTypeSigner.lift(uniffiHandle);
        return jsCallback.eciesDecrypt(FfiConverterArrayUInt8.lift(msg));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayUInt8.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SignerError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSignerError.lower.bind(
          FfiConverterTypeSignerError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Signer: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSigner.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(
      uniffiCallbackInterfaceSigner.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSigner = new FfiConverterCallback<Signer>();

export type AcceptPaymentProposedFeesRequest = {
  response: FetchPaymentProposedFeesResponse;
};

/**
 * Generated factory for {@link AcceptPaymentProposedFeesRequest} record objects.
 */
export const AcceptPaymentProposedFeesRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AcceptPaymentProposedFeesRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AcceptPaymentProposedFeesRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AcceptPaymentProposedFeesRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<AcceptPaymentProposedFeesRequest>,
  });
})();

const FfiConverterTypeAcceptPaymentProposedFeesRequest = (() => {
  type TypeName = AcceptPaymentProposedFeesRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        response: FfiConverterTypeFetchPaymentProposedFeesResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFetchPaymentProposedFeesResponse.write(
        value.response,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeFetchPaymentProposedFeesResponse.allocationSize(
        value.response
      );
    }
  }
  return new FFIConverter();
})();

export type AesSuccessActionData = {
  description: string;
  ciphertext: string;
  iv: string;
};

/**
 * Generated factory for {@link AesSuccessActionData} record objects.
 */
export const AesSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AesSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AesSuccessActionData>,
  });
})();

const FfiConverterTypeAesSuccessActionData = (() => {
  type TypeName = AesSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        ciphertext: FfiConverterString.read(from),
        iv: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.ciphertext, into);
      FfiConverterString.write(value.iv, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.ciphertext) +
        FfiConverterString.allocationSize(value.iv)
      );
    }
  }
  return new FFIConverter();
})();

export type AesSuccessActionDataDecrypted = {
  description: string;
  plaintext: string;
};

/**
 * Generated factory for {@link AesSuccessActionDataDecrypted} record objects.
 */
export const AesSuccessActionDataDecrypted = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AesSuccessActionDataDecrypted,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<AesSuccessActionDataDecrypted>,
  });
})();

const FfiConverterTypeAesSuccessActionDataDecrypted = (() => {
  type TypeName = AesSuccessActionDataDecrypted;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        plaintext: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.plaintext, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.plaintext)
      );
    }
  }
  return new FFIConverter();
})();

export type AssetBalance = {
  assetId: string;
  balanceSat: /*u64*/ bigint;
  name: string | undefined;
  ticker: string | undefined;
  balance: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link AssetBalance} record objects.
 */
export const AssetBalance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AssetBalance, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AssetBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AssetBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AssetBalance>,
  });
})();

const FfiConverterTypeAssetBalance = (() => {
  type TypeName = AssetBalance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        assetId: FfiConverterString.read(from),
        balanceSat: FfiConverterUInt64.read(from),
        name: FfiConverterOptionalString.read(from),
        ticker: FfiConverterOptionalString.read(from),
        balance: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.assetId, into);
      FfiConverterUInt64.write(value.balanceSat, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.ticker, into);
      FfiConverterOptionalFloat64.write(value.balance, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.assetId) +
        FfiConverterUInt64.allocationSize(value.balanceSat) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.ticker) +
        FfiConverterOptionalFloat64.allocationSize(value.balance)
      );
    }
  }
  return new FFIConverter();
})();

export type AssetInfo = {
  name: string;
  ticker: string;
  amount: /*f64*/ number;
  fees: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link AssetInfo} record objects.
 */
export const AssetInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AssetInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AssetInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AssetInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AssetInfo>,
  });
})();

const FfiConverterTypeAssetInfo = (() => {
  type TypeName = AssetInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        ticker: FfiConverterString.read(from),
        amount: FfiConverterFloat64.read(from),
        fees: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.ticker, into);
      FfiConverterFloat64.write(value.amount, into);
      FfiConverterOptionalFloat64.write(value.fees, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.ticker) +
        FfiConverterFloat64.allocationSize(value.amount) +
        FfiConverterOptionalFloat64.allocationSize(value.fees)
      );
    }
  }
  return new FFIConverter();
})();

export type AssetMetadata = {
  assetId: string;
  name: string;
  ticker: string;
  precision: /*u8*/ number;
  fiatId: string | undefined;
};

/**
 * Generated factory for {@link AssetMetadata} record objects.
 */
export const AssetMetadata = (() => {
  const defaults = () => ({ fiatId: undefined });
  const create = (() => {
    return uniffiCreateRecord<AssetMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AssetMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AssetMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AssetMetadata>,
  });
})();

const FfiConverterTypeAssetMetadata = (() => {
  type TypeName = AssetMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        assetId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        ticker: FfiConverterString.read(from),
        precision: FfiConverterUInt8.read(from),
        fiatId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.assetId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.ticker, into);
      FfiConverterUInt8.write(value.precision, into);
      FfiConverterOptionalString.write(value.fiatId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.assetId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.ticker) +
        FfiConverterUInt8.allocationSize(value.precision) +
        FfiConverterOptionalString.allocationSize(value.fiatId)
      );
    }
  }
  return new FFIConverter();
})();

export type BackupRequest = {
  backupPath: string | undefined;
};

/**
 * Generated factory for {@link BackupRequest} record objects.
 */
export const BackupRequest = (() => {
  const defaults = () => ({ backupPath: undefined });
  const create = (() => {
    return uniffiCreateRecord<BackupRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BackupRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BackupRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BackupRequest>,
  });
})();

const FfiConverterTypeBackupRequest = (() => {
  type TypeName = BackupRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        backupPath: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.backupPath, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalString.allocationSize(value.backupPath);
    }
  }
  return new FFIConverter();
})();

export type BitcoinAddressData = {
  address: string;
  network: Network;
  amountSat: /*u64*/ bigint | undefined;
  label: string | undefined;
  message: string | undefined;
};

/**
 * Generated factory for {@link BitcoinAddressData} record objects.
 */
export const BitcoinAddressData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<BitcoinAddressData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BitcoinAddressData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BitcoinAddressData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BitcoinAddressData>,
  });
})();

const FfiConverterTypeBitcoinAddressData = (() => {
  type TypeName = BitcoinAddressData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        amountSat: FfiConverterOptionalUInt64.read(from),
        label: FfiConverterOptionalString.read(from),
        message: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterOptionalUInt64.write(value.amountSat, into);
      FfiConverterOptionalString.write(value.label, into);
      FfiConverterOptionalString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterOptionalUInt64.allocationSize(value.amountSat) +
        FfiConverterOptionalString.allocationSize(value.label) +
        FfiConverterOptionalString.allocationSize(value.message)
      );
    }
  }
  return new FFIConverter();
})();

export type BlockchainInfo = {
  liquidTip: /*u32*/ number;
  bitcoinTip: /*u32*/ number;
};

/**
 * Generated factory for {@link BlockchainInfo} record objects.
 */
export const BlockchainInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<BlockchainInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BlockchainInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BlockchainInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BlockchainInfo>,
  });
})();

const FfiConverterTypeBlockchainInfo = (() => {
  type TypeName = BlockchainInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        liquidTip: FfiConverterUInt32.read(from),
        bitcoinTip: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.liquidTip, into);
      FfiConverterUInt32.write(value.bitcoinTip, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.liquidTip) +
        FfiConverterUInt32.allocationSize(value.bitcoinTip)
      );
    }
  }
  return new FFIConverter();
})();

export type BuyBitcoinRequest = {
  prepareResponse: PrepareBuyBitcoinResponse;
  redirectUrl: string | undefined;
};

/**
 * Generated factory for {@link BuyBitcoinRequest} record objects.
 */
export const BuyBitcoinRequest = (() => {
  const defaults = () => ({ redirectUrl: undefined });
  const create = (() => {
    return uniffiCreateRecord<BuyBitcoinRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BuyBitcoinRequest>,
  });
})();

const FfiConverterTypeBuyBitcoinRequest = (() => {
  type TypeName = BuyBitcoinRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareBuyBitcoinResponse.read(from),
        redirectUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareBuyBitcoinResponse.write(
        value.prepareResponse,
        into
      );
      FfiConverterOptionalString.write(value.redirectUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareBuyBitcoinResponse.allocationSize(
          value.prepareResponse
        ) + FfiConverterOptionalString.allocationSize(value.redirectUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type CheckMessageRequest = {
  message: string;
  pubkey: string;
  signature: string;
};

/**
 * Generated factory for {@link CheckMessageRequest} record objects.
 */
export const CheckMessageRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CheckMessageRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CheckMessageRequest>,
  });
})();

const FfiConverterTypeCheckMessageRequest = (() => {
  type TypeName = CheckMessageRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
        pubkey: FfiConverterString.read(from),
        signature: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.pubkey, into);
      FfiConverterString.write(value.signature, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.pubkey) +
        FfiConverterString.allocationSize(value.signature)
      );
    }
  }
  return new FFIConverter();
})();

export type CheckMessageResponse = {
  isValid: boolean;
};

/**
 * Generated factory for {@link CheckMessageResponse} record objects.
 */
export const CheckMessageResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CheckMessageResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CheckMessageResponse>,
  });
})();

const FfiConverterTypeCheckMessageResponse = (() => {
  type TypeName = CheckMessageResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        isValid: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.isValid, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterBool.allocationSize(value.isValid);
    }
  }
  return new FFIConverter();
})();

export type Config = {
  liquidExplorer: BlockchainExplorer;
  bitcoinExplorer: BlockchainExplorer;
  workingDir: string;
  network: LiquidNetwork;
  paymentTimeoutSec: /*u64*/ bigint;
  syncServiceUrl: string | undefined;
  breezApiKey: string | undefined;
  zeroConfMaxAmountSat: /*u64*/ bigint | undefined;
  useDefaultExternalInputParsers: boolean;
  useMagicRoutingHints: boolean;
  externalInputParsers: Array<ExternalInputParser> | undefined;
  onchainFeeRateLeewaySat: /*u64*/ bigint | undefined;
  assetMetadata: Array<AssetMetadata> | undefined;
  sideswapApiKey: string | undefined;
};

/**
 * Generated factory for {@link Config} record objects.
 */
export const Config = (() => {
  const defaults = () => ({
    useDefaultExternalInputParsers: true,
    useMagicRoutingHints: true,
    externalInputParsers: undefined,
    onchainFeeRateLeewaySat: undefined,
    assetMetadata: undefined,
    sideswapApiKey: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<Config, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Config>,
  });
})();

const FfiConverterTypeConfig = (() => {
  type TypeName = Config;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        liquidExplorer: FfiConverterTypeBlockchainExplorer.read(from),
        bitcoinExplorer: FfiConverterTypeBlockchainExplorer.read(from),
        workingDir: FfiConverterString.read(from),
        network: FfiConverterTypeLiquidNetwork.read(from),
        paymentTimeoutSec: FfiConverterUInt64.read(from),
        syncServiceUrl: FfiConverterOptionalString.read(from),
        breezApiKey: FfiConverterOptionalString.read(from),
        zeroConfMaxAmountSat: FfiConverterOptionalUInt64.read(from),
        useDefaultExternalInputParsers: FfiConverterBool.read(from),
        useMagicRoutingHints: FfiConverterBool.read(from),
        externalInputParsers:
          FfiConverterOptionalArrayTypeExternalInputParser.read(from),
        onchainFeeRateLeewaySat: FfiConverterOptionalUInt64.read(from),
        assetMetadata: FfiConverterOptionalArrayTypeAssetMetadata.read(from),
        sideswapApiKey: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeBlockchainExplorer.write(value.liquidExplorer, into);
      FfiConverterTypeBlockchainExplorer.write(value.bitcoinExplorer, into);
      FfiConverterString.write(value.workingDir, into);
      FfiConverterTypeLiquidNetwork.write(value.network, into);
      FfiConverterUInt64.write(value.paymentTimeoutSec, into);
      FfiConverterOptionalString.write(value.syncServiceUrl, into);
      FfiConverterOptionalString.write(value.breezApiKey, into);
      FfiConverterOptionalUInt64.write(value.zeroConfMaxAmountSat, into);
      FfiConverterBool.write(value.useDefaultExternalInputParsers, into);
      FfiConverterBool.write(value.useMagicRoutingHints, into);
      FfiConverterOptionalArrayTypeExternalInputParser.write(
        value.externalInputParsers,
        into
      );
      FfiConverterOptionalUInt64.write(value.onchainFeeRateLeewaySat, into);
      FfiConverterOptionalArrayTypeAssetMetadata.write(
        value.assetMetadata,
        into
      );
      FfiConverterOptionalString.write(value.sideswapApiKey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeBlockchainExplorer.allocationSize(
          value.liquidExplorer
        ) +
        FfiConverterTypeBlockchainExplorer.allocationSize(
          value.bitcoinExplorer
        ) +
        FfiConverterString.allocationSize(value.workingDir) +
        FfiConverterTypeLiquidNetwork.allocationSize(value.network) +
        FfiConverterUInt64.allocationSize(value.paymentTimeoutSec) +
        FfiConverterOptionalString.allocationSize(value.syncServiceUrl) +
        FfiConverterOptionalString.allocationSize(value.breezApiKey) +
        FfiConverterOptionalUInt64.allocationSize(value.zeroConfMaxAmountSat) +
        FfiConverterBool.allocationSize(value.useDefaultExternalInputParsers) +
        FfiConverterBool.allocationSize(value.useMagicRoutingHints) +
        FfiConverterOptionalArrayTypeExternalInputParser.allocationSize(
          value.externalInputParsers
        ) +
        FfiConverterOptionalUInt64.allocationSize(
          value.onchainFeeRateLeewaySat
        ) +
        FfiConverterOptionalArrayTypeAssetMetadata.allocationSize(
          value.assetMetadata
        ) +
        FfiConverterOptionalString.allocationSize(value.sideswapApiKey)
      );
    }
  }
  return new FFIConverter();
})();

export type ConnectRequest = {
  config: Config;
  mnemonic: string | undefined;
  passphrase: string | undefined;
  seed: Array</*u8*/ number> | undefined;
};

/**
 * Generated factory for {@link ConnectRequest} record objects.
 */
export const ConnectRequest = (() => {
  const defaults = () => ({
    mnemonic: undefined,
    passphrase: undefined,
    seed: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<ConnectRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ConnectRequest>,
  });
})();

const FfiConverterTypeConnectRequest = (() => {
  type TypeName = ConnectRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        config: FfiConverterTypeConfig.read(from),
        mnemonic: FfiConverterOptionalString.read(from),
        passphrase: FfiConverterOptionalString.read(from),
        seed: FfiConverterOptionalArrayUInt8.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeConfig.write(value.config, into);
      FfiConverterOptionalString.write(value.mnemonic, into);
      FfiConverterOptionalString.write(value.passphrase, into);
      FfiConverterOptionalArrayUInt8.write(value.seed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeConfig.allocationSize(value.config) +
        FfiConverterOptionalString.allocationSize(value.mnemonic) +
        FfiConverterOptionalString.allocationSize(value.passphrase) +
        FfiConverterOptionalArrayUInt8.allocationSize(value.seed)
      );
    }
  }
  return new FFIConverter();
})();

export type ConnectWithSignerRequest = {
  config: Config;
};

/**
 * Generated factory for {@link ConnectWithSignerRequest} record objects.
 */
export const ConnectWithSignerRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ConnectWithSignerRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectWithSignerRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConnectWithSignerRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ConnectWithSignerRequest>,
  });
})();

const FfiConverterTypeConnectWithSignerRequest = (() => {
  type TypeName = ConnectWithSignerRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        config: FfiConverterTypeConfig.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeConfig.write(value.config, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeConfig.allocationSize(value.config);
    }
  }
  return new FFIConverter();
})();

export type CreateBolt12InvoiceRequest = {
  offer: string;
  invoiceRequest: string;
};

/**
 * Generated factory for {@link CreateBolt12InvoiceRequest} record objects.
 */
export const CreateBolt12InvoiceRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CreateBolt12InvoiceRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CreateBolt12InvoiceRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CreateBolt12InvoiceRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CreateBolt12InvoiceRequest>,
  });
})();

const FfiConverterTypeCreateBolt12InvoiceRequest = (() => {
  type TypeName = CreateBolt12InvoiceRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        offer: FfiConverterString.read(from),
        invoiceRequest: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.offer, into);
      FfiConverterString.write(value.invoiceRequest, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.offer) +
        FfiConverterString.allocationSize(value.invoiceRequest)
      );
    }
  }
  return new FFIConverter();
})();

export type CreateBolt12InvoiceResponse = {
  invoice: string;
};

/**
 * Generated factory for {@link CreateBolt12InvoiceResponse} record objects.
 */
export const CreateBolt12InvoiceResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CreateBolt12InvoiceResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CreateBolt12InvoiceResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CreateBolt12InvoiceResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CreateBolt12InvoiceResponse>,
  });
})();

const FfiConverterTypeCreateBolt12InvoiceResponse = (() => {
  type TypeName = CreateBolt12InvoiceResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoice: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.invoice, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.invoice);
    }
  }
  return new FFIConverter();
})();

export type CurrencyInfo = {
  name: string;
  fractionSize: /*u32*/ number;
  spacing: /*u32*/ number | undefined;
  symbol: Symbol | undefined;
  uniqSymbol: Symbol | undefined;
  localizedName: Array<LocalizedName>;
  localeOverrides: Array<LocaleOverrides>;
};

/**
 * Generated factory for {@link CurrencyInfo} record objects.
 */
export const CurrencyInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CurrencyInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CurrencyInfo>,
  });
})();

const FfiConverterTypeCurrencyInfo = (() => {
  type TypeName = CurrencyInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        fractionSize: FfiConverterUInt32.read(from),
        spacing: FfiConverterOptionalUInt32.read(from),
        symbol: FfiConverterOptionalTypeSymbol.read(from),
        uniqSymbol: FfiConverterOptionalTypeSymbol.read(from),
        localizedName: FfiConverterArrayTypeLocalizedName.read(from),
        localeOverrides: FfiConverterArrayTypeLocaleOverrides.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterUInt32.write(value.fractionSize, into);
      FfiConverterOptionalUInt32.write(value.spacing, into);
      FfiConverterOptionalTypeSymbol.write(value.symbol, into);
      FfiConverterOptionalTypeSymbol.write(value.uniqSymbol, into);
      FfiConverterArrayTypeLocalizedName.write(value.localizedName, into);
      FfiConverterArrayTypeLocaleOverrides.write(value.localeOverrides, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterUInt32.allocationSize(value.fractionSize) +
        FfiConverterOptionalUInt32.allocationSize(value.spacing) +
        FfiConverterOptionalTypeSymbol.allocationSize(value.symbol) +
        FfiConverterOptionalTypeSymbol.allocationSize(value.uniqSymbol) +
        FfiConverterArrayTypeLocalizedName.allocationSize(value.localizedName) +
        FfiConverterArrayTypeLocaleOverrides.allocationSize(
          value.localeOverrides
        )
      );
    }
  }
  return new FFIConverter();
})();

export type ExternalInputParser = {
  providerId: string;
  inputRegex: string;
  parserUrl: string;
};

/**
 * Generated factory for {@link ExternalInputParser} record objects.
 */
export const ExternalInputParser = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ExternalInputParser, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ExternalInputParser>,
  });
})();

const FfiConverterTypeExternalInputParser = (() => {
  type TypeName = ExternalInputParser;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        providerId: FfiConverterString.read(from),
        inputRegex: FfiConverterString.read(from),
        parserUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.providerId, into);
      FfiConverterString.write(value.inputRegex, into);
      FfiConverterString.write(value.parserUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.providerId) +
        FfiConverterString.allocationSize(value.inputRegex) +
        FfiConverterString.allocationSize(value.parserUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type FetchPaymentProposedFeesRequest = {
  swapId: string;
};

/**
 * Generated factory for {@link FetchPaymentProposedFeesRequest} record objects.
 */
export const FetchPaymentProposedFeesRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FetchPaymentProposedFeesRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FetchPaymentProposedFeesRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FetchPaymentProposedFeesRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FetchPaymentProposedFeesRequest>,
  });
})();

const FfiConverterTypeFetchPaymentProposedFeesRequest = (() => {
  type TypeName = FetchPaymentProposedFeesRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        swapId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.swapId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.swapId);
    }
  }
  return new FFIConverter();
})();

export type FetchPaymentProposedFeesResponse = {
  swapId: string;
  feesSat: /*u64*/ bigint;
  payerAmountSat: /*u64*/ bigint;
  receiverAmountSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FetchPaymentProposedFeesResponse} record objects.
 */
export const FetchPaymentProposedFeesResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FetchPaymentProposedFeesResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FetchPaymentProposedFeesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FetchPaymentProposedFeesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FetchPaymentProposedFeesResponse>,
  });
})();

const FfiConverterTypeFetchPaymentProposedFeesResponse = (() => {
  type TypeName = FetchPaymentProposedFeesResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        swapId: FfiConverterString.read(from),
        feesSat: FfiConverterUInt64.read(from),
        payerAmountSat: FfiConverterUInt64.read(from),
        receiverAmountSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.swapId, into);
      FfiConverterUInt64.write(value.feesSat, into);
      FfiConverterUInt64.write(value.payerAmountSat, into);
      FfiConverterUInt64.write(value.receiverAmountSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.swapId) +
        FfiConverterUInt64.allocationSize(value.feesSat) +
        FfiConverterUInt64.allocationSize(value.payerAmountSat) +
        FfiConverterUInt64.allocationSize(value.receiverAmountSat)
      );
    }
  }
  return new FFIConverter();
})();

export type FiatCurrency = {
  id: string;
  info: CurrencyInfo;
};

/**
 * Generated factory for {@link FiatCurrency} record objects.
 */
export const FiatCurrency = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FiatCurrency, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FiatCurrency>,
  });
})();

const FfiConverterTypeFiatCurrency = (() => {
  type TypeName = FiatCurrency;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        info: FfiConverterTypeCurrencyInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypeCurrencyInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypeCurrencyInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type GetInfoResponse = {
  walletInfo: WalletInfo;
  blockchainInfo: BlockchainInfo;
};

/**
 * Generated factory for {@link GetInfoResponse} record objects.
 */
export const GetInfoResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoResponse>,
  });
})();

const FfiConverterTypeGetInfoResponse = (() => {
  type TypeName = GetInfoResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        walletInfo: FfiConverterTypeWalletInfo.read(from),
        blockchainInfo: FfiConverterTypeBlockchainInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWalletInfo.write(value.walletInfo, into);
      FfiConverterTypeBlockchainInfo.write(value.blockchainInfo, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeWalletInfo.allocationSize(value.walletInfo) +
        FfiConverterTypeBlockchainInfo.allocationSize(value.blockchainInfo)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * ///////////////////////////////
 */
export type LnInvoice = {
  bolt11: string;
  network: Network;
  payeePubkey: string;
  paymentHash: string;
  description: string | undefined;
  descriptionHash: string | undefined;
  amountMsat: /*u64*/ bigint | undefined;
  timestamp: /*u64*/ bigint;
  expiry: /*u64*/ bigint;
  routingHints: Array<RouteHint>;
  paymentSecret: Array</*u8*/ number>;
  minFinalCltvExpiryDelta: /*u64*/ bigint;
};

/**
 * Generated factory for {@link LnInvoice} record objects.
 */
export const LnInvoice = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnInvoice, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnInvoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnInvoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnInvoice>,
  });
})();

const FfiConverterTypeLNInvoice = (() => {
  type TypeName = LnInvoice;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        bolt11: FfiConverterString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        payeePubkey: FfiConverterString.read(from),
        paymentHash: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        descriptionHash: FfiConverterOptionalString.read(from),
        amountMsat: FfiConverterOptionalUInt64.read(from),
        timestamp: FfiConverterUInt64.read(from),
        expiry: FfiConverterUInt64.read(from),
        routingHints: FfiConverterArrayTypeRouteHint.read(from),
        paymentSecret: FfiConverterArrayUInt8.read(from),
        minFinalCltvExpiryDelta: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.bolt11, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterString.write(value.payeePubkey, into);
      FfiConverterString.write(value.paymentHash, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.descriptionHash, into);
      FfiConverterOptionalUInt64.write(value.amountMsat, into);
      FfiConverterUInt64.write(value.timestamp, into);
      FfiConverterUInt64.write(value.expiry, into);
      FfiConverterArrayTypeRouteHint.write(value.routingHints, into);
      FfiConverterArrayUInt8.write(value.paymentSecret, into);
      FfiConverterUInt64.write(value.minFinalCltvExpiryDelta, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.bolt11) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterString.allocationSize(value.payeePubkey) +
        FfiConverterString.allocationSize(value.paymentHash) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.descriptionHash) +
        FfiConverterOptionalUInt64.allocationSize(value.amountMsat) +
        FfiConverterUInt64.allocationSize(value.timestamp) +
        FfiConverterUInt64.allocationSize(value.expiry) +
        FfiConverterArrayTypeRouteHint.allocationSize(value.routingHints) +
        FfiConverterArrayUInt8.allocationSize(value.paymentSecret) +
        FfiConverterUInt64.allocationSize(value.minFinalCltvExpiryDelta)
      );
    }
  }
  return new FFIConverter();
})();

export type LnOffer = {
  offer: string;
  chains: Array<string>;
  paths: Array<LnOfferBlindedPath>;
  description: string | undefined;
  signingPubkey: string | undefined;
  minAmount: Amount | undefined;
  absoluteExpiry: /*u64*/ bigint | undefined;
  issuer: string | undefined;
};

/**
 * Generated factory for {@link LnOffer} record objects.
 */
export const LnOffer = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnOffer, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnOffer}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnOffer}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnOffer>,
  });
})();

const FfiConverterTypeLNOffer = (() => {
  type TypeName = LnOffer;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        offer: FfiConverterString.read(from),
        chains: FfiConverterArrayString.read(from),
        paths: FfiConverterArrayTypeLnOfferBlindedPath.read(from),
        description: FfiConverterOptionalString.read(from),
        signingPubkey: FfiConverterOptionalString.read(from),
        minAmount: FfiConverterOptionalTypeAmount.read(from),
        absoluteExpiry: FfiConverterOptionalUInt64.read(from),
        issuer: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.offer, into);
      FfiConverterArrayString.write(value.chains, into);
      FfiConverterArrayTypeLnOfferBlindedPath.write(value.paths, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.signingPubkey, into);
      FfiConverterOptionalTypeAmount.write(value.minAmount, into);
      FfiConverterOptionalUInt64.write(value.absoluteExpiry, into);
      FfiConverterOptionalString.write(value.issuer, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.offer) +
        FfiConverterArrayString.allocationSize(value.chains) +
        FfiConverterArrayTypeLnOfferBlindedPath.allocationSize(value.paths) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.signingPubkey) +
        FfiConverterOptionalTypeAmount.allocationSize(value.minAmount) +
        FfiConverterOptionalUInt64.allocationSize(value.absoluteExpiry) +
        FfiConverterOptionalString.allocationSize(value.issuer)
      );
    }
  }
  return new FFIConverter();
})();

export type LightningPaymentLimitsResponse = {
  send: Limits;
  receive: Limits;
};

/**
 * Generated factory for {@link LightningPaymentLimitsResponse} record objects.
 */
export const LightningPaymentLimitsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LightningPaymentLimitsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LightningPaymentLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LightningPaymentLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LightningPaymentLimitsResponse>,
  });
})();

const FfiConverterTypeLightningPaymentLimitsResponse = (() => {
  type TypeName = LightningPaymentLimitsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        send: FfiConverterTypeLimits.read(from),
        receive: FfiConverterTypeLimits.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLimits.write(value.send, into);
      FfiConverterTypeLimits.write(value.receive, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLimits.allocationSize(value.send) +
        FfiConverterTypeLimits.allocationSize(value.receive)
      );
    }
  }
  return new FFIConverter();
})();

export type Limits = {
  minSat: /*u64*/ bigint;
  maxSat: /*u64*/ bigint;
  maxZeroConfSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link Limits} record objects.
 */
export const Limits = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Limits, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Limits}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Limits}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Limits>,
  });
})();

const FfiConverterTypeLimits = (() => {
  type TypeName = Limits;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        minSat: FfiConverterUInt64.read(from),
        maxSat: FfiConverterUInt64.read(from),
        maxZeroConfSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.minSat, into);
      FfiConverterUInt64.write(value.maxSat, into);
      FfiConverterUInt64.write(value.maxZeroConfSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.minSat) +
        FfiConverterUInt64.allocationSize(value.maxSat) +
        FfiConverterUInt64.allocationSize(value.maxZeroConfSat)
      );
    }
  }
  return new FFIConverter();
})();

export type LiquidAddressData = {
  address: string;
  network: Network;
  assetId: string | undefined;
  amount: /*f64*/ number | undefined;
  amountSat: /*u64*/ bigint | undefined;
  label: string | undefined;
  message: string | undefined;
};

/**
 * Generated factory for {@link LiquidAddressData} record objects.
 */
export const LiquidAddressData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LiquidAddressData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LiquidAddressData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LiquidAddressData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LiquidAddressData>,
  });
})();

const FfiConverterTypeLiquidAddressData = (() => {
  type TypeName = LiquidAddressData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        assetId: FfiConverterOptionalString.read(from),
        amount: FfiConverterOptionalFloat64.read(from),
        amountSat: FfiConverterOptionalUInt64.read(from),
        label: FfiConverterOptionalString.read(from),
        message: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterOptionalString.write(value.assetId, into);
      FfiConverterOptionalFloat64.write(value.amount, into);
      FfiConverterOptionalUInt64.write(value.amountSat, into);
      FfiConverterOptionalString.write(value.label, into);
      FfiConverterOptionalString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterOptionalString.allocationSize(value.assetId) +
        FfiConverterOptionalFloat64.allocationSize(value.amount) +
        FfiConverterOptionalUInt64.allocationSize(value.amountSat) +
        FfiConverterOptionalString.allocationSize(value.label) +
        FfiConverterOptionalString.allocationSize(value.message)
      );
    }
  }
  return new FFIConverter();
})();

export type ListPaymentsRequest = {
  filters: Array<PaymentType> | undefined;
  states: Array<PaymentState> | undefined;
  fromTimestamp: /*i64*/ bigint | undefined;
  toTimestamp: /*i64*/ bigint | undefined;
  offset: /*u32*/ number | undefined;
  limit: /*u32*/ number | undefined;
  details: ListPaymentDetails | undefined;
  sortAscending: boolean | undefined;
};

/**
 * Generated factory for {@link ListPaymentsRequest} record objects.
 */
export const ListPaymentsRequest = (() => {
  const defaults = () => ({
    filters: undefined,
    states: undefined,
    fromTimestamp: undefined,
    toTimestamp: undefined,
    offset: undefined,
    limit: undefined,
    details: undefined,
    sortAscending: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<ListPaymentsRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsRequest>,
  });
})();

const FfiConverterTypeListPaymentsRequest = (() => {
  type TypeName = ListPaymentsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filters: FfiConverterOptionalArrayTypePaymentType.read(from),
        states: FfiConverterOptionalArrayTypePaymentState.read(from),
        fromTimestamp: FfiConverterOptionalInt64.read(from),
        toTimestamp: FfiConverterOptionalInt64.read(from),
        offset: FfiConverterOptionalUInt32.read(from),
        limit: FfiConverterOptionalUInt32.read(from),
        details: FfiConverterOptionalTypeListPaymentDetails.read(from),
        sortAscending: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypePaymentType.write(value.filters, into);
      FfiConverterOptionalArrayTypePaymentState.write(value.states, into);
      FfiConverterOptionalInt64.write(value.fromTimestamp, into);
      FfiConverterOptionalInt64.write(value.toTimestamp, into);
      FfiConverterOptionalUInt32.write(value.offset, into);
      FfiConverterOptionalUInt32.write(value.limit, into);
      FfiConverterOptionalTypeListPaymentDetails.write(value.details, into);
      FfiConverterOptionalBool.write(value.sortAscending, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypePaymentType.allocationSize(value.filters) +
        FfiConverterOptionalArrayTypePaymentState.allocationSize(value.states) +
        FfiConverterOptionalInt64.allocationSize(value.fromTimestamp) +
        FfiConverterOptionalInt64.allocationSize(value.toTimestamp) +
        FfiConverterOptionalUInt32.allocationSize(value.offset) +
        FfiConverterOptionalUInt32.allocationSize(value.limit) +
        FfiConverterOptionalTypeListPaymentDetails.allocationSize(
          value.details
        ) +
        FfiConverterOptionalBool.allocationSize(value.sortAscending)
      );
    }
  }
  return new FFIConverter();
})();

export type LnOfferBlindedPath = {
  blindedHops: Array<string>;
};

/**
 * Generated factory for {@link LnOfferBlindedPath} record objects.
 */
export const LnOfferBlindedPath = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnOfferBlindedPath, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnOfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnOfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnOfferBlindedPath>,
  });
})();

const FfiConverterTypeLnOfferBlindedPath = (() => {
  type TypeName = LnOfferBlindedPath;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        blindedHops: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.blindedHops, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayString.allocationSize(value.blindedHops);
    }
  }
  return new FFIConverter();
})();

export type LnUrlAuthRequestData = {
  k1: string;
  domain: string;
  url: string;
  action: string | undefined;
};

/**
 * Generated factory for {@link LnUrlAuthRequestData} record objects.
 */
export const LnUrlAuthRequestData = (() => {
  const defaults = () => ({ action: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      LnUrlAuthRequestData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlAuthRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlAuthRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlAuthRequestData>,
  });
})();

const FfiConverterTypeLnUrlAuthRequestData = (() => {
  type TypeName = LnUrlAuthRequestData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        k1: FfiConverterString.read(from),
        domain: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
        action: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.k1, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalString.write(value.action, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.k1) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalString.allocationSize(value.action)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlErrorData = {
  reason: string;
};

/**
 * Generated factory for {@link LnUrlErrorData} record objects.
 */
export const LnUrlErrorData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlErrorData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlErrorData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlErrorData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlErrorData>,
  });
})();

const FfiConverterTypeLnUrlErrorData = (() => {
  type TypeName = LnUrlErrorData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.reason);
    }
  }
  return new FFIConverter();
})();

export type LnUrlInfo = {
  lnAddress: string | undefined;
  lnurlPayComment: string | undefined;
  lnurlPayDomain: string | undefined;
  lnurlPayMetadata: string | undefined;
  lnurlPaySuccessAction: SuccessActionProcessed | undefined;
  lnurlPayUnprocessedSuccessAction: SuccessAction | undefined;
  lnurlWithdrawEndpoint: string | undefined;
};

/**
 * Generated factory for {@link LnUrlInfo} record objects.
 */
export const LnUrlInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlInfo>,
  });
})();

const FfiConverterTypeLnUrlInfo = (() => {
  type TypeName = LnUrlInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnAddress: FfiConverterOptionalString.read(from),
        lnurlPayComment: FfiConverterOptionalString.read(from),
        lnurlPayDomain: FfiConverterOptionalString.read(from),
        lnurlPayMetadata: FfiConverterOptionalString.read(from),
        lnurlPaySuccessAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
        lnurlPayUnprocessedSuccessAction:
          FfiConverterOptionalTypeSuccessAction.read(from),
        lnurlWithdrawEndpoint: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.lnAddress, into);
      FfiConverterOptionalString.write(value.lnurlPayComment, into);
      FfiConverterOptionalString.write(value.lnurlPayDomain, into);
      FfiConverterOptionalString.write(value.lnurlPayMetadata, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.lnurlPaySuccessAction,
        into
      );
      FfiConverterOptionalTypeSuccessAction.write(
        value.lnurlPayUnprocessedSuccessAction,
        into
      );
      FfiConverterOptionalString.write(value.lnurlWithdrawEndpoint, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.lnAddress) +
        FfiConverterOptionalString.allocationSize(value.lnurlPayComment) +
        FfiConverterOptionalString.allocationSize(value.lnurlPayDomain) +
        FfiConverterOptionalString.allocationSize(value.lnurlPayMetadata) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.lnurlPaySuccessAction
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.lnurlPayUnprocessedSuccessAction
        ) +
        FfiConverterOptionalString.allocationSize(value.lnurlWithdrawEndpoint)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlPayErrorData = {
  paymentHash: string;
  reason: string;
};

/**
 * Generated factory for {@link LnUrlPayErrorData} record objects.
 */
export const LnUrlPayErrorData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlPayErrorData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlPayErrorData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlPayErrorData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlPayErrorData>,
  });
})();

const FfiConverterTypeLnUrlPayErrorData = (() => {
  type TypeName = LnUrlPayErrorData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentHash: FfiConverterString.read(from),
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentHash, into);
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentHash) +
        FfiConverterString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlPayRequest = {
  prepareResponse: PrepareLnUrlPayResponse;
};

/**
 * Generated factory for {@link LnUrlPayRequest} record objects.
 */
export const LnUrlPayRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlPayRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlPayRequest>,
  });
})();

const FfiConverterTypeLnUrlPayRequest = (() => {
  type TypeName = LnUrlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareLnUrlPayResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareLnUrlPayResponse.write(
        value.prepareResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePrepareLnUrlPayResponse.allocationSize(
        value.prepareResponse
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlPayRequestData = {
  callback: string;
  minSendable: /*u64*/ bigint;
  maxSendable: /*u64*/ bigint;
  metadataStr: string;
  commentAllowed: /*u16*/ number;
  domain: string;
  allowsNostr: boolean;
  nostrPubkey: string | undefined;
  lnAddress: string | undefined;
};

/**
 * Generated factory for {@link LnUrlPayRequestData} record objects.
 */
export const LnUrlPayRequestData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlPayRequestData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlPayRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlPayRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlPayRequestData>,
  });
})();

const FfiConverterTypeLnUrlPayRequestData = (() => {
  type TypeName = LnUrlPayRequestData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        callback: FfiConverterString.read(from),
        minSendable: FfiConverterUInt64.read(from),
        maxSendable: FfiConverterUInt64.read(from),
        metadataStr: FfiConverterString.read(from),
        commentAllowed: FfiConverterUInt16.read(from),
        domain: FfiConverterString.read(from),
        allowsNostr: FfiConverterBool.read(from),
        nostrPubkey: FfiConverterOptionalString.read(from),
        lnAddress: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.callback, into);
      FfiConverterUInt64.write(value.minSendable, into);
      FfiConverterUInt64.write(value.maxSendable, into);
      FfiConverterString.write(value.metadataStr, into);
      FfiConverterUInt16.write(value.commentAllowed, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterBool.write(value.allowsNostr, into);
      FfiConverterOptionalString.write(value.nostrPubkey, into);
      FfiConverterOptionalString.write(value.lnAddress, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.callback) +
        FfiConverterUInt64.allocationSize(value.minSendable) +
        FfiConverterUInt64.allocationSize(value.maxSendable) +
        FfiConverterString.allocationSize(value.metadataStr) +
        FfiConverterUInt16.allocationSize(value.commentAllowed) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterBool.allocationSize(value.allowsNostr) +
        FfiConverterOptionalString.allocationSize(value.nostrPubkey) +
        FfiConverterOptionalString.allocationSize(value.lnAddress)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlPaySuccessData = {
  successAction: SuccessActionProcessed | undefined;
  payment: Payment;
};

/**
 * Generated factory for {@link LnUrlPaySuccessData} record objects.
 */
export const LnUrlPaySuccessData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnUrlPaySuccessData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlPaySuccessData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlPaySuccessData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlPaySuccessData>,
  });
})();

const FfiConverterTypeLnUrlPaySuccessData = (() => {
  type TypeName = LnUrlPaySuccessData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        successAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.successAction,
        into
      );
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.successAction
        ) + FfiConverterTypePayment.allocationSize(value.payment)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlWithdrawRequest = {
  data: LnUrlWithdrawRequestData;
  amountMsat: /*u64*/ bigint;
  description: string | undefined;
};

/**
 * Generated factory for {@link LnUrlWithdrawRequest} record objects.
 */
export const LnUrlWithdrawRequest = (() => {
  const defaults = () => ({ description: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      LnUrlWithdrawRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnUrlWithdrawRequest>,
  });
})();

const FfiConverterTypeLnUrlWithdrawRequest = (() => {
  type TypeName = LnUrlWithdrawRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        data: FfiConverterTypeLnUrlWithdrawRequestData.read(from),
        amountMsat: FfiConverterUInt64.read(from),
        description: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLnUrlWithdrawRequestData.write(value.data, into);
      FfiConverterUInt64.write(value.amountMsat, into);
      FfiConverterOptionalString.write(value.description, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLnUrlWithdrawRequestData.allocationSize(value.data) +
        FfiConverterUInt64.allocationSize(value.amountMsat) +
        FfiConverterOptionalString.allocationSize(value.description)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlWithdrawRequestData = {
  callback: string;
  k1: string;
  defaultDescription: string;
  minWithdrawable: /*u64*/ bigint;
  maxWithdrawable: /*u64*/ bigint;
};

/**
 * Generated factory for {@link LnUrlWithdrawRequestData} record objects.
 */
export const LnUrlWithdrawRequestData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnUrlWithdrawRequestData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlWithdrawRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlWithdrawRequestData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LnUrlWithdrawRequestData>,
  });
})();

const FfiConverterTypeLnUrlWithdrawRequestData = (() => {
  type TypeName = LnUrlWithdrawRequestData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        callback: FfiConverterString.read(from),
        k1: FfiConverterString.read(from),
        defaultDescription: FfiConverterString.read(from),
        minWithdrawable: FfiConverterUInt64.read(from),
        maxWithdrawable: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.callback, into);
      FfiConverterString.write(value.k1, into);
      FfiConverterString.write(value.defaultDescription, into);
      FfiConverterUInt64.write(value.minWithdrawable, into);
      FfiConverterUInt64.write(value.maxWithdrawable, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.callback) +
        FfiConverterString.allocationSize(value.k1) +
        FfiConverterString.allocationSize(value.defaultDescription) +
        FfiConverterUInt64.allocationSize(value.minWithdrawable) +
        FfiConverterUInt64.allocationSize(value.maxWithdrawable)
      );
    }
  }
  return new FFIConverter();
})();

export type LnUrlWithdrawSuccessData = {
  invoice: LnInvoice;
};

/**
 * Generated factory for {@link LnUrlWithdrawSuccessData} record objects.
 */
export const LnUrlWithdrawSuccessData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnUrlWithdrawSuccessData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnUrlWithdrawSuccessData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnUrlWithdrawSuccessData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LnUrlWithdrawSuccessData>,
  });
})();

const FfiConverterTypeLnUrlWithdrawSuccessData = (() => {
  type TypeName = LnUrlWithdrawSuccessData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoice: FfiConverterTypeLNInvoice.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLNInvoice.write(value.invoice, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeLNInvoice.allocationSize(value.invoice);
    }
  }
  return new FFIConverter();
})();

export type LocaleOverrides = {
  locale: string;
  spacing: /*u32*/ number | undefined;
  symbol: Symbol;
};

/**
 * Generated factory for {@link LocaleOverrides} record objects.
 */
export const LocaleOverrides = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocaleOverrides, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocaleOverrides>,
  });
})();

const FfiConverterTypeLocaleOverrides = (() => {
  type TypeName = LocaleOverrides;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        locale: FfiConverterString.read(from),
        spacing: FfiConverterOptionalUInt32.read(from),
        symbol: FfiConverterTypeSymbol.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.locale, into);
      FfiConverterOptionalUInt32.write(value.spacing, into);
      FfiConverterTypeSymbol.write(value.symbol, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.locale) +
        FfiConverterOptionalUInt32.allocationSize(value.spacing) +
        FfiConverterTypeSymbol.allocationSize(value.symbol)
      );
    }
  }
  return new FFIConverter();
})();

export type LocalizedName = {
  locale: string;
  name: string;
};

/**
 * Generated factory for {@link LocalizedName} record objects.
 */
export const LocalizedName = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocalizedName, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocalizedName>,
  });
})();

const FfiConverterTypeLocalizedName = (() => {
  type TypeName = LocalizedName;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        locale: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.locale, into);
      FfiConverterString.write(value.name, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.locale) +
        FfiConverterString.allocationSize(value.name)
      );
    }
  }
  return new FFIConverter();
})();

export type LogEntry = {
  line: string;
  level: string;
};

/**
 * Generated factory for {@link LogEntry} record objects.
 */
export const LogEntry = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LogEntry, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LogEntry>,
  });
})();

const FfiConverterTypeLogEntry = (() => {
  type TypeName = LogEntry;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        line: FfiConverterString.read(from),
        level: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.line, into);
      FfiConverterString.write(value.level, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.line) +
        FfiConverterString.allocationSize(value.level)
      );
    }
  }
  return new FFIConverter();
})();

export type MessageSuccessActionData = {
  message: string;
};

/**
 * Generated factory for {@link MessageSuccessActionData} record objects.
 */
export const MessageSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      MessageSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<MessageSuccessActionData>,
  });
})();

const FfiConverterTypeMessageSuccessActionData = (() => {
  type TypeName = MessageSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.message);
    }
  }
  return new FFIConverter();
})();

export type OnchainPaymentLimitsResponse = {
  send: Limits;
  receive: Limits;
};

/**
 * Generated factory for {@link OnchainPaymentLimitsResponse} record objects.
 */
export const OnchainPaymentLimitsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      OnchainPaymentLimitsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OnchainPaymentLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OnchainPaymentLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<OnchainPaymentLimitsResponse>,
  });
})();

const FfiConverterTypeOnchainPaymentLimitsResponse = (() => {
  type TypeName = OnchainPaymentLimitsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        send: FfiConverterTypeLimits.read(from),
        receive: FfiConverterTypeLimits.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLimits.write(value.send, into);
      FfiConverterTypeLimits.write(value.receive, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLimits.allocationSize(value.send) +
        FfiConverterTypeLimits.allocationSize(value.receive)
      );
    }
  }
  return new FFIConverter();
})();

export type PayOnchainRequest = {
  address: string;
  prepareResponse: PreparePayOnchainResponse;
};

/**
 * Generated factory for {@link PayOnchainRequest} record objects.
 */
export const PayOnchainRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PayOnchainRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PayOnchainRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PayOnchainRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PayOnchainRequest>,
  });
})();

const FfiConverterTypePayOnchainRequest = (() => {
  type TypeName = PayOnchainRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        prepareResponse: FfiConverterTypePreparePayOnchainResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypePreparePayOnchainResponse.write(
        value.prepareResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypePreparePayOnchainResponse.allocationSize(
          value.prepareResponse
        )
      );
    }
  }
  return new FFIConverter();
})();

export type Payment = {
  timestamp: /*u32*/ number;
  amountSat: /*u64*/ bigint;
  feesSat: /*u64*/ bigint;
  paymentType: PaymentType;
  status: PaymentState;
  details: PaymentDetails;
  swapperFeesSat: /*u64*/ bigint | undefined;
  destination: string | undefined;
  txId: string | undefined;
  unblindingData: string | undefined;
};

/**
 * Generated factory for {@link Payment} record objects.
 */
export const Payment = (() => {
  const defaults = () => ({
    swapperFeesSat: undefined,
    destination: undefined,
    txId: undefined,
    unblindingData: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<Payment, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Payment>,
  });
})();

const FfiConverterTypePayment = (() => {
  type TypeName = Payment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        timestamp: FfiConverterUInt32.read(from),
        amountSat: FfiConverterUInt64.read(from),
        feesSat: FfiConverterUInt64.read(from),
        paymentType: FfiConverterTypePaymentType.read(from),
        status: FfiConverterTypePaymentState.read(from),
        details: FfiConverterTypePaymentDetails.read(from),
        swapperFeesSat: FfiConverterOptionalUInt64.read(from),
        destination: FfiConverterOptionalString.read(from),
        txId: FfiConverterOptionalString.read(from),
        unblindingData: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.timestamp, into);
      FfiConverterUInt64.write(value.amountSat, into);
      FfiConverterUInt64.write(value.feesSat, into);
      FfiConverterTypePaymentType.write(value.paymentType, into);
      FfiConverterTypePaymentState.write(value.status, into);
      FfiConverterTypePaymentDetails.write(value.details, into);
      FfiConverterOptionalUInt64.write(value.swapperFeesSat, into);
      FfiConverterOptionalString.write(value.destination, into);
      FfiConverterOptionalString.write(value.txId, into);
      FfiConverterOptionalString.write(value.unblindingData, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.timestamp) +
        FfiConverterUInt64.allocationSize(value.amountSat) +
        FfiConverterUInt64.allocationSize(value.feesSat) +
        FfiConverterTypePaymentType.allocationSize(value.paymentType) +
        FfiConverterTypePaymentState.allocationSize(value.status) +
        FfiConverterTypePaymentDetails.allocationSize(value.details) +
        FfiConverterOptionalUInt64.allocationSize(value.swapperFeesSat) +
        FfiConverterOptionalString.allocationSize(value.destination) +
        FfiConverterOptionalString.allocationSize(value.txId) +
        FfiConverterOptionalString.allocationSize(value.unblindingData)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareBuyBitcoinRequest = {
  provider: BuyBitcoinProvider;
  amountSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link PrepareBuyBitcoinRequest} record objects.
 */
export const PrepareBuyBitcoinRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareBuyBitcoinRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareBuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareBuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareBuyBitcoinRequest>,
  });
})();

const FfiConverterTypePrepareBuyBitcoinRequest = (() => {
  type TypeName = PrepareBuyBitcoinRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        provider: FfiConverterTypeBuyBitcoinProvider.read(from),
        amountSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeBuyBitcoinProvider.write(value.provider, into);
      FfiConverterUInt64.write(value.amountSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeBuyBitcoinProvider.allocationSize(value.provider) +
        FfiConverterUInt64.allocationSize(value.amountSat)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareBuyBitcoinResponse = {
  provider: BuyBitcoinProvider;
  amountSat: /*u64*/ bigint;
  feesSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link PrepareBuyBitcoinResponse} record objects.
 */
export const PrepareBuyBitcoinResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareBuyBitcoinResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareBuyBitcoinResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareBuyBitcoinResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareBuyBitcoinResponse>,
  });
})();

const FfiConverterTypePrepareBuyBitcoinResponse = (() => {
  type TypeName = PrepareBuyBitcoinResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        provider: FfiConverterTypeBuyBitcoinProvider.read(from),
        amountSat: FfiConverterUInt64.read(from),
        feesSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeBuyBitcoinProvider.write(value.provider, into);
      FfiConverterUInt64.write(value.amountSat, into);
      FfiConverterUInt64.write(value.feesSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeBuyBitcoinProvider.allocationSize(value.provider) +
        FfiConverterUInt64.allocationSize(value.amountSat) +
        FfiConverterUInt64.allocationSize(value.feesSat)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnUrlPayRequest = {
  data: LnUrlPayRequestData;
  amount: PayAmount;
  bip353Address: string | undefined;
  comment: string | undefined;
  validateSuccessActionUrl: boolean | undefined;
};

/**
 * Generated factory for {@link PrepareLnUrlPayRequest} record objects.
 */
export const PrepareLnUrlPayRequest = (() => {
  const defaults = () => ({
    bip353Address: undefined,
    comment: undefined,
    validateSuccessActionUrl: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnUrlPayRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnUrlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnUrlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnUrlPayRequest>,
  });
})();

const FfiConverterTypePrepareLnUrlPayRequest = (() => {
  type TypeName = PrepareLnUrlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        data: FfiConverterTypeLnUrlPayRequestData.read(from),
        amount: FfiConverterTypePayAmount.read(from),
        bip353Address: FfiConverterOptionalString.read(from),
        comment: FfiConverterOptionalString.read(from),
        validateSuccessActionUrl: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLnUrlPayRequestData.write(value.data, into);
      FfiConverterTypePayAmount.write(value.amount, into);
      FfiConverterOptionalString.write(value.bip353Address, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalBool.write(value.validateSuccessActionUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLnUrlPayRequestData.allocationSize(value.data) +
        FfiConverterTypePayAmount.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.bip353Address) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalBool.allocationSize(value.validateSuccessActionUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnUrlPayResponse = {
  destination: SendDestination;
  feesSat: /*u64*/ bigint;
  data: LnUrlPayRequestData;
  amount: PayAmount;
  comment: string | undefined;
  successAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link PrepareLnUrlPayResponse} record objects.
 */
export const PrepareLnUrlPayResponse = (() => {
  const defaults = () => ({ comment: undefined, successAction: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnUrlPayResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnUrlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnUrlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnUrlPayResponse>,
  });
})();

const FfiConverterTypePrepareLnUrlPayResponse = (() => {
  type TypeName = PrepareLnUrlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        destination: FfiConverterTypeSendDestination.read(from),
        feesSat: FfiConverterUInt64.read(from),
        data: FfiConverterTypeLnUrlPayRequestData.read(from),
        amount: FfiConverterTypePayAmount.read(from),
        comment: FfiConverterOptionalString.read(from),
        successAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSendDestination.write(value.destination, into);
      FfiConverterUInt64.write(value.feesSat, into);
      FfiConverterTypeLnUrlPayRequestData.write(value.data, into);
      FfiConverterTypePayAmount.write(value.amount, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalTypeSuccessAction.write(value.successAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSendDestination.allocationSize(value.destination) +
        FfiConverterUInt64.allocationSize(value.feesSat) +
        FfiConverterTypeLnUrlPayRequestData.allocationSize(value.data) +
        FfiConverterTypePayAmount.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type PreparePayOnchainRequest = {
  amount: PayAmount;
  feeRateSatPerVbyte: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link PreparePayOnchainRequest} record objects.
 */
export const PreparePayOnchainRequest = (() => {
  const defaults = () => ({ feeRateSatPerVbyte: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PreparePayOnchainRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PreparePayOnchainRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PreparePayOnchainRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PreparePayOnchainRequest>,
  });
})();

const FfiConverterTypePreparePayOnchainRequest = (() => {
  type TypeName = PreparePayOnchainRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amount: FfiConverterTypePayAmount.read(from),
        feeRateSatPerVbyte: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayAmount.write(value.amount, into);
      FfiConverterOptionalUInt32.write(value.feeRateSatPerVbyte, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePayAmount.allocationSize(value.amount) +
        FfiConverterOptionalUInt32.allocationSize(value.feeRateSatPerVbyte)
      );
    }
  }
  return new FFIConverter();
})();

export type PreparePayOnchainResponse = {
  receiverAmountSat: /*u64*/ bigint;
  claimFeesSat: /*u64*/ bigint;
  totalFeesSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link PreparePayOnchainResponse} record objects.
 */
export const PreparePayOnchainResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PreparePayOnchainResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PreparePayOnchainResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PreparePayOnchainResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PreparePayOnchainResponse>,
  });
})();

const FfiConverterTypePreparePayOnchainResponse = (() => {
  type TypeName = PreparePayOnchainResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        receiverAmountSat: FfiConverterUInt64.read(from),
        claimFeesSat: FfiConverterUInt64.read(from),
        totalFeesSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.receiverAmountSat, into);
      FfiConverterUInt64.write(value.claimFeesSat, into);
      FfiConverterUInt64.write(value.totalFeesSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.receiverAmountSat) +
        FfiConverterUInt64.allocationSize(value.claimFeesSat) +
        FfiConverterUInt64.allocationSize(value.totalFeesSat)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareReceiveRequest = {
  paymentMethod: PaymentMethod;
  amount: ReceiveAmount | undefined;
};

/**
 * Generated factory for {@link PrepareReceiveRequest} record objects.
 */
export const PrepareReceiveRequest = (() => {
  const defaults = () => ({ amount: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareReceiveRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareReceiveRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareReceiveRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PrepareReceiveRequest>,
  });
})();

const FfiConverterTypePrepareReceiveRequest = (() => {
  type TypeName = PrepareReceiveRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypePaymentMethod.read(from),
        amount: FfiConverterOptionalTypeReceiveAmount.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePaymentMethod.write(value.paymentMethod, into);
      FfiConverterOptionalTypeReceiveAmount.write(value.amount, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePaymentMethod.allocationSize(value.paymentMethod) +
        FfiConverterOptionalTypeReceiveAmount.allocationSize(value.amount)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareReceiveResponse = {
  paymentMethod: PaymentMethod;
  feesSat: /*u64*/ bigint;
  amount: ReceiveAmount | undefined;
  minPayerAmountSat: /*u64*/ bigint | undefined;
  maxPayerAmountSat: /*u64*/ bigint | undefined;
  swapperFeerate: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link PrepareReceiveResponse} record objects.
 */
export const PrepareReceiveResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareReceiveResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareReceiveResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareReceiveResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareReceiveResponse>,
  });
})();

const FfiConverterTypePrepareReceiveResponse = (() => {
  type TypeName = PrepareReceiveResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypePaymentMethod.read(from),
        feesSat: FfiConverterUInt64.read(from),
        amount: FfiConverterOptionalTypeReceiveAmount.read(from),
        minPayerAmountSat: FfiConverterOptionalUInt64.read(from),
        maxPayerAmountSat: FfiConverterOptionalUInt64.read(from),
        swapperFeerate: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePaymentMethod.write(value.paymentMethod, into);
      FfiConverterUInt64.write(value.feesSat, into);
      FfiConverterOptionalTypeReceiveAmount.write(value.amount, into);
      FfiConverterOptionalUInt64.write(value.minPayerAmountSat, into);
      FfiConverterOptionalUInt64.write(value.maxPayerAmountSat, into);
      FfiConverterOptionalFloat64.write(value.swapperFeerate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePaymentMethod.allocationSize(value.paymentMethod) +
        FfiConverterUInt64.allocationSize(value.feesSat) +
        FfiConverterOptionalTypeReceiveAmount.allocationSize(value.amount) +
        FfiConverterOptionalUInt64.allocationSize(value.minPayerAmountSat) +
        FfiConverterOptionalUInt64.allocationSize(value.maxPayerAmountSat) +
        FfiConverterOptionalFloat64.allocationSize(value.swapperFeerate)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareRefundRequest = {
  swapAddress: string;
  refundAddress: string;
  feeRateSatPerVbyte: /*u32*/ number;
};

/**
 * Generated factory for {@link PrepareRefundRequest} record objects.
 */
export const PrepareRefundRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareRefundRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareRefundRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareRefundRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PrepareRefundRequest>,
  });
})();

const FfiConverterTypePrepareRefundRequest = (() => {
  type TypeName = PrepareRefundRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        swapAddress: FfiConverterString.read(from),
        refundAddress: FfiConverterString.read(from),
        feeRateSatPerVbyte: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.swapAddress, into);
      FfiConverterString.write(value.refundAddress, into);
      FfiConverterUInt32.write(value.feeRateSatPerVbyte, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.swapAddress) +
        FfiConverterString.allocationSize(value.refundAddress) +
        FfiConverterUInt32.allocationSize(value.feeRateSatPerVbyte)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareRefundResponse = {
  txVsize: /*u32*/ number;
  txFeeSat: /*u64*/ bigint;
  lastRefundTxId: string | undefined;
};

/**
 * Generated factory for {@link PrepareRefundResponse} record objects.
 */
export const PrepareRefundResponse = (() => {
  const defaults = () => ({ lastRefundTxId: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareRefundResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareRefundResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareRefundResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PrepareRefundResponse>,
  });
})();

const FfiConverterTypePrepareRefundResponse = (() => {
  type TypeName = PrepareRefundResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txVsize: FfiConverterUInt32.read(from),
        txFeeSat: FfiConverterUInt64.read(from),
        lastRefundTxId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.txVsize, into);
      FfiConverterUInt64.write(value.txFeeSat, into);
      FfiConverterOptionalString.write(value.lastRefundTxId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.txVsize) +
        FfiConverterUInt64.allocationSize(value.txFeeSat) +
        FfiConverterOptionalString.allocationSize(value.lastRefundTxId)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendRequest = {
  destination: string;
  amount: PayAmount | undefined;
};

/**
 * Generated factory for {@link PrepareSendRequest} record objects.
 */
export const PrepareSendRequest = (() => {
  const defaults = () => ({ amount: undefined });
  const create = (() => {
    return uniffiCreateRecord<PrepareSendRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PrepareSendRequest>,
  });
})();

const FfiConverterTypePrepareSendRequest = (() => {
  type TypeName = PrepareSendRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        destination: FfiConverterString.read(from),
        amount: FfiConverterOptionalTypePayAmount.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.destination, into);
      FfiConverterOptionalTypePayAmount.write(value.amount, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.destination) +
        FfiConverterOptionalTypePayAmount.allocationSize(value.amount)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendResponse = {
  destination: SendDestination;
  amount: PayAmount | undefined;
  feesSat: /*u64*/ bigint | undefined;
  estimatedAssetFees: /*f64*/ number | undefined;
  exchangeAmountSat: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link PrepareSendResponse} record objects.
 */
export const PrepareSendResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PrepareSendResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PrepareSendResponse>,
  });
})();

const FfiConverterTypePrepareSendResponse = (() => {
  type TypeName = PrepareSendResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        destination: FfiConverterTypeSendDestination.read(from),
        amount: FfiConverterOptionalTypePayAmount.read(from),
        feesSat: FfiConverterOptionalUInt64.read(from),
        estimatedAssetFees: FfiConverterOptionalFloat64.read(from),
        exchangeAmountSat: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSendDestination.write(value.destination, into);
      FfiConverterOptionalTypePayAmount.write(value.amount, into);
      FfiConverterOptionalUInt64.write(value.feesSat, into);
      FfiConverterOptionalFloat64.write(value.estimatedAssetFees, into);
      FfiConverterOptionalUInt64.write(value.exchangeAmountSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSendDestination.allocationSize(value.destination) +
        FfiConverterOptionalTypePayAmount.allocationSize(value.amount) +
        FfiConverterOptionalUInt64.allocationSize(value.feesSat) +
        FfiConverterOptionalFloat64.allocationSize(value.estimatedAssetFees) +
        FfiConverterOptionalUInt64.allocationSize(value.exchangeAmountSat)
      );
    }
  }
  return new FFIConverter();
})();

export type Rate = {
  coin: string;
  value: /*f64*/ number;
};

/**
 * Generated factory for {@link Rate} record objects.
 */
export const Rate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Rate, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Rate>,
  });
})();

const FfiConverterTypeRate = (() => {
  type TypeName = Rate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coin: FfiConverterString.read(from),
        value: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.coin, into);
      FfiConverterFloat64.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.coin) +
        FfiConverterFloat64.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentRequest = {
  prepareResponse: PrepareReceiveResponse;
  description: string | undefined;
  useDescriptionHash: boolean | undefined;
  payerNote: string | undefined;
};

/**
 * Generated factory for {@link ReceivePaymentRequest} record objects.
 */
export const ReceivePaymentRequest = (() => {
  const defaults = () => ({
    description: undefined,
    useDescriptionHash: undefined,
    payerNote: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReceivePaymentRequest>,
  });
})();

const FfiConverterTypeReceivePaymentRequest = (() => {
  type TypeName = ReceivePaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareReceiveResponse.read(from),
        description: FfiConverterOptionalString.read(from),
        useDescriptionHash: FfiConverterOptionalBool.read(from),
        payerNote: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareReceiveResponse.write(value.prepareResponse, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalBool.write(value.useDescriptionHash, into);
      FfiConverterOptionalString.write(value.payerNote, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareReceiveResponse.allocationSize(
          value.prepareResponse
        ) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalBool.allocationSize(value.useDescriptionHash) +
        FfiConverterOptionalString.allocationSize(value.payerNote)
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentResponse = {
  destination: string;
};

/**
 * Generated factory for {@link ReceivePaymentResponse} record objects.
 */
export const ReceivePaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ReceivePaymentResponse>,
  });
})();

const FfiConverterTypeReceivePaymentResponse = (() => {
  type TypeName = ReceivePaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        destination: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.destination, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.destination);
    }
  }
  return new FFIConverter();
})();

export type RecommendedFees = {
  fastestFee: /*u64*/ bigint;
  halfHourFee: /*u64*/ bigint;
  hourFee: /*u64*/ bigint;
  economyFee: /*u64*/ bigint;
  minimumFee: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RecommendedFees} record objects.
 */
export const RecommendedFees = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RecommendedFees, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RecommendedFees}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RecommendedFees}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RecommendedFees>,
  });
})();

const FfiConverterTypeRecommendedFees = (() => {
  type TypeName = RecommendedFees;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        fastestFee: FfiConverterUInt64.read(from),
        halfHourFee: FfiConverterUInt64.read(from),
        hourFee: FfiConverterUInt64.read(from),
        economyFee: FfiConverterUInt64.read(from),
        minimumFee: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.fastestFee, into);
      FfiConverterUInt64.write(value.halfHourFee, into);
      FfiConverterUInt64.write(value.hourFee, into);
      FfiConverterUInt64.write(value.economyFee, into);
      FfiConverterUInt64.write(value.minimumFee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.fastestFee) +
        FfiConverterUInt64.allocationSize(value.halfHourFee) +
        FfiConverterUInt64.allocationSize(value.hourFee) +
        FfiConverterUInt64.allocationSize(value.economyFee) +
        FfiConverterUInt64.allocationSize(value.minimumFee)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundRequest = {
  swapAddress: string;
  refundAddress: string;
  feeRateSatPerVbyte: /*u32*/ number;
};

/**
 * Generated factory for {@link RefundRequest} record objects.
 */
export const RefundRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RefundRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundRequest>,
  });
})();

const FfiConverterTypeRefundRequest = (() => {
  type TypeName = RefundRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        swapAddress: FfiConverterString.read(from),
        refundAddress: FfiConverterString.read(from),
        feeRateSatPerVbyte: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.swapAddress, into);
      FfiConverterString.write(value.refundAddress, into);
      FfiConverterUInt32.write(value.feeRateSatPerVbyte, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.swapAddress) +
        FfiConverterString.allocationSize(value.refundAddress) +
        FfiConverterUInt32.allocationSize(value.feeRateSatPerVbyte)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundResponse = {
  refundTxId: string;
};

/**
 * Generated factory for {@link RefundResponse} record objects.
 */
export const RefundResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RefundResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundResponse>,
  });
})();

const FfiConverterTypeRefundResponse = (() => {
  type TypeName = RefundResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        refundTxId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.refundTxId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.refundTxId);
    }
  }
  return new FFIConverter();
})();

export type RefundableSwap = {
  swapAddress: string;
  timestamp: /*u32*/ number;
  amountSat: /*u64*/ bigint;
  lastRefundTxId: string | undefined;
};

/**
 * Generated factory for {@link RefundableSwap} record objects.
 */
export const RefundableSwap = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RefundableSwap, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundableSwap}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundableSwap}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundableSwap>,
  });
})();

const FfiConverterTypeRefundableSwap = (() => {
  type TypeName = RefundableSwap;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        swapAddress: FfiConverterString.read(from),
        timestamp: FfiConverterUInt32.read(from),
        amountSat: FfiConverterUInt64.read(from),
        lastRefundTxId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.swapAddress, into);
      FfiConverterUInt32.write(value.timestamp, into);
      FfiConverterUInt64.write(value.amountSat, into);
      FfiConverterOptionalString.write(value.lastRefundTxId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.swapAddress) +
        FfiConverterUInt32.allocationSize(value.timestamp) +
        FfiConverterUInt64.allocationSize(value.amountSat) +
        FfiConverterOptionalString.allocationSize(value.lastRefundTxId)
      );
    }
  }
  return new FFIConverter();
})();

export type RestoreRequest = {
  backupPath: string | undefined;
};

/**
 * Generated factory for {@link RestoreRequest} record objects.
 */
export const RestoreRequest = (() => {
  const defaults = () => ({ backupPath: undefined });
  const create = (() => {
    return uniffiCreateRecord<RestoreRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RestoreRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RestoreRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RestoreRequest>,
  });
})();

const FfiConverterTypeRestoreRequest = (() => {
  type TypeName = RestoreRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        backupPath: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.backupPath, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalString.allocationSize(value.backupPath);
    }
  }
  return new FFIConverter();
})();

export type RouteHint = {
  hops: Array<RouteHintHop>;
};

/**
 * Generated factory for {@link RouteHint} record objects.
 */
export const RouteHint = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteHint, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteHint>,
  });
})();

const FfiConverterTypeRouteHint = (() => {
  type TypeName = RouteHint;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        hops: FfiConverterArrayTypeRouteHintHop.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeRouteHintHop.write(value.hops, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeRouteHintHop.allocationSize(value.hops);
    }
  }
  return new FFIConverter();
})();

export type RouteHintHop = {
  srcNodeId: string;
  shortChannelId: string;
  feesBaseMsat: /*u32*/ number;
  feesProportionalMillionths: /*u32*/ number;
  cltvExpiryDelta: /*u64*/ bigint;
  htlcMinimumMsat: /*u64*/ bigint | undefined;
  htlcMaximumMsat: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RouteHintHop} record objects.
 */
export const RouteHintHop = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteHintHop, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteHintHop>,
  });
})();

const FfiConverterTypeRouteHintHop = (() => {
  type TypeName = RouteHintHop;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        srcNodeId: FfiConverterString.read(from),
        shortChannelId: FfiConverterString.read(from),
        feesBaseMsat: FfiConverterUInt32.read(from),
        feesProportionalMillionths: FfiConverterUInt32.read(from),
        cltvExpiryDelta: FfiConverterUInt64.read(from),
        htlcMinimumMsat: FfiConverterOptionalUInt64.read(from),
        htlcMaximumMsat: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.srcNodeId, into);
      FfiConverterString.write(value.shortChannelId, into);
      FfiConverterUInt32.write(value.feesBaseMsat, into);
      FfiConverterUInt32.write(value.feesProportionalMillionths, into);
      FfiConverterUInt64.write(value.cltvExpiryDelta, into);
      FfiConverterOptionalUInt64.write(value.htlcMinimumMsat, into);
      FfiConverterOptionalUInt64.write(value.htlcMaximumMsat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.srcNodeId) +
        FfiConverterString.allocationSize(value.shortChannelId) +
        FfiConverterUInt32.allocationSize(value.feesBaseMsat) +
        FfiConverterUInt32.allocationSize(value.feesProportionalMillionths) +
        FfiConverterUInt64.allocationSize(value.cltvExpiryDelta) +
        FfiConverterOptionalUInt64.allocationSize(value.htlcMinimumMsat) +
        FfiConverterOptionalUInt64.allocationSize(value.htlcMaximumMsat)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentRequest = {
  prepareResponse: PrepareSendResponse;
  useAssetFees: boolean | undefined;
  payerNote: string | undefined;
};

/**
 * Generated factory for {@link SendPaymentRequest} record objects.
 */
export const SendPaymentRequest = (() => {
  const defaults = () => ({ useAssetFees: undefined, payerNote: undefined });
  const create = (() => {
    return uniffiCreateRecord<SendPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentRequest>,
  });
})();

const FfiConverterTypeSendPaymentRequest = (() => {
  type TypeName = SendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareSendResponse.read(from),
        useAssetFees: FfiConverterOptionalBool.read(from),
        payerNote: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareSendResponse.write(value.prepareResponse, into);
      FfiConverterOptionalBool.write(value.useAssetFees, into);
      FfiConverterOptionalString.write(value.payerNote, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareSendResponse.allocationSize(
          value.prepareResponse
        ) +
        FfiConverterOptionalBool.allocationSize(value.useAssetFees) +
        FfiConverterOptionalString.allocationSize(value.payerNote)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link SendPaymentResponse} record objects.
 */
export const SendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentResponse>,
  });
})();

const FfiConverterTypeSendPaymentResponse = (() => {
  type TypeName = SendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type SignMessageRequest = {
  message: string;
};

/**
 * Generated factory for {@link SignMessageRequest} record objects.
 */
export const SignMessageRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SignMessageRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SignMessageRequest>,
  });
})();

const FfiConverterTypeSignMessageRequest = (() => {
  type TypeName = SignMessageRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.message);
    }
  }
  return new FFIConverter();
})();

export type SignMessageResponse = {
  signature: string;
};

/**
 * Generated factory for {@link SignMessageResponse} record objects.
 */
export const SignMessageResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SignMessageResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SignMessageResponse>,
  });
})();

const FfiConverterTypeSignMessageResponse = (() => {
  type TypeName = SignMessageResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        signature: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.signature, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.signature);
    }
  }
  return new FFIConverter();
})();

export type Symbol = {
  grapheme: string | undefined;
  template: string | undefined;
  rtl: boolean | undefined;
  position: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link Symbol} record objects.
 */
export const Symbol = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Symbol, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Symbol>,
  });
})();

const FfiConverterTypeSymbol = (() => {
  type TypeName = Symbol;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        grapheme: FfiConverterOptionalString.read(from),
        template: FfiConverterOptionalString.read(from),
        rtl: FfiConverterOptionalBool.read(from),
        position: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.grapheme, into);
      FfiConverterOptionalString.write(value.template, into);
      FfiConverterOptionalBool.write(value.rtl, into);
      FfiConverterOptionalUInt32.write(value.position, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.grapheme) +
        FfiConverterOptionalString.allocationSize(value.template) +
        FfiConverterOptionalBool.allocationSize(value.rtl) +
        FfiConverterOptionalUInt32.allocationSize(value.position)
      );
    }
  }
  return new FFIConverter();
})();

export type UrlSuccessActionData = {
  description: string;
  url: string;
  matchesCallbackDomain: boolean;
};

/**
 * Generated factory for {@link UrlSuccessActionData} record objects.
 */
export const UrlSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UrlSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UrlSuccessActionData>,
  });
})();

const FfiConverterTypeUrlSuccessActionData = (() => {
  type TypeName = UrlSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
        matchesCallbackDomain: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.url, into);
      FfiConverterBool.write(value.matchesCallbackDomain, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.url) +
        FfiConverterBool.allocationSize(value.matchesCallbackDomain)
      );
    }
  }
  return new FFIConverter();
})();

export type WalletInfo = {
  balanceSat: /*u64*/ bigint;
  pendingSendSat: /*u64*/ bigint;
  pendingReceiveSat: /*u64*/ bigint;
  fingerprint: string;
  pubkey: string;
  assetBalances: Array<AssetBalance>;
};

/**
 * Generated factory for {@link WalletInfo} record objects.
 */
export const WalletInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WalletInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WalletInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WalletInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_liquid} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_liquid} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WalletInfo>,
  });
})();

const FfiConverterTypeWalletInfo = (() => {
  type TypeName = WalletInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balanceSat: FfiConverterUInt64.read(from),
        pendingSendSat: FfiConverterUInt64.read(from),
        pendingReceiveSat: FfiConverterUInt64.read(from),
        fingerprint: FfiConverterString.read(from),
        pubkey: FfiConverterString.read(from),
        assetBalances: FfiConverterArrayTypeAssetBalance.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.balanceSat, into);
      FfiConverterUInt64.write(value.pendingSendSat, into);
      FfiConverterUInt64.write(value.pendingReceiveSat, into);
      FfiConverterString.write(value.fingerprint, into);
      FfiConverterString.write(value.pubkey, into);
      FfiConverterArrayTypeAssetBalance.write(value.assetBalances, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.balanceSat) +
        FfiConverterUInt64.allocationSize(value.pendingSendSat) +
        FfiConverterUInt64.allocationSize(value.pendingReceiveSat) +
        FfiConverterString.allocationSize(value.fingerprint) +
        FfiConverterString.allocationSize(value.pubkey) +
        FfiConverterArrayTypeAssetBalance.allocationSize(value.assetBalances)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: AesSuccessActionDataResult
export enum AesSuccessActionDataResult_Tags {
  Decrypted = 'Decrypted',
  ErrorStatus = 'ErrorStatus',
}
export const AesSuccessActionDataResult = (() => {
  type Decrypted__interface = {
    tag: AesSuccessActionDataResult_Tags.Decrypted;
    inner: Readonly<{ data: AesSuccessActionDataDecrypted }>;
  };

  class Decrypted_ extends UniffiEnum implements Decrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AesSuccessActionDataResult';
    readonly tag = AesSuccessActionDataResult_Tags.Decrypted;
    readonly inner: Readonly<{ data: AesSuccessActionDataDecrypted }>;
    constructor(inner: { data: AesSuccessActionDataDecrypted }) {
      super('AesSuccessActionDataResult', 'Decrypted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: AesSuccessActionDataDecrypted }): Decrypted_ {
      return new Decrypted_(inner);
    }

    static instanceOf(obj: any): obj is Decrypted_ {
      return obj.tag === AesSuccessActionDataResult_Tags.Decrypted;
    }
  }

  type ErrorStatus__interface = {
    tag: AesSuccessActionDataResult_Tags.ErrorStatus;
    inner: Readonly<{ reason: string }>;
  };

  class ErrorStatus_ extends UniffiEnum implements ErrorStatus__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AesSuccessActionDataResult';
    readonly tag = AesSuccessActionDataResult_Tags.ErrorStatus;
    readonly inner: Readonly<{ reason: string }>;
    constructor(inner: { reason: string }) {
      super('AesSuccessActionDataResult', 'ErrorStatus');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { reason: string }): ErrorStatus_ {
      return new ErrorStatus_(inner);
    }

    static instanceOf(obj: any): obj is ErrorStatus_ {
      return obj.tag === AesSuccessActionDataResult_Tags.ErrorStatus;
    }
  }

  function instanceOf(obj: any): obj is AesSuccessActionDataResult {
    return obj[uniffiTypeNameSymbol] === 'AesSuccessActionDataResult';
  }

  return Object.freeze({
    instanceOf,
    Decrypted: Decrypted_,
    ErrorStatus: ErrorStatus_,
  });
})();

export type AesSuccessActionDataResult = InstanceType<
  (typeof AesSuccessActionDataResult)[keyof Omit<
    typeof AesSuccessActionDataResult,
    'instanceOf'
  >]
>;

// FfiConverter for enum AesSuccessActionDataResult
const FfiConverterTypeAesSuccessActionDataResult = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AesSuccessActionDataResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AesSuccessActionDataResult.Decrypted({
            data: FfiConverterTypeAesSuccessActionDataDecrypted.read(from),
          });
        case 2:
          return new AesSuccessActionDataResult.ErrorStatus({
            reason: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AesSuccessActionDataResult_Tags.Decrypted: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionDataDecrypted.write(inner.data, into);
          return;
        }
        case AesSuccessActionDataResult_Tags.ErrorStatus: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.reason, into);
          return;
        }
        default:
          // Throwing from here means that AesSuccessActionDataResult_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AesSuccessActionDataResult_Tags.Decrypted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionDataDecrypted.allocationSize(
            inner.data
          );
          return size;
        }
        case AesSuccessActionDataResult_Tags.ErrorStatus: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.reason);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Amount
export enum Amount_Tags {
  Bitcoin = 'Bitcoin',
  Currency = 'Currency',
}
export const Amount = (() => {
  type Bitcoin__interface = {
    tag: Amount_Tags.Bitcoin;
    inner: Readonly<{ amountMsat: /*u64*/ bigint }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Amount';
    readonly tag = Amount_Tags.Bitcoin;
    readonly inner: Readonly<{ amountMsat: /*u64*/ bigint }>;
    constructor(inner: { amountMsat: /*u64*/ bigint }) {
      super('Amount', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { amountMsat: /*u64*/ bigint }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === Amount_Tags.Bitcoin;
    }
  }

  type Currency__interface = {
    tag: Amount_Tags.Currency;
    inner: Readonly<{ iso4217Code: string; fractionalAmount: /*u64*/ bigint }>;
  };

  class Currency_ extends UniffiEnum implements Currency__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Amount';
    readonly tag = Amount_Tags.Currency;
    readonly inner: Readonly<{
      iso4217Code: string;
      fractionalAmount: /*u64*/ bigint;
    }>;
    constructor(inner: {
      iso4217Code: string;
      fractionalAmount: /*u64*/ bigint;
    }) {
      super('Amount', 'Currency');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      iso4217Code: string;
      fractionalAmount: /*u64*/ bigint;
    }): Currency_ {
      return new Currency_(inner);
    }

    static instanceOf(obj: any): obj is Currency_ {
      return obj.tag === Amount_Tags.Currency;
    }
  }

  function instanceOf(obj: any): obj is Amount {
    return obj[uniffiTypeNameSymbol] === 'Amount';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Currency: Currency_,
  });
})();

export type Amount = InstanceType<
  (typeof Amount)[keyof Omit<typeof Amount, 'instanceOf'>]
>;

// FfiConverter for enum Amount
const FfiConverterTypeAmount = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Amount;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Amount.Bitcoin({
            amountMsat: FfiConverterUInt64.read(from),
          });
        case 2:
          return new Amount.Currency({
            iso4217Code: FfiConverterString.read(from),
            fractionalAmount: FfiConverterUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Amount_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.amountMsat, into);
          return;
        }
        case Amount_Tags.Currency: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.iso4217Code, into);
          FfiConverterUInt64.write(inner.fractionalAmount, into);
          return;
        }
        default:
          // Throwing from here means that Amount_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Amount_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.amountMsat);
          return size;
        }
        case Amount_Tags.Currency: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.iso4217Code);
          size += FfiConverterUInt64.allocationSize(inner.fractionalAmount);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: BlockchainExplorer
export enum BlockchainExplorer_Tags {
  Electrum = 'Electrum',
  Esplora = 'Esplora',
}
export const BlockchainExplorer = (() => {
  type Electrum__interface = {
    tag: BlockchainExplorer_Tags.Electrum;
    inner: Readonly<{ url: string }>;
  };

  class Electrum_ extends UniffiEnum implements Electrum__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BlockchainExplorer';
    readonly tag = BlockchainExplorer_Tags.Electrum;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('BlockchainExplorer', 'Electrum');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Electrum_ {
      return new Electrum_(inner);
    }

    static instanceOf(obj: any): obj is Electrum_ {
      return obj.tag === BlockchainExplorer_Tags.Electrum;
    }
  }

  type Esplora__interface = {
    tag: BlockchainExplorer_Tags.Esplora;
    inner: Readonly<{ url: string; useWaterfalls: boolean }>;
  };

  class Esplora_ extends UniffiEnum implements Esplora__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BlockchainExplorer';
    readonly tag = BlockchainExplorer_Tags.Esplora;
    readonly inner: Readonly<{ url: string; useWaterfalls: boolean }>;
    constructor(inner: { url: string; useWaterfalls: boolean }) {
      super('BlockchainExplorer', 'Esplora');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string; useWaterfalls: boolean }): Esplora_ {
      return new Esplora_(inner);
    }

    static instanceOf(obj: any): obj is Esplora_ {
      return obj.tag === BlockchainExplorer_Tags.Esplora;
    }
  }

  function instanceOf(obj: any): obj is BlockchainExplorer {
    return obj[uniffiTypeNameSymbol] === 'BlockchainExplorer';
  }

  return Object.freeze({
    instanceOf,
    Electrum: Electrum_,
    Esplora: Esplora_,
  });
})();

export type BlockchainExplorer = InstanceType<
  (typeof BlockchainExplorer)[keyof Omit<
    typeof BlockchainExplorer,
    'instanceOf'
  >]
>;

// FfiConverter for enum BlockchainExplorer
const FfiConverterTypeBlockchainExplorer = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BlockchainExplorer;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new BlockchainExplorer.Electrum({
            url: FfiConverterString.read(from),
          });
        case 2:
          return new BlockchainExplorer.Esplora({
            url: FfiConverterString.read(from),
            useWaterfalls: FfiConverterBool.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case BlockchainExplorer_Tags.Electrum: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case BlockchainExplorer_Tags.Esplora: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          FfiConverterBool.write(inner.useWaterfalls, into);
          return;
        }
        default:
          // Throwing from here means that BlockchainExplorer_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case BlockchainExplorer_Tags.Electrum: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case BlockchainExplorer_Tags.Esplora: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.url);
          size += FfiConverterBool.allocationSize(inner.useWaterfalls);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum BuyBitcoinProvider {
  Moonpay,
}

const FfiConverterTypeBuyBitcoinProvider = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BuyBitcoinProvider;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BuyBitcoinProvider.Moonpay;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BuyBitcoinProvider.Moonpay:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: GetPaymentRequest
export enum GetPaymentRequest_Tags {
  PaymentHash = 'PaymentHash',
  SwapId = 'SwapId',
}
export const GetPaymentRequest = (() => {
  type PaymentHash__interface = {
    tag: GetPaymentRequest_Tags.PaymentHash;
    inner: Readonly<{ paymentHash: string }>;
  };

  class PaymentHash_ extends UniffiEnum implements PaymentHash__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GetPaymentRequest';
    readonly tag = GetPaymentRequest_Tags.PaymentHash;
    readonly inner: Readonly<{ paymentHash: string }>;
    constructor(inner: { paymentHash: string }) {
      super('GetPaymentRequest', 'PaymentHash');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { paymentHash: string }): PaymentHash_ {
      return new PaymentHash_(inner);
    }

    static instanceOf(obj: any): obj is PaymentHash_ {
      return obj.tag === GetPaymentRequest_Tags.PaymentHash;
    }
  }

  type SwapId__interface = {
    tag: GetPaymentRequest_Tags.SwapId;
    inner: Readonly<{ swapId: string }>;
  };

  class SwapId_ extends UniffiEnum implements SwapId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GetPaymentRequest';
    readonly tag = GetPaymentRequest_Tags.SwapId;
    readonly inner: Readonly<{ swapId: string }>;
    constructor(inner: { swapId: string }) {
      super('GetPaymentRequest', 'SwapId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { swapId: string }): SwapId_ {
      return new SwapId_(inner);
    }

    static instanceOf(obj: any): obj is SwapId_ {
      return obj.tag === GetPaymentRequest_Tags.SwapId;
    }
  }

  function instanceOf(obj: any): obj is GetPaymentRequest {
    return obj[uniffiTypeNameSymbol] === 'GetPaymentRequest';
  }

  return Object.freeze({
    instanceOf,
    PaymentHash: PaymentHash_,
    SwapId: SwapId_,
  });
})();

export type GetPaymentRequest = InstanceType<
  (typeof GetPaymentRequest)[keyof Omit<typeof GetPaymentRequest, 'instanceOf'>]
>;

// FfiConverter for enum GetPaymentRequest
const FfiConverterTypeGetPaymentRequest = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = GetPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new GetPaymentRequest.PaymentHash({
            paymentHash: FfiConverterString.read(from),
          });
        case 2:
          return new GetPaymentRequest.SwapId({
            swapId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case GetPaymentRequest_Tags.PaymentHash: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.paymentHash, into);
          return;
        }
        case GetPaymentRequest_Tags.SwapId: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.swapId, into);
          return;
        }
        default:
          // Throwing from here means that GetPaymentRequest_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case GetPaymentRequest_Tags.PaymentHash: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.paymentHash);
          return size;
        }
        case GetPaymentRequest_Tags.SwapId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.swapId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: InputType
export enum InputType_Tags {
  BitcoinAddress = 'BitcoinAddress',
  LiquidAddress = 'LiquidAddress',
  Bolt11 = 'Bolt11',
  Bolt12Offer = 'Bolt12Offer',
  NodeId = 'NodeId',
  Url = 'Url',
  LnUrlPay = 'LnUrlPay',
  LnUrlWithdraw = 'LnUrlWithdraw',
  LnUrlAuth = 'LnUrlAuth',
  LnUrlError = 'LnUrlError',
}
export const InputType = (() => {
  type BitcoinAddress__interface = {
    tag: InputType_Tags.BitcoinAddress;
    inner: Readonly<{ address: BitcoinAddressData }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.BitcoinAddress;
    readonly inner: Readonly<{ address: BitcoinAddressData }>;
    constructor(inner: { address: BitcoinAddressData }) {
      super('InputType', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { address: BitcoinAddressData }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === InputType_Tags.BitcoinAddress;
    }
  }

  type LiquidAddress__interface = {
    tag: InputType_Tags.LiquidAddress;
    inner: Readonly<{ address: LiquidAddressData }>;
  };

  class LiquidAddress_ extends UniffiEnum implements LiquidAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LiquidAddress;
    readonly inner: Readonly<{ address: LiquidAddressData }>;
    constructor(inner: { address: LiquidAddressData }) {
      super('InputType', 'LiquidAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { address: LiquidAddressData }): LiquidAddress_ {
      return new LiquidAddress_(inner);
    }

    static instanceOf(obj: any): obj is LiquidAddress_ {
      return obj.tag === InputType_Tags.LiquidAddress;
    }
  }

  type Bolt11__interface = {
    tag: InputType_Tags.Bolt11;
    inner: Readonly<{ invoice: LnInvoice }>;
  };

  class Bolt11_ extends UniffiEnum implements Bolt11__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt11;
    readonly inner: Readonly<{ invoice: LnInvoice }>;
    constructor(inner: { invoice: LnInvoice }) {
      super('InputType', 'Bolt11');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { invoice: LnInvoice }): Bolt11_ {
      return new Bolt11_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11_ {
      return obj.tag === InputType_Tags.Bolt11;
    }
  }

  type Bolt12Offer__interface = {
    tag: InputType_Tags.Bolt12Offer;
    inner: Readonly<{ offer: LnOffer; bip353Address: string | undefined }>;
  };

  class Bolt12Offer_ extends UniffiEnum implements Bolt12Offer__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt12Offer;
    readonly inner: Readonly<{
      offer: LnOffer;
      bip353Address: string | undefined;
    }>;
    constructor(inner: { offer: LnOffer; bip353Address: string | undefined }) {
      super('InputType', 'Bolt12Offer');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      offer: LnOffer;
      bip353Address: string | undefined;
    }): Bolt12Offer_ {
      return new Bolt12Offer_(inner);
    }

    static instanceOf(obj: any): obj is Bolt12Offer_ {
      return obj.tag === InputType_Tags.Bolt12Offer;
    }
  }

  type NodeId__interface = {
    tag: InputType_Tags.NodeId;
    inner: Readonly<{ nodeId: string }>;
  };

  class NodeId_ extends UniffiEnum implements NodeId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.NodeId;
    readonly inner: Readonly<{ nodeId: string }>;
    constructor(inner: { nodeId: string }) {
      super('InputType', 'NodeId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { nodeId: string }): NodeId_ {
      return new NodeId_(inner);
    }

    static instanceOf(obj: any): obj is NodeId_ {
      return obj.tag === InputType_Tags.NodeId;
    }
  }

  type Url__interface = {
    tag: InputType_Tags.Url;
    inner: Readonly<{ url: string }>;
  };

  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Url;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('InputType', 'Url');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Url_ {
      return new Url_(inner);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === InputType_Tags.Url;
    }
  }

  type LnUrlPay__interface = {
    tag: InputType_Tags.LnUrlPay;
    inner: Readonly<{
      data: LnUrlPayRequestData;
      bip353Address: string | undefined;
    }>;
  };

  class LnUrlPay_ extends UniffiEnum implements LnUrlPay__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnUrlPay;
    readonly inner: Readonly<{
      data: LnUrlPayRequestData;
      bip353Address: string | undefined;
    }>;
    constructor(inner: {
      data: LnUrlPayRequestData;
      bip353Address: string | undefined;
    }) {
      super('InputType', 'LnUrlPay');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      data: LnUrlPayRequestData;
      bip353Address: string | undefined;
    }): LnUrlPay_ {
      return new LnUrlPay_(inner);
    }

    static instanceOf(obj: any): obj is LnUrlPay_ {
      return obj.tag === InputType_Tags.LnUrlPay;
    }
  }

  type LnUrlWithdraw__interface = {
    tag: InputType_Tags.LnUrlWithdraw;
    inner: Readonly<{ data: LnUrlWithdrawRequestData }>;
  };

  class LnUrlWithdraw_ extends UniffiEnum implements LnUrlWithdraw__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnUrlWithdraw;
    readonly inner: Readonly<{ data: LnUrlWithdrawRequestData }>;
    constructor(inner: { data: LnUrlWithdrawRequestData }) {
      super('InputType', 'LnUrlWithdraw');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlWithdrawRequestData }): LnUrlWithdraw_ {
      return new LnUrlWithdraw_(inner);
    }

    static instanceOf(obj: any): obj is LnUrlWithdraw_ {
      return obj.tag === InputType_Tags.LnUrlWithdraw;
    }
  }

  type LnUrlAuth__interface = {
    tag: InputType_Tags.LnUrlAuth;
    inner: Readonly<{ data: LnUrlAuthRequestData }>;
  };

  class LnUrlAuth_ extends UniffiEnum implements LnUrlAuth__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnUrlAuth;
    readonly inner: Readonly<{ data: LnUrlAuthRequestData }>;
    constructor(inner: { data: LnUrlAuthRequestData }) {
      super('InputType', 'LnUrlAuth');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlAuthRequestData }): LnUrlAuth_ {
      return new LnUrlAuth_(inner);
    }

    static instanceOf(obj: any): obj is LnUrlAuth_ {
      return obj.tag === InputType_Tags.LnUrlAuth;
    }
  }

  type LnUrlError__interface = {
    tag: InputType_Tags.LnUrlError;
    inner: Readonly<{ data: LnUrlErrorData }>;
  };

  class LnUrlError_ extends UniffiEnum implements LnUrlError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnUrlError;
    readonly inner: Readonly<{ data: LnUrlErrorData }>;
    constructor(inner: { data: LnUrlErrorData }) {
      super('InputType', 'LnUrlError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlErrorData }): LnUrlError_ {
      return new LnUrlError_(inner);
    }

    static instanceOf(obj: any): obj is LnUrlError_ {
      return obj.tag === InputType_Tags.LnUrlError;
    }
  }

  function instanceOf(obj: any): obj is InputType {
    return obj[uniffiTypeNameSymbol] === 'InputType';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    LiquidAddress: LiquidAddress_,
    Bolt11: Bolt11_,
    Bolt12Offer: Bolt12Offer_,
    NodeId: NodeId_,
    Url: Url_,
    LnUrlPay: LnUrlPay_,
    LnUrlWithdraw: LnUrlWithdraw_,
    LnUrlAuth: LnUrlAuth_,
    LnUrlError: LnUrlError_,
  });
})();

export type InputType = InstanceType<
  (typeof InputType)[keyof Omit<typeof InputType, 'instanceOf'>]
>;

// FfiConverter for enum InputType
const FfiConverterTypeInputType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = InputType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new InputType.BitcoinAddress({
            address: FfiConverterTypeBitcoinAddressData.read(from),
          });
        case 2:
          return new InputType.LiquidAddress({
            address: FfiConverterTypeLiquidAddressData.read(from),
          });
        case 3:
          return new InputType.Bolt11({
            invoice: FfiConverterTypeLNInvoice.read(from),
          });
        case 4:
          return new InputType.Bolt12Offer({
            offer: FfiConverterTypeLNOffer.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
          });
        case 5:
          return new InputType.NodeId({
            nodeId: FfiConverterString.read(from),
          });
        case 6:
          return new InputType.Url({ url: FfiConverterString.read(from) });
        case 7:
          return new InputType.LnUrlPay({
            data: FfiConverterTypeLnUrlPayRequestData.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
          });
        case 8:
          return new InputType.LnUrlWithdraw({
            data: FfiConverterTypeLnUrlWithdrawRequestData.read(from),
          });
        case 9:
          return new InputType.LnUrlAuth({
            data: FfiConverterTypeLnUrlAuthRequestData.read(from),
          });
        case 10:
          return new InputType.LnUrlError({
            data: FfiConverterTypeLnUrlErrorData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case InputType_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeBitcoinAddressData.write(inner.address, into);
          return;
        }
        case InputType_Tags.LiquidAddress: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeLiquidAddressData.write(inner.address, into);
          return;
        }
        case InputType_Tags.Bolt11: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeLNInvoice.write(inner.invoice, into);
          return;
        }
        case InputType_Tags.Bolt12Offer: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeLNOffer.write(inner.offer, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          return;
        }
        case InputType_Tags.NodeId: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.nodeId, into);
          return;
        }
        case InputType_Tags.Url: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case InputType_Tags.LnUrlPay: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlPayRequestData.write(inner.data, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          return;
        }
        case InputType_Tags.LnUrlWithdraw: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlWithdrawRequestData.write(inner.data, into);
          return;
        }
        case InputType_Tags.LnUrlAuth: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlAuthRequestData.write(inner.data, into);
          return;
        }
        case InputType_Tags.LnUrlError: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlErrorData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that InputType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case InputType_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeBitcoinAddressData.allocationSize(
            inner.address
          );
          return size;
        }
        case InputType_Tags.LiquidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeLiquidAddressData.allocationSize(
            inner.address
          );
          return size;
        }
        case InputType_Tags.Bolt11: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeLNInvoice.allocationSize(inner.invoice);
          return size;
        }
        case InputType_Tags.Bolt12Offer: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeLNOffer.allocationSize(inner.offer);
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          return size;
        }
        case InputType_Tags.NodeId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.nodeId);
          return size;
        }
        case InputType_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case InputType_Tags.LnUrlPay: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeLnUrlPayRequestData.allocationSize(
            inner.data
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          return size;
        }
        case InputType_Tags.LnUrlWithdraw: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeLnUrlWithdrawRequestData.allocationSize(
            inner.data
          );
          return size;
        }
        case InputType_Tags.LnUrlAuth: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeLnUrlAuthRequestData.allocationSize(
            inner.data
          );
          return size;
        }
        case InputType_Tags.LnUrlError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterTypeLnUrlErrorData.allocationSize(inner.data);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum LiquidNetwork {
  Mainnet,
  Testnet,
  Regtest,
}

const FfiConverterTypeLiquidNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LiquidNetwork;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LiquidNetwork.Mainnet;
        case 2:
          return LiquidNetwork.Testnet;
        case 3:
          return LiquidNetwork.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LiquidNetwork.Mainnet:
          return ordinalConverter.write(1, into);
        case LiquidNetwork.Testnet:
          return ordinalConverter.write(2, into);
        case LiquidNetwork.Regtest:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ListPaymentDetails
export enum ListPaymentDetails_Tags {
  Liquid = 'Liquid',
  Bitcoin = 'Bitcoin',
}
export const ListPaymentDetails = (() => {
  type Liquid__interface = {
    tag: ListPaymentDetails_Tags.Liquid;
    inner: Readonly<{
      assetId: string | undefined;
      destination: string | undefined;
    }>;
  };

  class Liquid_ extends UniffiEnum implements Liquid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ListPaymentDetails';
    readonly tag = ListPaymentDetails_Tags.Liquid;
    readonly inner: Readonly<{
      assetId: string | undefined;
      destination: string | undefined;
    }>;
    constructor(inner: {
      assetId: string | undefined;
      destination: string | undefined;
    }) {
      super('ListPaymentDetails', 'Liquid');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      assetId: string | undefined;
      destination: string | undefined;
    }): Liquid_ {
      return new Liquid_(inner);
    }

    static instanceOf(obj: any): obj is Liquid_ {
      return obj.tag === ListPaymentDetails_Tags.Liquid;
    }
  }

  type Bitcoin__interface = {
    tag: ListPaymentDetails_Tags.Bitcoin;
    inner: Readonly<{ address: string | undefined }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ListPaymentDetails';
    readonly tag = ListPaymentDetails_Tags.Bitcoin;
    readonly inner: Readonly<{ address: string | undefined }>;
    constructor(inner: { address: string | undefined }) {
      super('ListPaymentDetails', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { address: string | undefined }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === ListPaymentDetails_Tags.Bitcoin;
    }
  }

  function instanceOf(obj: any): obj is ListPaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'ListPaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Liquid: Liquid_,
    Bitcoin: Bitcoin_,
  });
})();

export type ListPaymentDetails = InstanceType<
  (typeof ListPaymentDetails)[keyof Omit<
    typeof ListPaymentDetails,
    'instanceOf'
  >]
>;

// FfiConverter for enum ListPaymentDetails
const FfiConverterTypeListPaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ListPaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ListPaymentDetails.Liquid({
            assetId: FfiConverterOptionalString.read(from),
            destination: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new ListPaymentDetails.Bitcoin({
            address: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ListPaymentDetails_Tags.Liquid: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.assetId, into);
          FfiConverterOptionalString.write(inner.destination, into);
          return;
        }
        case ListPaymentDetails_Tags.Bitcoin: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.address, into);
          return;
        }
        default:
          // Throwing from here means that ListPaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ListPaymentDetails_Tags.Liquid: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterOptionalString.allocationSize(inner.assetId);
          size += FfiConverterOptionalString.allocationSize(inner.destination);
          return size;
        }
        case ListPaymentDetails_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(inner.address);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: LnUrlAuthError

// Enum: LnUrlAuthError
export enum LnUrlAuthError_Tags {
  Generic = 'Generic',
  InvalidUri = 'InvalidUri',
  ServiceConnectivity = 'ServiceConnectivity',
}
export const LnUrlAuthError = (() => {
  type Generic__interface = {
    tag: LnUrlAuthError_Tags.Generic;
    inner: Readonly<{ err: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlAuthError';
    readonly tag = LnUrlAuthError_Tags.Generic;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlAuthError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === LnUrlAuthError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidUri__interface = {
    tag: LnUrlAuthError_Tags.InvalidUri;
    inner: Readonly<{ err: string }>;
  };

  class InvalidUri_ extends UniffiError implements InvalidUri__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlAuthError';
    readonly tag = LnUrlAuthError_Tags.InvalidUri;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlAuthError', 'InvalidUri');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidUri_ {
      return new InvalidUri_(inner);
    }

    static instanceOf(obj: any): obj is InvalidUri_ {
      return obj.tag === LnUrlAuthError_Tags.InvalidUri;
    }

    static hasInner(obj: any): obj is InvalidUri_ {
      return InvalidUri_.instanceOf(obj);
    }

    static getInner(obj: InvalidUri_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: LnUrlAuthError_Tags.ServiceConnectivity;
    inner: Readonly<{ err: string }>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlAuthError';
    readonly tag = LnUrlAuthError_Tags.ServiceConnectivity;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlAuthError', 'ServiceConnectivity');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): ServiceConnectivity_ {
      return new ServiceConnectivity_(inner);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === LnUrlAuthError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is LnUrlAuthError {
    return obj[uniffiTypeNameSymbol] === 'LnUrlAuthError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
    InvalidUri: InvalidUri_,
    ServiceConnectivity: ServiceConnectivity_,
  });
})();

export type LnUrlAuthError = InstanceType<
  (typeof LnUrlAuthError)[keyof Omit<typeof LnUrlAuthError, 'instanceOf'>]
>;

// FfiConverter for enum LnUrlAuthError
const FfiConverterTypeLnUrlAuthError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlAuthError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlAuthError.Generic({
            err: FfiConverterString.read(from),
          });
        case 2:
          return new LnUrlAuthError.InvalidUri({
            err: FfiConverterString.read(from),
          });
        case 3:
          return new LnUrlAuthError.ServiceConnectivity({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlAuthError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlAuthError_Tags.InvalidUri: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlAuthError_Tags.ServiceConnectivity: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlAuthError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlAuthError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlAuthError_Tags.InvalidUri: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlAuthError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: LnUrlCallbackStatus
export enum LnUrlCallbackStatus_Tags {
  Ok = 'Ok',
  ErrorStatus = 'ErrorStatus',
}
export const LnUrlCallbackStatus = (() => {
  type Ok__interface = {
    tag: LnUrlCallbackStatus_Tags.Ok;
  };

  class Ok_ extends UniffiEnum implements Ok__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlCallbackStatus';
    readonly tag = LnUrlCallbackStatus_Tags.Ok;
    constructor() {
      super('LnUrlCallbackStatus', 'Ok');
    }

    static new(): Ok_ {
      return new Ok_();
    }

    static instanceOf(obj: any): obj is Ok_ {
      return obj.tag === LnUrlCallbackStatus_Tags.Ok;
    }
  }

  type ErrorStatus__interface = {
    tag: LnUrlCallbackStatus_Tags.ErrorStatus;
    inner: Readonly<{ data: LnUrlErrorData }>;
  };

  class ErrorStatus_ extends UniffiEnum implements ErrorStatus__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlCallbackStatus';
    readonly tag = LnUrlCallbackStatus_Tags.ErrorStatus;
    readonly inner: Readonly<{ data: LnUrlErrorData }>;
    constructor(inner: { data: LnUrlErrorData }) {
      super('LnUrlCallbackStatus', 'ErrorStatus');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlErrorData }): ErrorStatus_ {
      return new ErrorStatus_(inner);
    }

    static instanceOf(obj: any): obj is ErrorStatus_ {
      return obj.tag === LnUrlCallbackStatus_Tags.ErrorStatus;
    }
  }

  function instanceOf(obj: any): obj is LnUrlCallbackStatus {
    return obj[uniffiTypeNameSymbol] === 'LnUrlCallbackStatus';
  }

  return Object.freeze({
    instanceOf,
    Ok: Ok_,
    ErrorStatus: ErrorStatus_,
  });
})();

export type LnUrlCallbackStatus = InstanceType<
  (typeof LnUrlCallbackStatus)[keyof Omit<
    typeof LnUrlCallbackStatus,
    'instanceOf'
  >]
>;

// FfiConverter for enum LnUrlCallbackStatus
const FfiConverterTypeLnUrlCallbackStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlCallbackStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlCallbackStatus.Ok();
        case 2:
          return new LnUrlCallbackStatus.ErrorStatus({
            data: FfiConverterTypeLnUrlErrorData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlCallbackStatus_Tags.Ok: {
          ordinalConverter.write(1, into);
          return;
        }
        case LnUrlCallbackStatus_Tags.ErrorStatus: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlErrorData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlCallbackStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlCallbackStatus_Tags.Ok: {
          return ordinalConverter.allocationSize(1);
        }
        case LnUrlCallbackStatus_Tags.ErrorStatus: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeLnUrlErrorData.allocationSize(inner.data);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: LnUrlPayError

// Enum: LnUrlPayError
export enum LnUrlPayError_Tags {
  AlreadyPaid = 'AlreadyPaid',
  Generic = 'Generic',
  InsufficientBalance = 'InsufficientBalance',
  InvalidAmount = 'InvalidAmount',
  InvalidInvoice = 'InvalidInvoice',
  InvalidNetwork = 'InvalidNetwork',
  InvalidUri = 'InvalidUri',
  InvoiceExpired = 'InvoiceExpired',
  PaymentFailed = 'PaymentFailed',
  PaymentTimeout = 'PaymentTimeout',
  RouteNotFound = 'RouteNotFound',
  RouteTooExpensive = 'RouteTooExpensive',
  ServiceConnectivity = 'ServiceConnectivity',
}
export const LnUrlPayError = (() => {
  type AlreadyPaid__interface = {
    tag: LnUrlPayError_Tags.AlreadyPaid;
  };

  class AlreadyPaid_ extends UniffiError implements AlreadyPaid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.AlreadyPaid;
    constructor() {
      super('LnUrlPayError', 'AlreadyPaid');
    }

    static new(): AlreadyPaid_ {
      return new AlreadyPaid_();
    }

    static instanceOf(obj: any): obj is AlreadyPaid_ {
      return obj.tag === LnUrlPayError_Tags.AlreadyPaid;
    }

    static hasInner(obj: any): obj is AlreadyPaid_ {
      return false;
    }
  }

  type Generic__interface = {
    tag: LnUrlPayError_Tags.Generic;
    inner: Readonly<{ err: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.Generic;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === LnUrlPayError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InsufficientBalance__interface = {
    tag: LnUrlPayError_Tags.InsufficientBalance;
    inner: Readonly<{ err: string }>;
  };

  class InsufficientBalance_
    extends UniffiError
    implements InsufficientBalance__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InsufficientBalance;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InsufficientBalance');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InsufficientBalance_ {
      return new InsufficientBalance_(inner);
    }

    static instanceOf(obj: any): obj is InsufficientBalance_ {
      return obj.tag === LnUrlPayError_Tags.InsufficientBalance;
    }

    static hasInner(obj: any): obj is InsufficientBalance_ {
      return InsufficientBalance_.instanceOf(obj);
    }

    static getInner(obj: InsufficientBalance_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidAmount__interface = {
    tag: LnUrlPayError_Tags.InvalidAmount;
    inner: Readonly<{ err: string }>;
  };

  class InvalidAmount_ extends UniffiError implements InvalidAmount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InvalidAmount;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InvalidAmount');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidAmount_ {
      return new InvalidAmount_(inner);
    }

    static instanceOf(obj: any): obj is InvalidAmount_ {
      return obj.tag === LnUrlPayError_Tags.InvalidAmount;
    }

    static hasInner(obj: any): obj is InvalidAmount_ {
      return InvalidAmount_.instanceOf(obj);
    }

    static getInner(obj: InvalidAmount_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidInvoice__interface = {
    tag: LnUrlPayError_Tags.InvalidInvoice;
    inner: Readonly<{ err: string }>;
  };

  class InvalidInvoice_
    extends UniffiError
    implements InvalidInvoice__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InvalidInvoice;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InvalidInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidInvoice_ {
      return new InvalidInvoice_(inner);
    }

    static instanceOf(obj: any): obj is InvalidInvoice_ {
      return obj.tag === LnUrlPayError_Tags.InvalidInvoice;
    }

    static hasInner(obj: any): obj is InvalidInvoice_ {
      return InvalidInvoice_.instanceOf(obj);
    }

    static getInner(obj: InvalidInvoice_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidNetwork__interface = {
    tag: LnUrlPayError_Tags.InvalidNetwork;
    inner: Readonly<{ err: string }>;
  };

  class InvalidNetwork_
    extends UniffiError
    implements InvalidNetwork__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InvalidNetwork;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InvalidNetwork');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidNetwork_ {
      return new InvalidNetwork_(inner);
    }

    static instanceOf(obj: any): obj is InvalidNetwork_ {
      return obj.tag === LnUrlPayError_Tags.InvalidNetwork;
    }

    static hasInner(obj: any): obj is InvalidNetwork_ {
      return InvalidNetwork_.instanceOf(obj);
    }

    static getInner(obj: InvalidNetwork_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidUri__interface = {
    tag: LnUrlPayError_Tags.InvalidUri;
    inner: Readonly<{ err: string }>;
  };

  class InvalidUri_ extends UniffiError implements InvalidUri__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InvalidUri;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InvalidUri');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidUri_ {
      return new InvalidUri_(inner);
    }

    static instanceOf(obj: any): obj is InvalidUri_ {
      return obj.tag === LnUrlPayError_Tags.InvalidUri;
    }

    static hasInner(obj: any): obj is InvalidUri_ {
      return InvalidUri_.instanceOf(obj);
    }

    static getInner(obj: InvalidUri_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvoiceExpired__interface = {
    tag: LnUrlPayError_Tags.InvoiceExpired;
    inner: Readonly<{ err: string }>;
  };

  class InvoiceExpired_
    extends UniffiError
    implements InvoiceExpired__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.InvoiceExpired;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'InvoiceExpired');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvoiceExpired_ {
      return new InvoiceExpired_(inner);
    }

    static instanceOf(obj: any): obj is InvoiceExpired_ {
      return obj.tag === LnUrlPayError_Tags.InvoiceExpired;
    }

    static hasInner(obj: any): obj is InvoiceExpired_ {
      return InvoiceExpired_.instanceOf(obj);
    }

    static getInner(obj: InvoiceExpired_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type PaymentFailed__interface = {
    tag: LnUrlPayError_Tags.PaymentFailed;
    inner: Readonly<{ err: string }>;
  };

  class PaymentFailed_ extends UniffiError implements PaymentFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.PaymentFailed;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'PaymentFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): PaymentFailed_ {
      return new PaymentFailed_(inner);
    }

    static instanceOf(obj: any): obj is PaymentFailed_ {
      return obj.tag === LnUrlPayError_Tags.PaymentFailed;
    }

    static hasInner(obj: any): obj is PaymentFailed_ {
      return PaymentFailed_.instanceOf(obj);
    }

    static getInner(obj: PaymentFailed_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type PaymentTimeout__interface = {
    tag: LnUrlPayError_Tags.PaymentTimeout;
    inner: Readonly<{ err: string }>;
  };

  class PaymentTimeout_
    extends UniffiError
    implements PaymentTimeout__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.PaymentTimeout;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'PaymentTimeout');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): PaymentTimeout_ {
      return new PaymentTimeout_(inner);
    }

    static instanceOf(obj: any): obj is PaymentTimeout_ {
      return obj.tag === LnUrlPayError_Tags.PaymentTimeout;
    }

    static hasInner(obj: any): obj is PaymentTimeout_ {
      return PaymentTimeout_.instanceOf(obj);
    }

    static getInner(obj: PaymentTimeout_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type RouteNotFound__interface = {
    tag: LnUrlPayError_Tags.RouteNotFound;
    inner: Readonly<{ err: string }>;
  };

  class RouteNotFound_ extends UniffiError implements RouteNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.RouteNotFound;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'RouteNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): RouteNotFound_ {
      return new RouteNotFound_(inner);
    }

    static instanceOf(obj: any): obj is RouteNotFound_ {
      return obj.tag === LnUrlPayError_Tags.RouteNotFound;
    }

    static hasInner(obj: any): obj is RouteNotFound_ {
      return RouteNotFound_.instanceOf(obj);
    }

    static getInner(obj: RouteNotFound_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type RouteTooExpensive__interface = {
    tag: LnUrlPayError_Tags.RouteTooExpensive;
    inner: Readonly<{ err: string }>;
  };

  class RouteTooExpensive_
    extends UniffiError
    implements RouteTooExpensive__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.RouteTooExpensive;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'RouteTooExpensive');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): RouteTooExpensive_ {
      return new RouteTooExpensive_(inner);
    }

    static instanceOf(obj: any): obj is RouteTooExpensive_ {
      return obj.tag === LnUrlPayError_Tags.RouteTooExpensive;
    }

    static hasInner(obj: any): obj is RouteTooExpensive_ {
      return RouteTooExpensive_.instanceOf(obj);
    }

    static getInner(obj: RouteTooExpensive_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: LnUrlPayError_Tags.ServiceConnectivity;
    inner: Readonly<{ err: string }>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayError';
    readonly tag = LnUrlPayError_Tags.ServiceConnectivity;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlPayError', 'ServiceConnectivity');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): ServiceConnectivity_ {
      return new ServiceConnectivity_(inner);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === LnUrlPayError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is LnUrlPayError {
    return obj[uniffiTypeNameSymbol] === 'LnUrlPayError';
  }

  return Object.freeze({
    instanceOf,
    AlreadyPaid: AlreadyPaid_,
    Generic: Generic_,
    InsufficientBalance: InsufficientBalance_,
    InvalidAmount: InvalidAmount_,
    InvalidInvoice: InvalidInvoice_,
    InvalidNetwork: InvalidNetwork_,
    InvalidUri: InvalidUri_,
    InvoiceExpired: InvoiceExpired_,
    PaymentFailed: PaymentFailed_,
    PaymentTimeout: PaymentTimeout_,
    RouteNotFound: RouteNotFound_,
    RouteTooExpensive: RouteTooExpensive_,
    ServiceConnectivity: ServiceConnectivity_,
  });
})();

export type LnUrlPayError = InstanceType<
  (typeof LnUrlPayError)[keyof Omit<typeof LnUrlPayError, 'instanceOf'>]
>;

// FfiConverter for enum LnUrlPayError
const FfiConverterTypeLnUrlPayError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlPayError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlPayError.AlreadyPaid();
        case 2:
          return new LnUrlPayError.Generic({
            err: FfiConverterString.read(from),
          });
        case 3:
          return new LnUrlPayError.InsufficientBalance({
            err: FfiConverterString.read(from),
          });
        case 4:
          return new LnUrlPayError.InvalidAmount({
            err: FfiConverterString.read(from),
          });
        case 5:
          return new LnUrlPayError.InvalidInvoice({
            err: FfiConverterString.read(from),
          });
        case 6:
          return new LnUrlPayError.InvalidNetwork({
            err: FfiConverterString.read(from),
          });
        case 7:
          return new LnUrlPayError.InvalidUri({
            err: FfiConverterString.read(from),
          });
        case 8:
          return new LnUrlPayError.InvoiceExpired({
            err: FfiConverterString.read(from),
          });
        case 9:
          return new LnUrlPayError.PaymentFailed({
            err: FfiConverterString.read(from),
          });
        case 10:
          return new LnUrlPayError.PaymentTimeout({
            err: FfiConverterString.read(from),
          });
        case 11:
          return new LnUrlPayError.RouteNotFound({
            err: FfiConverterString.read(from),
          });
        case 12:
          return new LnUrlPayError.RouteTooExpensive({
            err: FfiConverterString.read(from),
          });
        case 13:
          return new LnUrlPayError.ServiceConnectivity({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlPayError_Tags.AlreadyPaid: {
          ordinalConverter.write(1, into);
          return;
        }
        case LnUrlPayError_Tags.Generic: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InsufficientBalance: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InvalidAmount: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InvalidInvoice: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InvalidNetwork: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InvalidUri: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.InvoiceExpired: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.PaymentFailed: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.PaymentTimeout: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.RouteNotFound: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.RouteTooExpensive: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlPayError_Tags.ServiceConnectivity: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlPayError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlPayError_Tags.AlreadyPaid: {
          return ordinalConverter.allocationSize(1);
        }
        case LnUrlPayError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InsufficientBalance: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InvalidAmount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InvalidInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InvalidNetwork: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InvalidUri: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.InvoiceExpired: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.PaymentFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.PaymentTimeout: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.RouteNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.RouteTooExpensive: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlPayError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: LnUrlPayResult
export enum LnUrlPayResult_Tags {
  EndpointSuccess = 'EndpointSuccess',
  EndpointError = 'EndpointError',
  PayError = 'PayError',
}
/**
 * /////////////////////////////
 * ///////////////////////////////
 */
export const LnUrlPayResult = (() => {
  type EndpointSuccess__interface = {
    tag: LnUrlPayResult_Tags.EndpointSuccess;
    inner: Readonly<{ data: LnUrlPaySuccessData }>;
  };

  class EndpointSuccess_
    extends UniffiEnum
    implements EndpointSuccess__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayResult';
    readonly tag = LnUrlPayResult_Tags.EndpointSuccess;
    readonly inner: Readonly<{ data: LnUrlPaySuccessData }>;
    constructor(inner: { data: LnUrlPaySuccessData }) {
      super('LnUrlPayResult', 'EndpointSuccess');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlPaySuccessData }): EndpointSuccess_ {
      return new EndpointSuccess_(inner);
    }

    static instanceOf(obj: any): obj is EndpointSuccess_ {
      return obj.tag === LnUrlPayResult_Tags.EndpointSuccess;
    }
  }

  type EndpointError__interface = {
    tag: LnUrlPayResult_Tags.EndpointError;
    inner: Readonly<{ data: LnUrlErrorData }>;
  };

  class EndpointError_ extends UniffiEnum implements EndpointError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayResult';
    readonly tag = LnUrlPayResult_Tags.EndpointError;
    readonly inner: Readonly<{ data: LnUrlErrorData }>;
    constructor(inner: { data: LnUrlErrorData }) {
      super('LnUrlPayResult', 'EndpointError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlErrorData }): EndpointError_ {
      return new EndpointError_(inner);
    }

    static instanceOf(obj: any): obj is EndpointError_ {
      return obj.tag === LnUrlPayResult_Tags.EndpointError;
    }
  }

  type PayError__interface = {
    tag: LnUrlPayResult_Tags.PayError;
    inner: Readonly<{ data: LnUrlPayErrorData }>;
  };

  class PayError_ extends UniffiEnum implements PayError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlPayResult';
    readonly tag = LnUrlPayResult_Tags.PayError;
    readonly inner: Readonly<{ data: LnUrlPayErrorData }>;
    constructor(inner: { data: LnUrlPayErrorData }) {
      super('LnUrlPayResult', 'PayError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlPayErrorData }): PayError_ {
      return new PayError_(inner);
    }

    static instanceOf(obj: any): obj is PayError_ {
      return obj.tag === LnUrlPayResult_Tags.PayError;
    }
  }

  function instanceOf(obj: any): obj is LnUrlPayResult {
    return obj[uniffiTypeNameSymbol] === 'LnUrlPayResult';
  }

  return Object.freeze({
    instanceOf,
    EndpointSuccess: EndpointSuccess_,
    EndpointError: EndpointError_,
    PayError: PayError_,
  });
})();

/**
 * /////////////////////////////
 * ///////////////////////////////
 */

export type LnUrlPayResult = InstanceType<
  (typeof LnUrlPayResult)[keyof Omit<typeof LnUrlPayResult, 'instanceOf'>]
>;

// FfiConverter for enum LnUrlPayResult
const FfiConverterTypeLnUrlPayResult = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlPayResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlPayResult.EndpointSuccess({
            data: FfiConverterTypeLnUrlPaySuccessData.read(from),
          });
        case 2:
          return new LnUrlPayResult.EndpointError({
            data: FfiConverterTypeLnUrlErrorData.read(from),
          });
        case 3:
          return new LnUrlPayResult.PayError({
            data: FfiConverterTypeLnUrlPayErrorData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlPayResult_Tags.EndpointSuccess: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlPaySuccessData.write(inner.data, into);
          return;
        }
        case LnUrlPayResult_Tags.EndpointError: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlErrorData.write(inner.data, into);
          return;
        }
        case LnUrlPayResult_Tags.PayError: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlPayErrorData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlPayResult_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlPayResult_Tags.EndpointSuccess: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeLnUrlPaySuccessData.allocationSize(
            inner.data
          );
          return size;
        }
        case LnUrlPayResult_Tags.EndpointError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeLnUrlErrorData.allocationSize(inner.data);
          return size;
        }
        case LnUrlPayResult_Tags.PayError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeLnUrlPayErrorData.allocationSize(inner.data);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: LnUrlWithdrawError

// Enum: LnUrlWithdrawError
export enum LnUrlWithdrawError_Tags {
  Generic = 'Generic',
  InvalidAmount = 'InvalidAmount',
  InvalidInvoice = 'InvalidInvoice',
  InvalidUri = 'InvalidUri',
  ServiceConnectivity = 'ServiceConnectivity',
  InvoiceNoRoutingHints = 'InvoiceNoRoutingHints',
}
export const LnUrlWithdrawError = (() => {
  type Generic__interface = {
    tag: LnUrlWithdrawError_Tags.Generic;
    inner: Readonly<{ err: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.Generic;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === LnUrlWithdrawError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidAmount__interface = {
    tag: LnUrlWithdrawError_Tags.InvalidAmount;
    inner: Readonly<{ err: string }>;
  };

  class InvalidAmount_ extends UniffiError implements InvalidAmount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.InvalidAmount;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'InvalidAmount');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidAmount_ {
      return new InvalidAmount_(inner);
    }

    static instanceOf(obj: any): obj is InvalidAmount_ {
      return obj.tag === LnUrlWithdrawError_Tags.InvalidAmount;
    }

    static hasInner(obj: any): obj is InvalidAmount_ {
      return InvalidAmount_.instanceOf(obj);
    }

    static getInner(obj: InvalidAmount_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidInvoice__interface = {
    tag: LnUrlWithdrawError_Tags.InvalidInvoice;
    inner: Readonly<{ err: string }>;
  };

  class InvalidInvoice_
    extends UniffiError
    implements InvalidInvoice__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.InvalidInvoice;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'InvalidInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidInvoice_ {
      return new InvalidInvoice_(inner);
    }

    static instanceOf(obj: any): obj is InvalidInvoice_ {
      return obj.tag === LnUrlWithdrawError_Tags.InvalidInvoice;
    }

    static hasInner(obj: any): obj is InvalidInvoice_ {
      return InvalidInvoice_.instanceOf(obj);
    }

    static getInner(obj: InvalidInvoice_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvalidUri__interface = {
    tag: LnUrlWithdrawError_Tags.InvalidUri;
    inner: Readonly<{ err: string }>;
  };

  class InvalidUri_ extends UniffiError implements InvalidUri__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.InvalidUri;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'InvalidUri');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvalidUri_ {
      return new InvalidUri_(inner);
    }

    static instanceOf(obj: any): obj is InvalidUri_ {
      return obj.tag === LnUrlWithdrawError_Tags.InvalidUri;
    }

    static hasInner(obj: any): obj is InvalidUri_ {
      return InvalidUri_.instanceOf(obj);
    }

    static getInner(obj: InvalidUri_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: LnUrlWithdrawError_Tags.ServiceConnectivity;
    inner: Readonly<{ err: string }>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.ServiceConnectivity;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'ServiceConnectivity');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): ServiceConnectivity_ {
      return new ServiceConnectivity_(inner);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === LnUrlWithdrawError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  type InvoiceNoRoutingHints__interface = {
    tag: LnUrlWithdrawError_Tags.InvoiceNoRoutingHints;
    inner: Readonly<{ err: string }>;
  };

  class InvoiceNoRoutingHints_
    extends UniffiError
    implements InvoiceNoRoutingHints__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawError';
    readonly tag = LnUrlWithdrawError_Tags.InvoiceNoRoutingHints;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('LnUrlWithdrawError', 'InvoiceNoRoutingHints');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): InvoiceNoRoutingHints_ {
      return new InvoiceNoRoutingHints_(inner);
    }

    static instanceOf(obj: any): obj is InvoiceNoRoutingHints_ {
      return obj.tag === LnUrlWithdrawError_Tags.InvoiceNoRoutingHints;
    }

    static hasInner(obj: any): obj is InvoiceNoRoutingHints_ {
      return InvoiceNoRoutingHints_.instanceOf(obj);
    }

    static getInner(obj: InvoiceNoRoutingHints_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is LnUrlWithdrawError {
    return obj[uniffiTypeNameSymbol] === 'LnUrlWithdrawError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
    InvalidAmount: InvalidAmount_,
    InvalidInvoice: InvalidInvoice_,
    InvalidUri: InvalidUri_,
    ServiceConnectivity: ServiceConnectivity_,
    InvoiceNoRoutingHints: InvoiceNoRoutingHints_,
  });
})();

export type LnUrlWithdrawError = InstanceType<
  (typeof LnUrlWithdrawError)[keyof Omit<
    typeof LnUrlWithdrawError,
    'instanceOf'
  >]
>;

// FfiConverter for enum LnUrlWithdrawError
const FfiConverterTypeLnUrlWithdrawError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlWithdrawError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlWithdrawError.Generic({
            err: FfiConverterString.read(from),
          });
        case 2:
          return new LnUrlWithdrawError.InvalidAmount({
            err: FfiConverterString.read(from),
          });
        case 3:
          return new LnUrlWithdrawError.InvalidInvoice({
            err: FfiConverterString.read(from),
          });
        case 4:
          return new LnUrlWithdrawError.InvalidUri({
            err: FfiConverterString.read(from),
          });
        case 5:
          return new LnUrlWithdrawError.ServiceConnectivity({
            err: FfiConverterString.read(from),
          });
        case 6:
          return new LnUrlWithdrawError.InvoiceNoRoutingHints({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlWithdrawError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlWithdrawError_Tags.InvalidAmount: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlWithdrawError_Tags.InvalidInvoice: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlWithdrawError_Tags.InvalidUri: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlWithdrawError_Tags.ServiceConnectivity: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        case LnUrlWithdrawError_Tags.InvoiceNoRoutingHints: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlWithdrawError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlWithdrawError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlWithdrawError_Tags.InvalidAmount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlWithdrawError_Tags.InvalidInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlWithdrawError_Tags.InvalidUri: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlWithdrawError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case LnUrlWithdrawError_Tags.InvoiceNoRoutingHints: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: LnUrlWithdrawResult
export enum LnUrlWithdrawResult_Tags {
  Ok = 'Ok',
  Timeout = 'Timeout',
  ErrorStatus = 'ErrorStatus',
}
export const LnUrlWithdrawResult = (() => {
  type Ok__interface = {
    tag: LnUrlWithdrawResult_Tags.Ok;
    inner: Readonly<{ data: LnUrlWithdrawSuccessData }>;
  };

  class Ok_ extends UniffiEnum implements Ok__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawResult';
    readonly tag = LnUrlWithdrawResult_Tags.Ok;
    readonly inner: Readonly<{ data: LnUrlWithdrawSuccessData }>;
    constructor(inner: { data: LnUrlWithdrawSuccessData }) {
      super('LnUrlWithdrawResult', 'Ok');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlWithdrawSuccessData }): Ok_ {
      return new Ok_(inner);
    }

    static instanceOf(obj: any): obj is Ok_ {
      return obj.tag === LnUrlWithdrawResult_Tags.Ok;
    }
  }

  type Timeout__interface = {
    tag: LnUrlWithdrawResult_Tags.Timeout;
    inner: Readonly<{ data: LnUrlWithdrawSuccessData }>;
  };

  class Timeout_ extends UniffiEnum implements Timeout__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawResult';
    readonly tag = LnUrlWithdrawResult_Tags.Timeout;
    readonly inner: Readonly<{ data: LnUrlWithdrawSuccessData }>;
    constructor(inner: { data: LnUrlWithdrawSuccessData }) {
      super('LnUrlWithdrawResult', 'Timeout');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlWithdrawSuccessData }): Timeout_ {
      return new Timeout_(inner);
    }

    static instanceOf(obj: any): obj is Timeout_ {
      return obj.tag === LnUrlWithdrawResult_Tags.Timeout;
    }
  }

  type ErrorStatus__interface = {
    tag: LnUrlWithdrawResult_Tags.ErrorStatus;
    inner: Readonly<{ data: LnUrlErrorData }>;
  };

  class ErrorStatus_ extends UniffiEnum implements ErrorStatus__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LnUrlWithdrawResult';
    readonly tag = LnUrlWithdrawResult_Tags.ErrorStatus;
    readonly inner: Readonly<{ data: LnUrlErrorData }>;
    constructor(inner: { data: LnUrlErrorData }) {
      super('LnUrlWithdrawResult', 'ErrorStatus');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: LnUrlErrorData }): ErrorStatus_ {
      return new ErrorStatus_(inner);
    }

    static instanceOf(obj: any): obj is ErrorStatus_ {
      return obj.tag === LnUrlWithdrawResult_Tags.ErrorStatus;
    }
  }

  function instanceOf(obj: any): obj is LnUrlWithdrawResult {
    return obj[uniffiTypeNameSymbol] === 'LnUrlWithdrawResult';
  }

  return Object.freeze({
    instanceOf,
    Ok: Ok_,
    Timeout: Timeout_,
    ErrorStatus: ErrorStatus_,
  });
})();

export type LnUrlWithdrawResult = InstanceType<
  (typeof LnUrlWithdrawResult)[keyof Omit<
    typeof LnUrlWithdrawResult,
    'instanceOf'
  >]
>;

// FfiConverter for enum LnUrlWithdrawResult
const FfiConverterTypeLnUrlWithdrawResult = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LnUrlWithdrawResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LnUrlWithdrawResult.Ok({
            data: FfiConverterTypeLnUrlWithdrawSuccessData.read(from),
          });
        case 2:
          return new LnUrlWithdrawResult.Timeout({
            data: FfiConverterTypeLnUrlWithdrawSuccessData.read(from),
          });
        case 3:
          return new LnUrlWithdrawResult.ErrorStatus({
            data: FfiConverterTypeLnUrlErrorData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LnUrlWithdrawResult_Tags.Ok: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlWithdrawSuccessData.write(inner.data, into);
          return;
        }
        case LnUrlWithdrawResult_Tags.Timeout: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlWithdrawSuccessData.write(inner.data, into);
          return;
        }
        case LnUrlWithdrawResult_Tags.ErrorStatus: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeLnUrlErrorData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that LnUrlWithdrawResult_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LnUrlWithdrawResult_Tags.Ok: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeLnUrlWithdrawSuccessData.allocationSize(
            inner.data
          );
          return size;
        }
        case LnUrlWithdrawResult_Tags.Timeout: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeLnUrlWithdrawSuccessData.allocationSize(
            inner.data
          );
          return size;
        }
        case LnUrlWithdrawResult_Tags.ErrorStatus: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeLnUrlErrorData.allocationSize(inner.data);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum Network {
  Bitcoin,
  Testnet,
  Signet,
  Regtest,
}

const FfiConverterTypeNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Network;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Network.Bitcoin;
        case 2:
          return Network.Testnet;
        case 3:
          return Network.Signet;
        case 4:
          return Network.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Network.Bitcoin:
          return ordinalConverter.write(1, into);
        case Network.Testnet:
          return ordinalConverter.write(2, into);
        case Network.Signet:
          return ordinalConverter.write(3, into);
        case Network.Regtest:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: NwcEvent
export enum NwcEvent_Tags {
  ConnectedHandled = 'ConnectedHandled',
  DisconnectedHandled = 'DisconnectedHandled',
  PayInvoiceHandled = 'PayInvoiceHandled',
  ListTransactionsHandled = 'ListTransactionsHandled',
  GetBalanceHandled = 'GetBalanceHandled',
}
export const NwcEvent = (() => {
  type ConnectedHandled__interface = {
    tag: NwcEvent_Tags.ConnectedHandled;
  };

  class ConnectedHandled_
    extends UniffiEnum
    implements ConnectedHandled__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NwcEvent';
    readonly tag = NwcEvent_Tags.ConnectedHandled;
    constructor() {
      super('NwcEvent', 'ConnectedHandled');
    }

    static new(): ConnectedHandled_ {
      return new ConnectedHandled_();
    }

    static instanceOf(obj: any): obj is ConnectedHandled_ {
      return obj.tag === NwcEvent_Tags.ConnectedHandled;
    }
  }

  type DisconnectedHandled__interface = {
    tag: NwcEvent_Tags.DisconnectedHandled;
  };

  class DisconnectedHandled_
    extends UniffiEnum
    implements DisconnectedHandled__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NwcEvent';
    readonly tag = NwcEvent_Tags.DisconnectedHandled;
    constructor() {
      super('NwcEvent', 'DisconnectedHandled');
    }

    static new(): DisconnectedHandled_ {
      return new DisconnectedHandled_();
    }

    static instanceOf(obj: any): obj is DisconnectedHandled_ {
      return obj.tag === NwcEvent_Tags.DisconnectedHandled;
    }
  }

  type PayInvoiceHandled__interface = {
    tag: NwcEvent_Tags.PayInvoiceHandled;
    inner: Readonly<{
      success: boolean;
      preimage: string | undefined;
      feesSat: /*u64*/ bigint | undefined;
      error: string | undefined;
    }>;
  };

  class PayInvoiceHandled_
    extends UniffiEnum
    implements PayInvoiceHandled__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NwcEvent';
    readonly tag = NwcEvent_Tags.PayInvoiceHandled;
    readonly inner: Readonly<{
      success: boolean;
      preimage: string | undefined;
      feesSat: /*u64*/ bigint | undefined;
      error: string | undefined;
    }>;
    constructor(inner: {
      success: boolean;
      preimage: string | undefined;
      feesSat: /*u64*/ bigint | undefined;
      error: string | undefined;
    }) {
      super('NwcEvent', 'PayInvoiceHandled');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      success: boolean;
      preimage: string | undefined;
      feesSat: /*u64*/ bigint | undefined;
      error: string | undefined;
    }): PayInvoiceHandled_ {
      return new PayInvoiceHandled_(inner);
    }

    static instanceOf(obj: any): obj is PayInvoiceHandled_ {
      return obj.tag === NwcEvent_Tags.PayInvoiceHandled;
    }
  }

  type ListTransactionsHandled__interface = {
    tag: NwcEvent_Tags.ListTransactionsHandled;
  };

  class ListTransactionsHandled_
    extends UniffiEnum
    implements ListTransactionsHandled__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NwcEvent';
    readonly tag = NwcEvent_Tags.ListTransactionsHandled;
    constructor() {
      super('NwcEvent', 'ListTransactionsHandled');
    }

    static new(): ListTransactionsHandled_ {
      return new ListTransactionsHandled_();
    }

    static instanceOf(obj: any): obj is ListTransactionsHandled_ {
      return obj.tag === NwcEvent_Tags.ListTransactionsHandled;
    }
  }

  type GetBalanceHandled__interface = {
    tag: NwcEvent_Tags.GetBalanceHandled;
  };

  class GetBalanceHandled_
    extends UniffiEnum
    implements GetBalanceHandled__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NwcEvent';
    readonly tag = NwcEvent_Tags.GetBalanceHandled;
    constructor() {
      super('NwcEvent', 'GetBalanceHandled');
    }

    static new(): GetBalanceHandled_ {
      return new GetBalanceHandled_();
    }

    static instanceOf(obj: any): obj is GetBalanceHandled_ {
      return obj.tag === NwcEvent_Tags.GetBalanceHandled;
    }
  }

  function instanceOf(obj: any): obj is NwcEvent {
    return obj[uniffiTypeNameSymbol] === 'NwcEvent';
  }

  return Object.freeze({
    instanceOf,
    ConnectedHandled: ConnectedHandled_,
    DisconnectedHandled: DisconnectedHandled_,
    PayInvoiceHandled: PayInvoiceHandled_,
    ListTransactionsHandled: ListTransactionsHandled_,
    GetBalanceHandled: GetBalanceHandled_,
  });
})();

export type NwcEvent = InstanceType<
  (typeof NwcEvent)[keyof Omit<typeof NwcEvent, 'instanceOf'>]
>;

// FfiConverter for enum NwcEvent
const FfiConverterTypeNwcEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NwcEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NwcEvent.ConnectedHandled();
        case 2:
          return new NwcEvent.DisconnectedHandled();
        case 3:
          return new NwcEvent.PayInvoiceHandled({
            success: FfiConverterBool.read(from),
            preimage: FfiConverterOptionalString.read(from),
            feesSat: FfiConverterOptionalUInt64.read(from),
            error: FfiConverterOptionalString.read(from),
          });
        case 4:
          return new NwcEvent.ListTransactionsHandled();
        case 5:
          return new NwcEvent.GetBalanceHandled();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NwcEvent_Tags.ConnectedHandled: {
          ordinalConverter.write(1, into);
          return;
        }
        case NwcEvent_Tags.DisconnectedHandled: {
          ordinalConverter.write(2, into);
          return;
        }
        case NwcEvent_Tags.PayInvoiceHandled: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.success, into);
          FfiConverterOptionalString.write(inner.preimage, into);
          FfiConverterOptionalUInt64.write(inner.feesSat, into);
          FfiConverterOptionalString.write(inner.error, into);
          return;
        }
        case NwcEvent_Tags.ListTransactionsHandled: {
          ordinalConverter.write(4, into);
          return;
        }
        case NwcEvent_Tags.GetBalanceHandled: {
          ordinalConverter.write(5, into);
          return;
        }
        default:
          // Throwing from here means that NwcEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NwcEvent_Tags.ConnectedHandled: {
          return ordinalConverter.allocationSize(1);
        }
        case NwcEvent_Tags.DisconnectedHandled: {
          return ordinalConverter.allocationSize(2);
        }
        case NwcEvent_Tags.PayInvoiceHandled: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterBool.allocationSize(inner.success);
          size += FfiConverterOptionalString.allocationSize(inner.preimage);
          size += FfiConverterOptionalUInt64.allocationSize(inner.feesSat);
          size += FfiConverterOptionalString.allocationSize(inner.error);
          return size;
        }
        case NwcEvent_Tags.ListTransactionsHandled: {
          return ordinalConverter.allocationSize(4);
        }
        case NwcEvent_Tags.GetBalanceHandled: {
          return ordinalConverter.allocationSize(5);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: PayAmount
export enum PayAmount_Tags {
  Bitcoin = 'Bitcoin',
  Asset = 'Asset',
  Drain = 'Drain',
}
export const PayAmount = (() => {
  type Bitcoin__interface = {
    tag: PayAmount_Tags.Bitcoin;
    inner: Readonly<{ receiverAmountSat: /*u64*/ bigint }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PayAmount';
    readonly tag = PayAmount_Tags.Bitcoin;
    readonly inner: Readonly<{ receiverAmountSat: /*u64*/ bigint }>;
    constructor(inner: { receiverAmountSat: /*u64*/ bigint }) {
      super('PayAmount', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { receiverAmountSat: /*u64*/ bigint }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === PayAmount_Tags.Bitcoin;
    }
  }

  type Asset__interface = {
    tag: PayAmount_Tags.Asset;
    inner: Readonly<{
      toAsset: string;
      receiverAmount: /*f64*/ number;
      estimateAssetFees: boolean | undefined;
      fromAsset: string | undefined;
    }>;
  };

  class Asset_ extends UniffiEnum implements Asset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PayAmount';
    readonly tag = PayAmount_Tags.Asset;
    readonly inner: Readonly<{
      toAsset: string;
      receiverAmount: /*f64*/ number;
      estimateAssetFees: boolean | undefined;
      fromAsset: string | undefined;
    }>;
    constructor(inner: {
      toAsset: string;
      receiverAmount: /*f64*/ number;
      estimateAssetFees: boolean | undefined;
      fromAsset: string | undefined;
    }) {
      super('PayAmount', 'Asset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      toAsset: string;
      receiverAmount: /*f64*/ number;
      estimateAssetFees: boolean | undefined;
      fromAsset: string | undefined;
    }): Asset_ {
      return new Asset_(inner);
    }

    static instanceOf(obj: any): obj is Asset_ {
      return obj.tag === PayAmount_Tags.Asset;
    }
  }

  type Drain__interface = {
    tag: PayAmount_Tags.Drain;
  };

  class Drain_ extends UniffiEnum implements Drain__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PayAmount';
    readonly tag = PayAmount_Tags.Drain;
    constructor() {
      super('PayAmount', 'Drain');
    }

    static new(): Drain_ {
      return new Drain_();
    }

    static instanceOf(obj: any): obj is Drain_ {
      return obj.tag === PayAmount_Tags.Drain;
    }
  }

  function instanceOf(obj: any): obj is PayAmount {
    return obj[uniffiTypeNameSymbol] === 'PayAmount';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Asset: Asset_,
    Drain: Drain_,
  });
})();

export type PayAmount = InstanceType<
  (typeof PayAmount)[keyof Omit<typeof PayAmount, 'instanceOf'>]
>;

// FfiConverter for enum PayAmount
const FfiConverterTypePayAmount = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PayAmount;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PayAmount.Bitcoin({
            receiverAmountSat: FfiConverterUInt64.read(from),
          });
        case 2:
          return new PayAmount.Asset({
            toAsset: FfiConverterString.read(from),
            receiverAmount: FfiConverterFloat64.read(from),
            estimateAssetFees: FfiConverterOptionalBool.read(from),
            fromAsset: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new PayAmount.Drain();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PayAmount_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.receiverAmountSat, into);
          return;
        }
        case PayAmount_Tags.Asset: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.toAsset, into);
          FfiConverterFloat64.write(inner.receiverAmount, into);
          FfiConverterOptionalBool.write(inner.estimateAssetFees, into);
          FfiConverterOptionalString.write(inner.fromAsset, into);
          return;
        }
        case PayAmount_Tags.Drain: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that PayAmount_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PayAmount_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.receiverAmountSat);
          return size;
        }
        case PayAmount_Tags.Asset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.toAsset);
          size += FfiConverterFloat64.allocationSize(inner.receiverAmount);
          size += FfiConverterOptionalBool.allocationSize(
            inner.estimateAssetFees
          );
          size += FfiConverterOptionalString.allocationSize(inner.fromAsset);
          return size;
        }
        case PayAmount_Tags.Drain: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: PaymentDetails
export enum PaymentDetails_Tags {
  Lightning = 'Lightning',
  Liquid = 'Liquid',
  Bitcoin = 'Bitcoin',
}
export const PaymentDetails = (() => {
  type Lightning__interface = {
    tag: PaymentDetails_Tags.Lightning;
    inner: Readonly<{
      swapId: string;
      description: string;
      liquidExpirationBlockheight: /*u32*/ number;
      preimage: string | undefined;
      invoice: string | undefined;
      bolt12Offer: string | undefined;
      paymentHash: string | undefined;
      destinationPubkey: string | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{
      swapId: string;
      description: string;
      liquidExpirationBlockheight: /*u32*/ number;
      preimage: string | undefined;
      invoice: string | undefined;
      bolt12Offer: string | undefined;
      paymentHash: string | undefined;
      destinationPubkey: string | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }>;
    constructor(inner: {
      swapId: string;
      description: string;
      liquidExpirationBlockheight: /*u32*/ number;
      preimage: string | undefined;
      invoice: string | undefined;
      bolt12Offer: string | undefined;
      paymentHash: string | undefined;
      destinationPubkey: string | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }) {
      super('PaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      swapId: string;
      description: string;
      liquidExpirationBlockheight: /*u32*/ number;
      preimage: string | undefined;
      invoice: string | undefined;
      bolt12Offer: string | undefined;
      paymentHash: string | undefined;
      destinationPubkey: string | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === PaymentDetails_Tags.Lightning;
    }
  }

  type Liquid__interface = {
    tag: PaymentDetails_Tags.Liquid;
    inner: Readonly<{
      assetId: string;
      destination: string;
      description: string;
      assetInfo: AssetInfo | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
    }>;
  };

  class Liquid_ extends UniffiEnum implements Liquid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Liquid;
    readonly inner: Readonly<{
      assetId: string;
      destination: string;
      description: string;
      assetInfo: AssetInfo | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
    }>;
    constructor(inner: {
      assetId: string;
      destination: string;
      description: string;
      assetInfo: AssetInfo | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
    }) {
      super('PaymentDetails', 'Liquid');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      assetId: string;
      destination: string;
      description: string;
      assetInfo: AssetInfo | undefined;
      lnurlInfo: LnUrlInfo | undefined;
      bip353Address: string | undefined;
      payerNote: string | undefined;
    }): Liquid_ {
      return new Liquid_(inner);
    }

    static instanceOf(obj: any): obj is Liquid_ {
      return obj.tag === PaymentDetails_Tags.Liquid;
    }
  }

  type Bitcoin__interface = {
    tag: PaymentDetails_Tags.Bitcoin;
    inner: Readonly<{
      swapId: string;
      bitcoinAddress: string;
      description: string;
      autoAcceptedFees: boolean;
      bitcoinExpirationBlockheight: /*u32*/ number | undefined;
      liquidExpirationBlockheight: /*u32*/ number | undefined;
      lockupTxId: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Bitcoin;
    readonly inner: Readonly<{
      swapId: string;
      bitcoinAddress: string;
      description: string;
      autoAcceptedFees: boolean;
      bitcoinExpirationBlockheight: /*u32*/ number | undefined;
      liquidExpirationBlockheight: /*u32*/ number | undefined;
      lockupTxId: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }>;
    constructor(inner: {
      swapId: string;
      bitcoinAddress: string;
      description: string;
      autoAcceptedFees: boolean;
      bitcoinExpirationBlockheight: /*u32*/ number | undefined;
      liquidExpirationBlockheight: /*u32*/ number | undefined;
      lockupTxId: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }) {
      super('PaymentDetails', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      swapId: string;
      bitcoinAddress: string;
      description: string;
      autoAcceptedFees: boolean;
      bitcoinExpirationBlockheight: /*u32*/ number | undefined;
      liquidExpirationBlockheight: /*u32*/ number | undefined;
      lockupTxId: string | undefined;
      claimTxId: string | undefined;
      refundTxId: string | undefined;
      refundTxAmountSat: /*u64*/ bigint | undefined;
    }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === PaymentDetails_Tags.Bitcoin;
    }
  }

  function instanceOf(obj: any): obj is PaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'PaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Lightning: Lightning_,
    Liquid: Liquid_,
    Bitcoin: Bitcoin_,
  });
})();

export type PaymentDetails = InstanceType<
  (typeof PaymentDetails)[keyof Omit<typeof PaymentDetails, 'instanceOf'>]
>;

// FfiConverter for enum PaymentDetails
const FfiConverterTypePaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentDetails.Lightning({
            swapId: FfiConverterString.read(from),
            description: FfiConverterString.read(from),
            liquidExpirationBlockheight: FfiConverterUInt32.read(from),
            preimage: FfiConverterOptionalString.read(from),
            invoice: FfiConverterOptionalString.read(from),
            bolt12Offer: FfiConverterOptionalString.read(from),
            paymentHash: FfiConverterOptionalString.read(from),
            destinationPubkey: FfiConverterOptionalString.read(from),
            lnurlInfo: FfiConverterOptionalTypeLnUrlInfo.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
            payerNote: FfiConverterOptionalString.read(from),
            claimTxId: FfiConverterOptionalString.read(from),
            refundTxId: FfiConverterOptionalString.read(from),
            refundTxAmountSat: FfiConverterOptionalUInt64.read(from),
          });
        case 2:
          return new PaymentDetails.Liquid({
            assetId: FfiConverterString.read(from),
            destination: FfiConverterString.read(from),
            description: FfiConverterString.read(from),
            assetInfo: FfiConverterOptionalTypeAssetInfo.read(from),
            lnurlInfo: FfiConverterOptionalTypeLnUrlInfo.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
            payerNote: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new PaymentDetails.Bitcoin({
            swapId: FfiConverterString.read(from),
            bitcoinAddress: FfiConverterString.read(from),
            description: FfiConverterString.read(from),
            autoAcceptedFees: FfiConverterBool.read(from),
            bitcoinExpirationBlockheight: FfiConverterOptionalUInt32.read(from),
            liquidExpirationBlockheight: FfiConverterOptionalUInt32.read(from),
            lockupTxId: FfiConverterOptionalString.read(from),
            claimTxId: FfiConverterOptionalString.read(from),
            refundTxId: FfiConverterOptionalString.read(from),
            refundTxAmountSat: FfiConverterOptionalUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentDetails_Tags.Lightning: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.swapId, into);
          FfiConverterString.write(inner.description, into);
          FfiConverterUInt32.write(inner.liquidExpirationBlockheight, into);
          FfiConverterOptionalString.write(inner.preimage, into);
          FfiConverterOptionalString.write(inner.invoice, into);
          FfiConverterOptionalString.write(inner.bolt12Offer, into);
          FfiConverterOptionalString.write(inner.paymentHash, into);
          FfiConverterOptionalString.write(inner.destinationPubkey, into);
          FfiConverterOptionalTypeLnUrlInfo.write(inner.lnurlInfo, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          FfiConverterOptionalString.write(inner.payerNote, into);
          FfiConverterOptionalString.write(inner.claimTxId, into);
          FfiConverterOptionalString.write(inner.refundTxId, into);
          FfiConverterOptionalUInt64.write(inner.refundTxAmountSat, into);
          return;
        }
        case PaymentDetails_Tags.Liquid: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.assetId, into);
          FfiConverterString.write(inner.destination, into);
          FfiConverterString.write(inner.description, into);
          FfiConverterOptionalTypeAssetInfo.write(inner.assetInfo, into);
          FfiConverterOptionalTypeLnUrlInfo.write(inner.lnurlInfo, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          FfiConverterOptionalString.write(inner.payerNote, into);
          return;
        }
        case PaymentDetails_Tags.Bitcoin: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.swapId, into);
          FfiConverterString.write(inner.bitcoinAddress, into);
          FfiConverterString.write(inner.description, into);
          FfiConverterBool.write(inner.autoAcceptedFees, into);
          FfiConverterOptionalUInt32.write(
            inner.bitcoinExpirationBlockheight,
            into
          );
          FfiConverterOptionalUInt32.write(
            inner.liquidExpirationBlockheight,
            into
          );
          FfiConverterOptionalString.write(inner.lockupTxId, into);
          FfiConverterOptionalString.write(inner.claimTxId, into);
          FfiConverterOptionalString.write(inner.refundTxId, into);
          FfiConverterOptionalUInt64.write(inner.refundTxAmountSat, into);
          return;
        }
        default:
          // Throwing from here means that PaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.swapId);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterUInt32.allocationSize(
            inner.liquidExpirationBlockheight
          );
          size += FfiConverterOptionalString.allocationSize(inner.preimage);
          size += FfiConverterOptionalString.allocationSize(inner.invoice);
          size += FfiConverterOptionalString.allocationSize(inner.bolt12Offer);
          size += FfiConverterOptionalString.allocationSize(inner.paymentHash);
          size += FfiConverterOptionalString.allocationSize(
            inner.destinationPubkey
          );
          size += FfiConverterOptionalTypeLnUrlInfo.allocationSize(
            inner.lnurlInfo
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          size += FfiConverterOptionalString.allocationSize(inner.payerNote);
          size += FfiConverterOptionalString.allocationSize(inner.claimTxId);
          size += FfiConverterOptionalString.allocationSize(inner.refundTxId);
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.refundTxAmountSat
          );
          return size;
        }
        case PaymentDetails_Tags.Liquid: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.assetId);
          size += FfiConverterString.allocationSize(inner.destination);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterOptionalTypeAssetInfo.allocationSize(
            inner.assetInfo
          );
          size += FfiConverterOptionalTypeLnUrlInfo.allocationSize(
            inner.lnurlInfo
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          size += FfiConverterOptionalString.allocationSize(inner.payerNote);
          return size;
        }
        case PaymentDetails_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.swapId);
          size += FfiConverterString.allocationSize(inner.bitcoinAddress);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterBool.allocationSize(inner.autoAcceptedFees);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.bitcoinExpirationBlockheight
          );
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.liquidExpirationBlockheight
          );
          size += FfiConverterOptionalString.allocationSize(inner.lockupTxId);
          size += FfiConverterOptionalString.allocationSize(inner.claimTxId);
          size += FfiConverterOptionalString.allocationSize(inner.refundTxId);
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.refundTxAmountSat
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: PaymentError
export enum PaymentError_Tags {
  AlreadyClaimed = 'AlreadyClaimed',
  AlreadyPaid = 'AlreadyPaid',
  PaymentInProgress = 'PaymentInProgress',
  AmountOutOfRange = 'AmountOutOfRange',
  AmountMissing = 'AmountMissing',
  AssetError = 'AssetError',
  Generic = 'Generic',
  InvalidOrExpiredFees = 'InvalidOrExpiredFees',
  InsufficientFunds = 'InsufficientFunds',
  InvalidDescription = 'InvalidDescription',
  InvalidInvoice = 'InvalidInvoice',
  InvalidNetwork = 'InvalidNetwork',
  InvalidPreimage = 'InvalidPreimage',
  PairsNotFound = 'PairsNotFound',
  PaymentTimeout = 'PaymentTimeout',
  PersistError = 'PersistError',
  ReceiveError = 'ReceiveError',
  Refunded = 'Refunded',
  SelfTransferNotSupported = 'SelfTransferNotSupported',
  SendError = 'SendError',
  SignerError = 'SignerError',
}
export const PaymentError = (() => {
  class AlreadyClaimed extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = PaymentError_Tags.AlreadyClaimed;

    constructor(message: string) {
      super('PaymentError', 'AlreadyClaimed', message);
    }

    static instanceOf(e: any): e is AlreadyClaimed {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class AlreadyPaid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = PaymentError_Tags.AlreadyPaid;

    constructor(message: string) {
      super('PaymentError', 'AlreadyPaid', message);
    }

    static instanceOf(e: any): e is AlreadyPaid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class PaymentInProgress extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = PaymentError_Tags.PaymentInProgress;

    constructor(message: string) {
      super('PaymentError', 'PaymentInProgress', message);
    }

    static instanceOf(e: any): e is PaymentInProgress {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class AmountOutOfRange extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = PaymentError_Tags.AmountOutOfRange;

    constructor(message: string) {
      super('PaymentError', 'AmountOutOfRange', message);
    }

    static instanceOf(e: any): e is AmountOutOfRange {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class AmountMissing extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = PaymentError_Tags.AmountMissing;

    constructor(message: string) {
      super('PaymentError', 'AmountMissing', message);
    }

    static instanceOf(e: any): e is AmountMissing {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class AssetError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = PaymentError_Tags.AssetError;

    constructor(message: string) {
      super('PaymentError', 'AssetError', message);
    }

    static instanceOf(e: any): e is AssetError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = PaymentError_Tags.Generic;

    constructor(message: string) {
      super('PaymentError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class InvalidOrExpiredFees extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = PaymentError_Tags.InvalidOrExpiredFees;

    constructor(message: string) {
      super('PaymentError', 'InvalidOrExpiredFees', message);
    }

    static instanceOf(e: any): e is InvalidOrExpiredFees {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class InsufficientFunds extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = PaymentError_Tags.InsufficientFunds;

    constructor(message: string) {
      super('PaymentError', 'InsufficientFunds', message);
    }

    static instanceOf(e: any): e is InsufficientFunds {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class InvalidDescription extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = PaymentError_Tags.InvalidDescription;

    constructor(message: string) {
      super('PaymentError', 'InvalidDescription', message);
    }

    static instanceOf(e: any): e is InvalidDescription {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }
  class InvalidInvoice extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 11;

    public readonly tag = PaymentError_Tags.InvalidInvoice;

    constructor(message: string) {
      super('PaymentError', 'InvalidInvoice', message);
    }

    static instanceOf(e: any): e is InvalidInvoice {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11;
    }
  }
  class InvalidNetwork extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 12;

    public readonly tag = PaymentError_Tags.InvalidNetwork;

    constructor(message: string) {
      super('PaymentError', 'InvalidNetwork', message);
    }

    static instanceOf(e: any): e is InvalidNetwork {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 12;
    }
  }
  class InvalidPreimage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 13;

    public readonly tag = PaymentError_Tags.InvalidPreimage;

    constructor(message: string) {
      super('PaymentError', 'InvalidPreimage', message);
    }

    static instanceOf(e: any): e is InvalidPreimage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 13;
    }
  }
  class PairsNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 14;

    public readonly tag = PaymentError_Tags.PairsNotFound;

    constructor(message: string) {
      super('PaymentError', 'PairsNotFound', message);
    }

    static instanceOf(e: any): e is PairsNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 14;
    }
  }
  class PaymentTimeout extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 15;

    public readonly tag = PaymentError_Tags.PaymentTimeout;

    constructor(message: string) {
      super('PaymentError', 'PaymentTimeout', message);
    }

    static instanceOf(e: any): e is PaymentTimeout {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 15;
    }
  }
  class PersistError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 16;

    public readonly tag = PaymentError_Tags.PersistError;

    constructor(message: string) {
      super('PaymentError', 'PersistError', message);
    }

    static instanceOf(e: any): e is PersistError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 16;
    }
  }
  class ReceiveError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 17;

    public readonly tag = PaymentError_Tags.ReceiveError;

    constructor(message: string) {
      super('PaymentError', 'ReceiveError', message);
    }

    static instanceOf(e: any): e is ReceiveError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 17;
    }
  }
  class Refunded extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 18;

    public readonly tag = PaymentError_Tags.Refunded;

    constructor(message: string) {
      super('PaymentError', 'Refunded', message);
    }

    static instanceOf(e: any): e is Refunded {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 18;
    }
  }
  class SelfTransferNotSupported extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 19;

    public readonly tag = PaymentError_Tags.SelfTransferNotSupported;

    constructor(message: string) {
      super('PaymentError', 'SelfTransferNotSupported', message);
    }

    static instanceOf(e: any): e is SelfTransferNotSupported {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 19;
    }
  }
  class SendError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 20;

    public readonly tag = PaymentError_Tags.SendError;

    constructor(message: string) {
      super('PaymentError', 'SendError', message);
    }

    static instanceOf(e: any): e is SendError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 20;
    }
  }
  class SignerError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'PaymentError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 21;

    public readonly tag = PaymentError_Tags.SignerError;

    constructor(message: string) {
      super('PaymentError', 'SignerError', message);
    }

    static instanceOf(e: any): e is SignerError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 21;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is PaymentError {
    return (e as any)[uniffiTypeNameSymbol] === 'PaymentError';
  }
  return {
    AlreadyClaimed,
    AlreadyPaid,
    PaymentInProgress,
    AmountOutOfRange,
    AmountMissing,
    AssetError,
    Generic,
    InvalidOrExpiredFees,
    InsufficientFunds,
    InvalidDescription,
    InvalidInvoice,
    InvalidNetwork,
    InvalidPreimage,
    PairsNotFound,
    PaymentTimeout,
    PersistError,
    ReceiveError,
    Refunded,
    SelfTransferNotSupported,
    SendError,
    SignerError,
    instanceOf,
  };
})();

// Union type for PaymentError error type.

export type PaymentError = InstanceType<
  (typeof PaymentError)[keyof Omit<typeof PaymentError, 'instanceOf'>]
>;

const FfiConverterTypePaymentError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = PaymentError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new PaymentError.AlreadyClaimed(FfiConverterString.read(from));

        case 2:
          return new PaymentError.AlreadyPaid(FfiConverterString.read(from));

        case 3:
          return new PaymentError.PaymentInProgress(
            FfiConverterString.read(from)
          );

        case 4:
          return new PaymentError.AmountOutOfRange(
            FfiConverterString.read(from)
          );

        case 5:
          return new PaymentError.AmountMissing(FfiConverterString.read(from));

        case 6:
          return new PaymentError.AssetError(FfiConverterString.read(from));

        case 7:
          return new PaymentError.Generic(FfiConverterString.read(from));

        case 8:
          return new PaymentError.InvalidOrExpiredFees(
            FfiConverterString.read(from)
          );

        case 9:
          return new PaymentError.InsufficientFunds(
            FfiConverterString.read(from)
          );

        case 10:
          return new PaymentError.InvalidDescription(
            FfiConverterString.read(from)
          );

        case 11:
          return new PaymentError.InvalidInvoice(FfiConverterString.read(from));

        case 12:
          return new PaymentError.InvalidNetwork(FfiConverterString.read(from));

        case 13:
          return new PaymentError.InvalidPreimage(
            FfiConverterString.read(from)
          );

        case 14:
          return new PaymentError.PairsNotFound(FfiConverterString.read(from));

        case 15:
          return new PaymentError.PaymentTimeout(FfiConverterString.read(from));

        case 16:
          return new PaymentError.PersistError(FfiConverterString.read(from));

        case 17:
          return new PaymentError.ReceiveError(FfiConverterString.read(from));

        case 18:
          return new PaymentError.Refunded(FfiConverterString.read(from));

        case 19:
          return new PaymentError.SelfTransferNotSupported(
            FfiConverterString.read(from)
          );

        case 20:
          return new PaymentError.SendError(FfiConverterString.read(from));

        case 21:
          return new PaymentError.SignerError(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum PaymentMethod {
  Lightning,
  Bolt11Invoice,
  Bolt12Offer,
  BitcoinAddress,
  LiquidAddress,
}

const FfiConverterTypePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentMethod.Lightning;
        case 2:
          return PaymentMethod.Bolt11Invoice;
        case 3:
          return PaymentMethod.Bolt12Offer;
        case 4:
          return PaymentMethod.BitcoinAddress;
        case 5:
          return PaymentMethod.LiquidAddress;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentMethod.Lightning:
          return ordinalConverter.write(1, into);
        case PaymentMethod.Bolt11Invoice:
          return ordinalConverter.write(2, into);
        case PaymentMethod.Bolt12Offer:
          return ordinalConverter.write(3, into);
        case PaymentMethod.BitcoinAddress:
          return ordinalConverter.write(4, into);
        case PaymentMethod.LiquidAddress:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum PaymentState {
  Created,
  Pending,
  Complete,
  Failed,
  TimedOut,
  Refundable,
  RefundPending,
  WaitingFeeAcceptance,
}

const FfiConverterTypePaymentState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentState.Created;
        case 2:
          return PaymentState.Pending;
        case 3:
          return PaymentState.Complete;
        case 4:
          return PaymentState.Failed;
        case 5:
          return PaymentState.TimedOut;
        case 6:
          return PaymentState.Refundable;
        case 7:
          return PaymentState.RefundPending;
        case 8:
          return PaymentState.WaitingFeeAcceptance;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentState.Created:
          return ordinalConverter.write(1, into);
        case PaymentState.Pending:
          return ordinalConverter.write(2, into);
        case PaymentState.Complete:
          return ordinalConverter.write(3, into);
        case PaymentState.Failed:
          return ordinalConverter.write(4, into);
        case PaymentState.TimedOut:
          return ordinalConverter.write(5, into);
        case PaymentState.Refundable:
          return ordinalConverter.write(6, into);
        case PaymentState.RefundPending:
          return ordinalConverter.write(7, into);
        case PaymentState.WaitingFeeAcceptance:
          return ordinalConverter.write(8, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum PaymentType {
  Receive,
  Send,
}

const FfiConverterTypePaymentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentType.Receive;
        case 2:
          return PaymentType.Send;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentType.Receive:
          return ordinalConverter.write(1, into);
        case PaymentType.Send:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: PluginStorageError

// Enum: PluginStorageError
export enum PluginStorageError_Tags {
  Generic = 'Generic',
}
export const PluginStorageError = (() => {
  type Generic__interface = {
    tag: PluginStorageError_Tags.Generic;
    inner: Readonly<{ err: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PluginStorageError';
    readonly tag = PluginStorageError_Tags.Generic;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('PluginStorageError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === PluginStorageError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PluginStorageError {
    return obj[uniffiTypeNameSymbol] === 'PluginStorageError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
  });
})();

export type PluginStorageError = InstanceType<
  (typeof PluginStorageError)[keyof Omit<
    typeof PluginStorageError,
    'instanceOf'
  >]
>;

// FfiConverter for enum PluginStorageError
const FfiConverterTypePluginStorageError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PluginStorageError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PluginStorageError.Generic({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PluginStorageError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that PluginStorageError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PluginStorageError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ReceiveAmount
export enum ReceiveAmount_Tags {
  Bitcoin = 'Bitcoin',
  Asset = 'Asset',
}
export const ReceiveAmount = (() => {
  type Bitcoin__interface = {
    tag: ReceiveAmount_Tags.Bitcoin;
    inner: Readonly<{ payerAmountSat: /*u64*/ bigint }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceiveAmount';
    readonly tag = ReceiveAmount_Tags.Bitcoin;
    readonly inner: Readonly<{ payerAmountSat: /*u64*/ bigint }>;
    constructor(inner: { payerAmountSat: /*u64*/ bigint }) {
      super('ReceiveAmount', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payerAmountSat: /*u64*/ bigint }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === ReceiveAmount_Tags.Bitcoin;
    }
  }

  type Asset__interface = {
    tag: ReceiveAmount_Tags.Asset;
    inner: Readonly<{
      assetId: string;
      payerAmount: /*f64*/ number | undefined;
    }>;
  };

  class Asset_ extends UniffiEnum implements Asset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceiveAmount';
    readonly tag = ReceiveAmount_Tags.Asset;
    readonly inner: Readonly<{
      assetId: string;
      payerAmount: /*f64*/ number | undefined;
    }>;
    constructor(inner: {
      assetId: string;
      payerAmount: /*f64*/ number | undefined;
    }) {
      super('ReceiveAmount', 'Asset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      assetId: string;
      payerAmount: /*f64*/ number | undefined;
    }): Asset_ {
      return new Asset_(inner);
    }

    static instanceOf(obj: any): obj is Asset_ {
      return obj.tag === ReceiveAmount_Tags.Asset;
    }
  }

  function instanceOf(obj: any): obj is ReceiveAmount {
    return obj[uniffiTypeNameSymbol] === 'ReceiveAmount';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Asset: Asset_,
  });
})();

export type ReceiveAmount = InstanceType<
  (typeof ReceiveAmount)[keyof Omit<typeof ReceiveAmount, 'instanceOf'>]
>;

// FfiConverter for enum ReceiveAmount
const FfiConverterTypeReceiveAmount = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceiveAmount;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ReceiveAmount.Bitcoin({
            payerAmountSat: FfiConverterUInt64.read(from),
          });
        case 2:
          return new ReceiveAmount.Asset({
            assetId: FfiConverterString.read(from),
            payerAmount: FfiConverterOptionalFloat64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ReceiveAmount_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.payerAmountSat, into);
          return;
        }
        case ReceiveAmount_Tags.Asset: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.assetId, into);
          FfiConverterOptionalFloat64.write(inner.payerAmount, into);
          return;
        }
        default:
          // Throwing from here means that ReceiveAmount_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ReceiveAmount_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.payerAmountSat);
          return size;
        }
        case ReceiveAmount_Tags.Asset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.assetId);
          size += FfiConverterOptionalFloat64.allocationSize(inner.payerAmount);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: SdkError
export enum SdkError_Tags {
  AlreadyStarted = 'AlreadyStarted',
  Generic = 'Generic',
  NotStarted = 'NotStarted',
  ServiceConnectivity = 'ServiceConnectivity',
}
/**
 * /////////////////////////////
 */
export const SdkError = (() => {
  class AlreadyStarted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SdkError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = SdkError_Tags.AlreadyStarted;

    constructor(message: string) {
      super('SdkError', 'AlreadyStarted', message);
    }

    static instanceOf(e: any): e is AlreadyStarted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SdkError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = SdkError_Tags.Generic;

    constructor(message: string) {
      super('SdkError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class NotStarted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SdkError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = SdkError_Tags.NotStarted;

    constructor(message: string) {
      super('SdkError', 'NotStarted', message);
    }

    static instanceOf(e: any): e is NotStarted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class ServiceConnectivity extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SdkError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = SdkError_Tags.ServiceConnectivity;

    constructor(message: string) {
      super('SdkError', 'ServiceConnectivity', message);
    }

    static instanceOf(e: any): e is ServiceConnectivity {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is SdkError {
    return (e as any)[uniffiTypeNameSymbol] === 'SdkError';
  }
  return {
    AlreadyStarted,
    Generic,
    NotStarted,
    ServiceConnectivity,
    instanceOf,
  };
})();

// Union type for SdkError error type.

/**
 * /////////////////////////////
 */

export type SdkError = InstanceType<
  (typeof SdkError)[keyof Omit<typeof SdkError, 'instanceOf'>]
>;

const FfiConverterTypeSdkError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = SdkError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SdkError.AlreadyStarted(FfiConverterString.read(from));

        case 2:
          return new SdkError.Generic(FfiConverterString.read(from));

        case 3:
          return new SdkError.NotStarted(FfiConverterString.read(from));

        case 4:
          return new SdkError.ServiceConnectivity(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: SdkEvent
export enum SdkEvent_Tags {
  PaymentFailed = 'PaymentFailed',
  PaymentPending = 'PaymentPending',
  PaymentRefundable = 'PaymentRefundable',
  PaymentRefunded = 'PaymentRefunded',
  PaymentRefundPending = 'PaymentRefundPending',
  PaymentSucceeded = 'PaymentSucceeded',
  PaymentWaitingConfirmation = 'PaymentWaitingConfirmation',
  PaymentWaitingFeeAcceptance = 'PaymentWaitingFeeAcceptance',
  Synced = 'Synced',
  DataSynced = 'DataSynced',
  Nwc = 'NWC',
}
export const SdkEvent = (() => {
  type PaymentFailed__interface = {
    tag: SdkEvent_Tags.PaymentFailed;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentFailed_ extends UniffiEnum implements PaymentFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentFailed;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentFailed_ {
      return new PaymentFailed_(inner);
    }

    static instanceOf(obj: any): obj is PaymentFailed_ {
      return obj.tag === SdkEvent_Tags.PaymentFailed;
    }
  }

  type PaymentPending__interface = {
    tag: SdkEvent_Tags.PaymentPending;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentPending_
    extends UniffiEnum
    implements PaymentPending__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentPending;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentPending');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentPending_ {
      return new PaymentPending_(inner);
    }

    static instanceOf(obj: any): obj is PaymentPending_ {
      return obj.tag === SdkEvent_Tags.PaymentPending;
    }
  }

  type PaymentRefundable__interface = {
    tag: SdkEvent_Tags.PaymentRefundable;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentRefundable_
    extends UniffiEnum
    implements PaymentRefundable__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentRefundable;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentRefundable');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentRefundable_ {
      return new PaymentRefundable_(inner);
    }

    static instanceOf(obj: any): obj is PaymentRefundable_ {
      return obj.tag === SdkEvent_Tags.PaymentRefundable;
    }
  }

  type PaymentRefunded__interface = {
    tag: SdkEvent_Tags.PaymentRefunded;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentRefunded_
    extends UniffiEnum
    implements PaymentRefunded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentRefunded;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentRefunded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentRefunded_ {
      return new PaymentRefunded_(inner);
    }

    static instanceOf(obj: any): obj is PaymentRefunded_ {
      return obj.tag === SdkEvent_Tags.PaymentRefunded;
    }
  }

  type PaymentRefundPending__interface = {
    tag: SdkEvent_Tags.PaymentRefundPending;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentRefundPending_
    extends UniffiEnum
    implements PaymentRefundPending__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentRefundPending;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentRefundPending');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentRefundPending_ {
      return new PaymentRefundPending_(inner);
    }

    static instanceOf(obj: any): obj is PaymentRefundPending_ {
      return obj.tag === SdkEvent_Tags.PaymentRefundPending;
    }
  }

  type PaymentSucceeded__interface = {
    tag: SdkEvent_Tags.PaymentSucceeded;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentSucceeded_
    extends UniffiEnum
    implements PaymentSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentSucceeded;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentSucceeded_ {
      return new PaymentSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is PaymentSucceeded_ {
      return obj.tag === SdkEvent_Tags.PaymentSucceeded;
    }
  }

  type PaymentWaitingConfirmation__interface = {
    tag: SdkEvent_Tags.PaymentWaitingConfirmation;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentWaitingConfirmation_
    extends UniffiEnum
    implements PaymentWaitingConfirmation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentWaitingConfirmation;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentWaitingConfirmation');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentWaitingConfirmation_ {
      return new PaymentWaitingConfirmation_(inner);
    }

    static instanceOf(obj: any): obj is PaymentWaitingConfirmation_ {
      return obj.tag === SdkEvent_Tags.PaymentWaitingConfirmation;
    }
  }

  type PaymentWaitingFeeAcceptance__interface = {
    tag: SdkEvent_Tags.PaymentWaitingFeeAcceptance;
    inner: Readonly<{ details: Payment }>;
  };

  class PaymentWaitingFeeAcceptance_
    extends UniffiEnum
    implements PaymentWaitingFeeAcceptance__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentWaitingFeeAcceptance;
    readonly inner: Readonly<{ details: Payment }>;
    constructor(inner: { details: Payment }) {
      super('SdkEvent', 'PaymentWaitingFeeAcceptance');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { details: Payment }): PaymentWaitingFeeAcceptance_ {
      return new PaymentWaitingFeeAcceptance_(inner);
    }

    static instanceOf(obj: any): obj is PaymentWaitingFeeAcceptance_ {
      return obj.tag === SdkEvent_Tags.PaymentWaitingFeeAcceptance;
    }
  }

  type Synced__interface = {
    tag: SdkEvent_Tags.Synced;
  };

  class Synced_ extends UniffiEnum implements Synced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.Synced;
    constructor() {
      super('SdkEvent', 'Synced');
    }

    static new(): Synced_ {
      return new Synced_();
    }

    static instanceOf(obj: any): obj is Synced_ {
      return obj.tag === SdkEvent_Tags.Synced;
    }
  }

  type DataSynced__interface = {
    tag: SdkEvent_Tags.DataSynced;
    inner: Readonly<{ didPullNewRecords: boolean }>;
  };

  class DataSynced_ extends UniffiEnum implements DataSynced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.DataSynced;
    readonly inner: Readonly<{ didPullNewRecords: boolean }>;
    constructor(inner: { didPullNewRecords: boolean }) {
      super('SdkEvent', 'DataSynced');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { didPullNewRecords: boolean }): DataSynced_ {
      return new DataSynced_(inner);
    }

    static instanceOf(obj: any): obj is DataSynced_ {
      return obj.tag === SdkEvent_Tags.DataSynced;
    }
  }

  type Nwc__interface = {
    tag: SdkEvent_Tags.Nwc;
    inner: Readonly<{ eventId: string; details: NwcEvent }>;
  };

  class Nwc_ extends UniffiEnum implements Nwc__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.Nwc;
    readonly inner: Readonly<{ eventId: string; details: NwcEvent }>;
    constructor(inner: { eventId: string; details: NwcEvent }) {
      super('SdkEvent', 'Nwc');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string; details: NwcEvent }): Nwc_ {
      return new Nwc_(inner);
    }

    static instanceOf(obj: any): obj is Nwc_ {
      return obj.tag === SdkEvent_Tags.Nwc;
    }
  }

  function instanceOf(obj: any): obj is SdkEvent {
    return obj[uniffiTypeNameSymbol] === 'SdkEvent';
  }

  return Object.freeze({
    instanceOf,
    PaymentFailed: PaymentFailed_,
    PaymentPending: PaymentPending_,
    PaymentRefundable: PaymentRefundable_,
    PaymentRefunded: PaymentRefunded_,
    PaymentRefundPending: PaymentRefundPending_,
    PaymentSucceeded: PaymentSucceeded_,
    PaymentWaitingConfirmation: PaymentWaitingConfirmation_,
    PaymentWaitingFeeAcceptance: PaymentWaitingFeeAcceptance_,
    Synced: Synced_,
    DataSynced: DataSynced_,
    Nwc: Nwc_,
  });
})();

export type SdkEvent = InstanceType<
  (typeof SdkEvent)[keyof Omit<typeof SdkEvent, 'instanceOf'>]
>;

// FfiConverter for enum SdkEvent
const FfiConverterTypeSdkEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkEvent.PaymentFailed({
            details: FfiConverterTypePayment.read(from),
          });
        case 2:
          return new SdkEvent.PaymentPending({
            details: FfiConverterTypePayment.read(from),
          });
        case 3:
          return new SdkEvent.PaymentRefundable({
            details: FfiConverterTypePayment.read(from),
          });
        case 4:
          return new SdkEvent.PaymentRefunded({
            details: FfiConverterTypePayment.read(from),
          });
        case 5:
          return new SdkEvent.PaymentRefundPending({
            details: FfiConverterTypePayment.read(from),
          });
        case 6:
          return new SdkEvent.PaymentSucceeded({
            details: FfiConverterTypePayment.read(from),
          });
        case 7:
          return new SdkEvent.PaymentWaitingConfirmation({
            details: FfiConverterTypePayment.read(from),
          });
        case 8:
          return new SdkEvent.PaymentWaitingFeeAcceptance({
            details: FfiConverterTypePayment.read(from),
          });
        case 9:
          return new SdkEvent.Synced();
        case 10:
          return new SdkEvent.DataSynced({
            didPullNewRecords: FfiConverterBool.read(from),
          });
        case 11:
          return new SdkEvent.Nwc({
            eventId: FfiConverterString.read(from),
            details: FfiConverterTypeNwcEvent.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkEvent_Tags.PaymentFailed: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentPending: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentRefundable: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentRefunded: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentRefundPending: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentWaitingConfirmation: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.PaymentWaitingFeeAcceptance: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.details, into);
          return;
        }
        case SdkEvent_Tags.Synced: {
          ordinalConverter.write(9, into);
          return;
        }
        case SdkEvent_Tags.DataSynced: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.didPullNewRecords, into);
          return;
        }
        case SdkEvent_Tags.Nwc: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          FfiConverterTypeNwcEvent.write(inner.details, into);
          return;
        }
        default:
          // Throwing from here means that SdkEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkEvent_Tags.PaymentFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentPending: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentRefundable: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentRefunded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentRefundPending: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentWaitingConfirmation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.PaymentWaitingFeeAcceptance: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypePayment.allocationSize(inner.details);
          return size;
        }
        case SdkEvent_Tags.Synced: {
          return ordinalConverter.allocationSize(9);
        }
        case SdkEvent_Tags.DataSynced: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterBool.allocationSize(inner.didPullNewRecords);
          return size;
        }
        case SdkEvent_Tags.Nwc: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.eventId);
          size += FfiConverterTypeNwcEvent.allocationSize(inner.details);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendDestination
export enum SendDestination_Tags {
  LiquidAddress = 'LiquidAddress',
  Bolt11 = 'Bolt11',
  Bolt12 = 'Bolt12',
}
export const SendDestination = (() => {
  type LiquidAddress__interface = {
    tag: SendDestination_Tags.LiquidAddress;
    inner: Readonly<{
      addressData: LiquidAddressData;
      bip353Address: string | undefined;
    }>;
  };

  class LiquidAddress_ extends UniffiEnum implements LiquidAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendDestination';
    readonly tag = SendDestination_Tags.LiquidAddress;
    readonly inner: Readonly<{
      addressData: LiquidAddressData;
      bip353Address: string | undefined;
    }>;
    constructor(inner: {
      addressData: LiquidAddressData;
      bip353Address: string | undefined;
    }) {
      super('SendDestination', 'LiquidAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      addressData: LiquidAddressData;
      bip353Address: string | undefined;
    }): LiquidAddress_ {
      return new LiquidAddress_(inner);
    }

    static instanceOf(obj: any): obj is LiquidAddress_ {
      return obj.tag === SendDestination_Tags.LiquidAddress;
    }
  }

  type Bolt11__interface = {
    tag: SendDestination_Tags.Bolt11;
    inner: Readonly<{ invoice: LnInvoice; bip353Address: string | undefined }>;
  };

  class Bolt11_ extends UniffiEnum implements Bolt11__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendDestination';
    readonly tag = SendDestination_Tags.Bolt11;
    readonly inner: Readonly<{
      invoice: LnInvoice;
      bip353Address: string | undefined;
    }>;
    constructor(inner: {
      invoice: LnInvoice;
      bip353Address: string | undefined;
    }) {
      super('SendDestination', 'Bolt11');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      invoice: LnInvoice;
      bip353Address: string | undefined;
    }): Bolt11_ {
      return new Bolt11_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11_ {
      return obj.tag === SendDestination_Tags.Bolt11;
    }
  }

  type Bolt12__interface = {
    tag: SendDestination_Tags.Bolt12;
    inner: Readonly<{
      offer: LnOffer;
      receiverAmountSat: /*u64*/ bigint;
      bip353Address: string | undefined;
    }>;
  };

  class Bolt12_ extends UniffiEnum implements Bolt12__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendDestination';
    readonly tag = SendDestination_Tags.Bolt12;
    readonly inner: Readonly<{
      offer: LnOffer;
      receiverAmountSat: /*u64*/ bigint;
      bip353Address: string | undefined;
    }>;
    constructor(inner: {
      offer: LnOffer;
      receiverAmountSat: /*u64*/ bigint;
      bip353Address: string | undefined;
    }) {
      super('SendDestination', 'Bolt12');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      offer: LnOffer;
      receiverAmountSat: /*u64*/ bigint;
      bip353Address: string | undefined;
    }): Bolt12_ {
      return new Bolt12_(inner);
    }

    static instanceOf(obj: any): obj is Bolt12_ {
      return obj.tag === SendDestination_Tags.Bolt12;
    }
  }

  function instanceOf(obj: any): obj is SendDestination {
    return obj[uniffiTypeNameSymbol] === 'SendDestination';
  }

  return Object.freeze({
    instanceOf,
    LiquidAddress: LiquidAddress_,
    Bolt11: Bolt11_,
    Bolt12: Bolt12_,
  });
})();

export type SendDestination = InstanceType<
  (typeof SendDestination)[keyof Omit<typeof SendDestination, 'instanceOf'>]
>;

// FfiConverter for enum SendDestination
const FfiConverterTypeSendDestination = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendDestination;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendDestination.LiquidAddress({
            addressData: FfiConverterTypeLiquidAddressData.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new SendDestination.Bolt11({
            invoice: FfiConverterTypeLNInvoice.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new SendDestination.Bolt12({
            offer: FfiConverterTypeLNOffer.read(from),
            receiverAmountSat: FfiConverterUInt64.read(from),
            bip353Address: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendDestination_Tags.LiquidAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeLiquidAddressData.write(inner.addressData, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          return;
        }
        case SendDestination_Tags.Bolt11: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeLNInvoice.write(inner.invoice, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          return;
        }
        case SendDestination_Tags.Bolt12: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeLNOffer.write(inner.offer, into);
          FfiConverterUInt64.write(inner.receiverAmountSat, into);
          FfiConverterOptionalString.write(inner.bip353Address, into);
          return;
        }
        default:
          // Throwing from here means that SendDestination_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendDestination_Tags.LiquidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeLiquidAddressData.allocationSize(
            inner.addressData
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          return size;
        }
        case SendDestination_Tags.Bolt11: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeLNInvoice.allocationSize(inner.invoice);
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          return size;
        }
        case SendDestination_Tags.Bolt12: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeLNOffer.allocationSize(inner.offer);
          size += FfiConverterUInt64.allocationSize(inner.receiverAmountSat);
          size += FfiConverterOptionalString.allocationSize(
            inner.bip353Address
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SignerError

// Enum: SignerError
export enum SignerError_Tags {
  Generic = 'Generic',
}
export const SignerError = (() => {
  type Generic__interface = {
    tag: SignerError_Tags.Generic;
    inner: Readonly<{ err: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SignerError';
    readonly tag = SignerError_Tags.Generic;
    readonly inner: Readonly<{ err: string }>;
    constructor(inner: { err: string }) {
      super('SignerError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { err: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SignerError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ err: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SignerError {
    return obj[uniffiTypeNameSymbol] === 'SignerError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
  });
})();

export type SignerError = InstanceType<
  (typeof SignerError)[keyof Omit<typeof SignerError, 'instanceOf'>]
>;

// FfiConverter for enum SignerError
const FfiConverterTypeSignerError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SignerError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SignerError.Generic({
            err: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SignerError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.err, into);
          return;
        }
        default:
          // Throwing from here means that SignerError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SignerError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SuccessAction
export enum SuccessAction_Tags {
  Aes = 'Aes',
  Message = 'Message',
  Url = 'Url',
}
export const SuccessAction = (() => {
  type Aes__interface = {
    tag: SuccessAction_Tags.Aes;
    inner: Readonly<{ data: AesSuccessActionData }>;
  };

  class Aes_ extends UniffiEnum implements Aes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Aes;
    readonly inner: Readonly<{ data: AesSuccessActionData }>;
    constructor(inner: { data: AesSuccessActionData }) {
      super('SuccessAction', 'Aes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: AesSuccessActionData }): Aes_ {
      return new Aes_(inner);
    }

    static instanceOf(obj: any): obj is Aes_ {
      return obj.tag === SuccessAction_Tags.Aes;
    }
  }

  type Message__interface = {
    tag: SuccessAction_Tags.Message;
    inner: Readonly<{ data: MessageSuccessActionData }>;
  };

  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Message;
    readonly inner: Readonly<{ data: MessageSuccessActionData }>;
    constructor(inner: { data: MessageSuccessActionData }) {
      super('SuccessAction', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: MessageSuccessActionData }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === SuccessAction_Tags.Message;
    }
  }

  type Url__interface = {
    tag: SuccessAction_Tags.Url;
    inner: Readonly<{ data: UrlSuccessActionData }>;
  };

  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Url;
    readonly inner: Readonly<{ data: UrlSuccessActionData }>;
    constructor(inner: { data: UrlSuccessActionData }) {
      super('SuccessAction', 'Url');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: UrlSuccessActionData }): Url_ {
      return new Url_(inner);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === SuccessAction_Tags.Url;
    }
  }

  function instanceOf(obj: any): obj is SuccessAction {
    return obj[uniffiTypeNameSymbol] === 'SuccessAction';
  }

  return Object.freeze({
    instanceOf,
    Aes: Aes_,
    Message: Message_,
    Url: Url_,
  });
})();

export type SuccessAction = InstanceType<
  (typeof SuccessAction)[keyof Omit<typeof SuccessAction, 'instanceOf'>]
>;

// FfiConverter for enum SuccessAction
const FfiConverterTypeSuccessAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SuccessAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SuccessAction.Aes({
            data: FfiConverterTypeAesSuccessActionData.read(from),
          });
        case 2:
          return new SuccessAction.Message({
            data: FfiConverterTypeMessageSuccessActionData.read(from),
          });
        case 3:
          return new SuccessAction.Url({
            data: FfiConverterTypeUrlSuccessActionData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SuccessAction_Tags.Aes: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessAction_Tags.Message: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeMessageSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessAction_Tags.Url: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeUrlSuccessActionData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that SuccessAction_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SuccessAction_Tags.Aes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessAction_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeMessageSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessAction_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeUrlSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SuccessActionProcessed
export enum SuccessActionProcessed_Tags {
  Aes = 'Aes',
  Message = 'Message',
  Url = 'Url',
}
export const SuccessActionProcessed = (() => {
  type Aes__interface = {
    tag: SuccessActionProcessed_Tags.Aes;
    inner: Readonly<{ result: AesSuccessActionDataResult }>;
  };

  class Aes_ extends UniffiEnum implements Aes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Aes;
    readonly inner: Readonly<{ result: AesSuccessActionDataResult }>;
    constructor(inner: { result: AesSuccessActionDataResult }) {
      super('SuccessActionProcessed', 'Aes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { result: AesSuccessActionDataResult }): Aes_ {
      return new Aes_(inner);
    }

    static instanceOf(obj: any): obj is Aes_ {
      return obj.tag === SuccessActionProcessed_Tags.Aes;
    }
  }

  type Message__interface = {
    tag: SuccessActionProcessed_Tags.Message;
    inner: Readonly<{ data: MessageSuccessActionData }>;
  };

  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Message;
    readonly inner: Readonly<{ data: MessageSuccessActionData }>;
    constructor(inner: { data: MessageSuccessActionData }) {
      super('SuccessActionProcessed', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: MessageSuccessActionData }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === SuccessActionProcessed_Tags.Message;
    }
  }

  type Url__interface = {
    tag: SuccessActionProcessed_Tags.Url;
    inner: Readonly<{ data: UrlSuccessActionData }>;
  };

  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Url;
    readonly inner: Readonly<{ data: UrlSuccessActionData }>;
    constructor(inner: { data: UrlSuccessActionData }) {
      super('SuccessActionProcessed', 'Url');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: UrlSuccessActionData }): Url_ {
      return new Url_(inner);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === SuccessActionProcessed_Tags.Url;
    }
  }

  function instanceOf(obj: any): obj is SuccessActionProcessed {
    return obj[uniffiTypeNameSymbol] === 'SuccessActionProcessed';
  }

  return Object.freeze({
    instanceOf,
    Aes: Aes_,
    Message: Message_,
    Url: Url_,
  });
})();

export type SuccessActionProcessed = InstanceType<
  (typeof SuccessActionProcessed)[keyof Omit<
    typeof SuccessActionProcessed,
    'instanceOf'
  >]
>;

// FfiConverter for enum SuccessActionProcessed
const FfiConverterTypeSuccessActionProcessed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SuccessActionProcessed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SuccessActionProcessed.Aes({
            result: FfiConverterTypeAesSuccessActionDataResult.read(from),
          });
        case 2:
          return new SuccessActionProcessed.Message({
            data: FfiConverterTypeMessageSuccessActionData.read(from),
          });
        case 3:
          return new SuccessActionProcessed.Url({
            data: FfiConverterTypeUrlSuccessActionData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SuccessActionProcessed_Tags.Aes: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionDataResult.write(inner.result, into);
          return;
        }
        case SuccessActionProcessed_Tags.Message: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeMessageSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessActionProcessed_Tags.Url: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeUrlSuccessActionData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that SuccessActionProcessed_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SuccessActionProcessed_Tags.Aes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionDataResult.allocationSize(
            inner.result
          );
          return size;
        }
        case SuccessActionProcessed_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeMessageSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessActionProcessed_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeUrlSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface BindingLiquidSdkInterface {
  acceptPaymentProposedFees(
    req: AcceptPaymentProposedFeesRequest
  ) /*throws*/ : void;
  addEventListener(listener: EventListener) /*throws*/ : string;
  backup(req: BackupRequest) /*throws*/ : void;
  buyBitcoin(req: BuyBitcoinRequest) /*throws*/ : string;
  checkMessage(req: CheckMessageRequest) /*throws*/ : CheckMessageResponse;
  createBolt12Invoice(
    req: CreateBolt12InvoiceRequest
  ) /*throws*/ : CreateBolt12InvoiceResponse;
  disconnect() /*throws*/ : void;
  fetchFiatRates() /*throws*/ : Array<Rate>;
  fetchLightningLimits() /*throws*/ : LightningPaymentLimitsResponse;
  fetchOnchainLimits() /*throws*/ : OnchainPaymentLimitsResponse;
  fetchPaymentProposedFees(
    req: FetchPaymentProposedFeesRequest
  ) /*throws*/ : FetchPaymentProposedFeesResponse;
  getInfo() /*throws*/ : GetInfoResponse;
  getPayment(req: GetPaymentRequest) /*throws*/ : Payment | undefined;
  listFiatCurrencies() /*throws*/ : Array<FiatCurrency>;
  listPayments(req: ListPaymentsRequest) /*throws*/ : Array<Payment>;
  listRefundables() /*throws*/ : Array<RefundableSwap>;
  lnurlAuth(reqData: LnUrlAuthRequestData) /*throws*/ : LnUrlCallbackStatus;
  lnurlPay(req: LnUrlPayRequest) /*throws*/ : LnUrlPayResult;
  lnurlWithdraw(req: LnUrlWithdrawRequest) /*throws*/ : LnUrlWithdrawResult;
  parse(input: string) /*throws*/ : InputType;
  payOnchain(req: PayOnchainRequest) /*throws*/ : SendPaymentResponse;
  prepareBuyBitcoin(
    req: PrepareBuyBitcoinRequest
  ) /*throws*/ : PrepareBuyBitcoinResponse;
  prepareLnurlPay(
    req: PrepareLnUrlPayRequest
  ) /*throws*/ : PrepareLnUrlPayResponse;
  preparePayOnchain(
    req: PreparePayOnchainRequest
  ) /*throws*/ : PreparePayOnchainResponse;
  prepareReceivePayment(
    req: PrepareReceiveRequest
  ) /*throws*/ : PrepareReceiveResponse;
  prepareRefund(req: PrepareRefundRequest) /*throws*/ : PrepareRefundResponse;
  prepareSendPayment(req: PrepareSendRequest) /*throws*/ : PrepareSendResponse;
  receivePayment(
    req: ReceivePaymentRequest
  ) /*throws*/ : ReceivePaymentResponse;
  recommendedFees() /*throws*/ : RecommendedFees;
  refund(req: RefundRequest) /*throws*/ : RefundResponse;
  registerWebhook(webhookUrl: string) /*throws*/ : void;
  removeEventListener(id: string) /*throws*/ : void;
  rescanOnchainSwaps() /*throws*/ : void;
  restore(req: RestoreRequest) /*throws*/ : void;
  sendPayment(req: SendPaymentRequest) /*throws*/ : SendPaymentResponse;
  signMessage(req: SignMessageRequest) /*throws*/ : SignMessageResponse;
  sync() /*throws*/ : void;
  unregisterWebhook() /*throws*/ : void;
}

export class BindingLiquidSdk
  extends UniffiAbstractObject
  implements BindingLiquidSdkInterface
{
  readonly [uniffiTypeNameSymbol] = 'BindingLiquidSdk';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBindingLiquidSdkObjectFactory.bless(pointer);
  }

  public acceptPaymentProposedFees(
    req: AcceptPaymentProposedFeesRequest
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
        FfiConverterTypePaymentError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          FfiConverterTypeAcceptPaymentProposedFeesRequest.lower(req),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public addEventListener(listener: EventListener): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeEventListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public backup(req: BackupRequest): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          FfiConverterTypeBackupRequest.lower(req),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public buyBitcoin(req: BuyBitcoinRequest): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeBuyBitcoinRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public checkMessage(
    req: CheckMessageRequest
  ): CheckMessageResponse /*throws*/ {
    return FfiConverterTypeCheckMessageResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCheckMessageRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public createBolt12Invoice(
    req: CreateBolt12InvoiceRequest
  ): CreateBolt12InvoiceResponse /*throws*/ {
    return FfiConverterTypeCreateBolt12InvoiceResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCreateBolt12InvoiceRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public disconnect(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public fetchFiatRates(): Array<Rate> /*throws*/ {
    return FfiConverterArrayTypeRate.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fetchLightningLimits(): LightningPaymentLimitsResponse /*throws*/ {
    return FfiConverterTypeLightningPaymentLimitsResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fetchOnchainLimits(): OnchainPaymentLimitsResponse /*throws*/ {
    return FfiConverterTypeOnchainPaymentLimitsResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fetchPaymentProposedFees(
    req: FetchPaymentProposedFeesRequest
  ): FetchPaymentProposedFeesResponse /*throws*/ {
    return FfiConverterTypeFetchPaymentProposedFeesResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeFetchPaymentProposedFeesRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getInfo(): GetInfoResponse /*throws*/ {
    return FfiConverterTypeGetInfoResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getPayment(req: GetPaymentRequest): Payment | undefined /*throws*/ {
    return FfiConverterOptionalTypePayment.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetPaymentRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listFiatCurrencies(): Array<FiatCurrency> /*throws*/ {
    return FfiConverterArrayTypeFiatCurrency.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listPayments(req: ListPaymentsRequest): Array<Payment> /*throws*/ {
    return FfiConverterArrayTypePayment.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listRefundables(): Array<RefundableSwap> /*throws*/ {
    return FfiConverterArrayTypeRefundableSwap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public lnurlAuth(
    reqData: LnUrlAuthRequestData
  ): LnUrlCallbackStatus /*throws*/ {
    return FfiConverterTypeLnUrlCallbackStatus.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLnUrlAuthError.lift.bind(
          FfiConverterTypeLnUrlAuthError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnUrlAuthRequestData.lower(reqData),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public lnurlPay(req: LnUrlPayRequest): LnUrlPayResult /*throws*/ {
    return FfiConverterTypeLnUrlPayResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLnUrlPayError.lift.bind(
          FfiConverterTypeLnUrlPayError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnUrlPayRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public lnurlWithdraw(
    req: LnUrlWithdrawRequest
  ): LnUrlWithdrawResult /*throws*/ {
    return FfiConverterTypeLnUrlWithdrawResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLnUrlWithdrawError.lift.bind(
          FfiConverterTypeLnUrlWithdrawError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnUrlWithdrawRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public parse(input: string): InputType /*throws*/ {
    return FfiConverterTypeInputType.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(input),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public payOnchain(req: PayOnchainRequest): SendPaymentResponse /*throws*/ {
    return FfiConverterTypeSendPaymentResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePayOnchainRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public prepareBuyBitcoin(
    req: PrepareBuyBitcoinRequest
  ): PrepareBuyBitcoinResponse /*throws*/ {
    return FfiConverterTypePrepareBuyBitcoinResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareBuyBitcoinRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public prepareLnurlPay(
    req: PrepareLnUrlPayRequest
  ): PrepareLnUrlPayResponse /*throws*/ {
    return FfiConverterTypePrepareLnUrlPayResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLnUrlPayError.lift.bind(
          FfiConverterTypeLnUrlPayError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareLnUrlPayRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public preparePayOnchain(
    req: PreparePayOnchainRequest
  ): PreparePayOnchainResponse /*throws*/ {
    return FfiConverterTypePreparePayOnchainResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePreparePayOnchainRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public prepareReceivePayment(
    req: PrepareReceiveRequest
  ): PrepareReceiveResponse /*throws*/ {
    return FfiConverterTypePrepareReceiveResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareReceiveRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public prepareRefund(
    req: PrepareRefundRequest
  ): PrepareRefundResponse /*throws*/ {
    return FfiConverterTypePrepareRefundResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareRefundRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public prepareSendPayment(
    req: PrepareSendRequest
  ): PrepareSendResponse /*throws*/ {
    return FfiConverterTypePrepareSendResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareSendRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public receivePayment(
    req: ReceivePaymentRequest
  ): ReceivePaymentResponse /*throws*/ {
    return FfiConverterTypeReceivePaymentResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeReceivePaymentRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public recommendedFees(): RecommendedFees /*throws*/ {
    return FfiConverterTypeRecommendedFees.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public refund(req: RefundRequest): RefundResponse /*throws*/ {
    return FfiConverterTypeRefundResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRefundRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public registerWebhook(webhookUrl: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          FfiConverterString.lower(webhookUrl),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public removeEventListener(id: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          FfiConverterString.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public rescanOnchainSwaps(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public restore(req: RestoreRequest): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          FfiConverterTypeRestoreRequest.lower(req),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public sendPayment(req: SendPaymentRequest): SendPaymentResponse /*throws*/ {
    return FfiConverterTypeSendPaymentResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePaymentError.lift.bind(
          FfiConverterTypePaymentError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSendPaymentRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public signMessage(req: SignMessageRequest): SignMessageResponse /*throws*/ {
    return FfiConverterTypeSignMessageResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
            uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSignMessageRequest.lower(req),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sync(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public unregisterWebhook(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
          uniffiTypeBindingLiquidSdkObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBindingLiquidSdkObjectFactory.pointer(this);
      uniffiTypeBindingLiquidSdkObjectFactory.freePointer(pointer);
      uniffiTypeBindingLiquidSdkObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BindingLiquidSdk {
    return uniffiTypeBindingLiquidSdkObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBindingLiquidSdkObjectFactory: UniffiObjectFactory<BindingLiquidSdkInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): BindingLiquidSdkInterface {
      const instance = Object.create(BindingLiquidSdk.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BindingLiquidSdk';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_bindingliquidsdk_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BindingLiquidSdkInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BindingLiquidSdkInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BindingLiquidSdkInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'BindingLiquidSdk'
      );
    },
  };
// FfiConverter for BindingLiquidSdkInterface
const FfiConverterTypeBindingLiquidSdk = new FfiConverterObject(
  uniffiTypeBindingLiquidSdkObjectFactory
);

export interface PluginEventEmitterInterface {
  broadcast(event: SdkEvent): void;
}

export class PluginEventEmitter
  extends UniffiAbstractObject
  implements PluginEventEmitterInterface
{
  readonly [uniffiTypeNameSymbol] = 'PluginEventEmitter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePluginEventEmitterObjectFactory.bless(pointer);
  }

  public broadcast(event: SdkEvent): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
          uniffiTypePluginEventEmitterObjectFactory.clonePointer(this),
          FfiConverterTypeSdkEvent.lower(event),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePluginEventEmitterObjectFactory.pointer(this);
      uniffiTypePluginEventEmitterObjectFactory.freePointer(pointer);
      uniffiTypePluginEventEmitterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PluginEventEmitter {
    return uniffiTypePluginEventEmitterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePluginEventEmitterObjectFactory: UniffiObjectFactory<PluginEventEmitterInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): PluginEventEmitterInterface {
      const instance = Object.create(PluginEventEmitter.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PluginEventEmitter';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_plugineventemitter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PluginEventEmitterInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PluginEventEmitterInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PluginEventEmitterInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PluginEventEmitter'
      );
    },
  };
// FfiConverter for PluginEventEmitterInterface
const FfiConverterTypePluginEventEmitter = new FfiConverterObject(
  uniffiTypePluginEventEmitterObjectFactory
);

export interface PluginStorageInterface {
  getItem(key: string) /*throws*/ : string | undefined;
  removeItem(key: string) /*throws*/ : void;
  setItem(key: string, value: string) /*throws*/ : void;
}

export class PluginStorage
  extends UniffiAbstractObject
  implements PluginStorageInterface
{
  readonly [uniffiTypeNameSymbol] = 'PluginStorage';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePluginStorageObjectFactory.bless(pointer);
  }

  public getItem(key: string): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePluginStorageError.lift.bind(
          FfiConverterTypePluginStorageError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
            uniffiTypePluginStorageObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeItem(key: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePluginStorageError.lift.bind(
        FfiConverterTypePluginStorageError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
          uniffiTypePluginStorageObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setItem(key: string, value: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePluginStorageError.lift.bind(
        FfiConverterTypePluginStorageError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
          uniffiTypePluginStorageObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          FfiConverterString.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePluginStorageObjectFactory.pointer(this);
      uniffiTypePluginStorageObjectFactory.freePointer(pointer);
      uniffiTypePluginStorageObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PluginStorage {
    return uniffiTypePluginStorageObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePluginStorageObjectFactory: UniffiObjectFactory<PluginStorageInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): PluginStorageInterface {
      const instance = Object.create(PluginStorage.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PluginStorage';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_pluginstorage_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PluginStorageInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PluginStorageInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PluginStorageInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PluginStorage'
      );
    },
  };
// FfiConverter for PluginStorageInterface
const FfiConverterTypePluginStorage = new FfiConverterObject(
  uniffiTypePluginStorageObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for AssetInfo | undefined
const FfiConverterOptionalTypeAssetInfo = new FfiConverterOptional(
  FfiConverterTypeAssetInfo
);

// FfiConverter for LnUrlInfo | undefined
const FfiConverterOptionalTypeLnUrlInfo = new FfiConverterOptional(
  FfiConverterTypeLnUrlInfo
);

// FfiConverter for Payment | undefined
const FfiConverterOptionalTypePayment = new FfiConverterOptional(
  FfiConverterTypePayment
);

// FfiConverter for Symbol | undefined
const FfiConverterOptionalTypeSymbol = new FfiConverterOptional(
  FfiConverterTypeSymbol
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<Plugin>
const FfiConverterArrayTypePlugin = new FfiConverterArray(
  FfiConverterTypePlugin
);

// FfiConverter for Array<AssetBalance>
const FfiConverterArrayTypeAssetBalance = new FfiConverterArray(
  FfiConverterTypeAssetBalance
);

// FfiConverter for Array<AssetMetadata>
const FfiConverterArrayTypeAssetMetadata = new FfiConverterArray(
  FfiConverterTypeAssetMetadata
);

// FfiConverter for Array<ExternalInputParser>
const FfiConverterArrayTypeExternalInputParser = new FfiConverterArray(
  FfiConverterTypeExternalInputParser
);

// FfiConverter for Array<FiatCurrency>
const FfiConverterArrayTypeFiatCurrency = new FfiConverterArray(
  FfiConverterTypeFiatCurrency
);

// FfiConverter for Array<LnOfferBlindedPath>
const FfiConverterArrayTypeLnOfferBlindedPath = new FfiConverterArray(
  FfiConverterTypeLnOfferBlindedPath
);

// FfiConverter for Array<LocaleOverrides>
const FfiConverterArrayTypeLocaleOverrides = new FfiConverterArray(
  FfiConverterTypeLocaleOverrides
);

// FfiConverter for Array<LocalizedName>
const FfiConverterArrayTypeLocalizedName = new FfiConverterArray(
  FfiConverterTypeLocalizedName
);

// FfiConverter for Array<Payment>
const FfiConverterArrayTypePayment = new FfiConverterArray(
  FfiConverterTypePayment
);

// FfiConverter for Array<Rate>
const FfiConverterArrayTypeRate = new FfiConverterArray(FfiConverterTypeRate);

// FfiConverter for Array<RefundableSwap>
const FfiConverterArrayTypeRefundableSwap = new FfiConverterArray(
  FfiConverterTypeRefundableSwap
);

// FfiConverter for Array<RouteHint>
const FfiConverterArrayTypeRouteHint = new FfiConverterArray(
  FfiConverterTypeRouteHint
);

// FfiConverter for Array<RouteHintHop>
const FfiConverterArrayTypeRouteHintHop = new FfiConverterArray(
  FfiConverterTypeRouteHintHop
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u8*/number>
const FfiConverterArrayUInt8 = new FfiConverterArray(FfiConverterUInt8);

// FfiConverter for Amount | undefined
const FfiConverterOptionalTypeAmount = new FfiConverterOptional(
  FfiConverterTypeAmount
);

// FfiConverter for ListPaymentDetails | undefined
const FfiConverterOptionalTypeListPaymentDetails = new FfiConverterOptional(
  FfiConverterTypeListPaymentDetails
);

// FfiConverter for PayAmount | undefined
const FfiConverterOptionalTypePayAmount = new FfiConverterOptional(
  FfiConverterTypePayAmount
);

// FfiConverter for ReceiveAmount | undefined
const FfiConverterOptionalTypeReceiveAmount = new FfiConverterOptional(
  FfiConverterTypeReceiveAmount
);

// FfiConverter for SuccessAction | undefined
const FfiConverterOptionalTypeSuccessAction = new FfiConverterOptional(
  FfiConverterTypeSuccessAction
);

// FfiConverter for SuccessActionProcessed | undefined
const FfiConverterOptionalTypeSuccessActionProcessed = new FfiConverterOptional(
  FfiConverterTypeSuccessActionProcessed
);

// FfiConverter for Array<Plugin> | undefined
const FfiConverterOptionalArrayTypePlugin = new FfiConverterOptional(
  FfiConverterArrayTypePlugin
);

// FfiConverter for Array<AssetMetadata> | undefined
const FfiConverterOptionalArrayTypeAssetMetadata = new FfiConverterOptional(
  FfiConverterArrayTypeAssetMetadata
);

// FfiConverter for Array<ExternalInputParser> | undefined
const FfiConverterOptionalArrayTypeExternalInputParser =
  new FfiConverterOptional(FfiConverterArrayTypeExternalInputParser);

// FfiConverter for Array</*u8*/number> | undefined
const FfiConverterOptionalArrayUInt8 = new FfiConverterOptional(
  FfiConverterArrayUInt8
);

// FfiConverter for Array<PaymentState>
const FfiConverterArrayTypePaymentState = new FfiConverterArray(
  FfiConverterTypePaymentState
);

// FfiConverter for Array<PaymentType>
const FfiConverterArrayTypePaymentType = new FfiConverterArray(
  FfiConverterTypePaymentType
);

// FfiConverter for Array<PaymentState> | undefined
const FfiConverterOptionalArrayTypePaymentState = new FfiConverterOptional(
  FfiConverterArrayTypePaymentState
);

// FfiConverter for Array<PaymentType> | undefined
const FfiConverterOptionalArrayTypePaymentType = new FfiConverterOptional(
  FfiConverterArrayTypePaymentType
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_breez_sdk_liquid_bindings_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_connect() !==
    56099
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_func_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer() !==
    22815
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_default_config() !==
    20931
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_func_default_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice() !==
    45284
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger() !==
    32375
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees() !==
    57291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener() !==
    65289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup() !==
    3592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin() !==
    53022
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message() !==
    64029
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice() !==
    30488
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect() !==
    37717
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates() !==
    61824
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits() !==
    61822
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits() !==
    51575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees() !==
    45806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info() !==
    4290
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment() !==
    25832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies() !==
    38203
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments() !==
    39611
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables() !==
    22886
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth() !==
    58655
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay() !==
    46650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw() !==
    60533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse() !==
    40166
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain() !==
    46079
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin() !==
    26608
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay() !==
    14727
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain() !==
    1876
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment() !==
    28769
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund() !==
    53467
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment() !==
    1183
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment() !==
    63548
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees() !==
    23255
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund() !==
    31475
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook() !==
    3912
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener() !==
    16569
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps() !==
    14305
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore() !==
    63590
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment() !==
    63087
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message() !==
    33731
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync() !==
    31783
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook() !==
    34970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast() !==
    56428
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item() !==
    50949
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item() !==
    35977
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item() !==
    49740
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event() !==
    22441
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log() !==
    36218
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id() !==
    19661
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start() !==
    26346
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop() !==
    59886
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub() !==
    36847
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub() !==
    8680
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa() !==
    48623
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable() !==
    263
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key() !==
    9707
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256() !==
    40934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt() !==
    43772
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt() !==
    45851
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt'
    );
  }

  uniffiCallbackInterfaceEventListener.register();
  uniffiCallbackInterfaceLogger.register();
  uniffiCallbackInterfacePlugin.register();
  uniffiCallbackInterfaceSigner.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAcceptPaymentProposedFeesRequest,
    FfiConverterTypeAesSuccessActionData,
    FfiConverterTypeAesSuccessActionDataDecrypted,
    FfiConverterTypeAesSuccessActionDataResult,
    FfiConverterTypeAmount,
    FfiConverterTypeAssetBalance,
    FfiConverterTypeAssetInfo,
    FfiConverterTypeAssetMetadata,
    FfiConverterTypeBackupRequest,
    FfiConverterTypeBindingLiquidSdk,
    FfiConverterTypeBitcoinAddressData,
    FfiConverterTypeBlockchainExplorer,
    FfiConverterTypeBlockchainInfo,
    FfiConverterTypeBuyBitcoinProvider,
    FfiConverterTypeBuyBitcoinRequest,
    FfiConverterTypeCheckMessageRequest,
    FfiConverterTypeCheckMessageResponse,
    FfiConverterTypeConfig,
    FfiConverterTypeConnectRequest,
    FfiConverterTypeConnectWithSignerRequest,
    FfiConverterTypeCreateBolt12InvoiceRequest,
    FfiConverterTypeCreateBolt12InvoiceResponse,
    FfiConverterTypeCurrencyInfo,
    FfiConverterTypeExternalInputParser,
    FfiConverterTypeFetchPaymentProposedFeesRequest,
    FfiConverterTypeFetchPaymentProposedFeesResponse,
    FfiConverterTypeFiatCurrency,
    FfiConverterTypeGetInfoResponse,
    FfiConverterTypeGetPaymentRequest,
    FfiConverterTypeInputType,
    FfiConverterTypeLNInvoice,
    FfiConverterTypeLNOffer,
    FfiConverterTypeLightningPaymentLimitsResponse,
    FfiConverterTypeLimits,
    FfiConverterTypeLiquidAddressData,
    FfiConverterTypeLiquidNetwork,
    FfiConverterTypeListPaymentDetails,
    FfiConverterTypeListPaymentsRequest,
    FfiConverterTypeLnOfferBlindedPath,
    FfiConverterTypeLnUrlAuthRequestData,
    FfiConverterTypeLnUrlCallbackStatus,
    FfiConverterTypeLnUrlErrorData,
    FfiConverterTypeLnUrlInfo,
    FfiConverterTypeLnUrlPayErrorData,
    FfiConverterTypeLnUrlPayRequest,
    FfiConverterTypeLnUrlPayRequestData,
    FfiConverterTypeLnUrlPayResult,
    FfiConverterTypeLnUrlPaySuccessData,
    FfiConverterTypeLnUrlWithdrawRequest,
    FfiConverterTypeLnUrlWithdrawRequestData,
    FfiConverterTypeLnUrlWithdrawResult,
    FfiConverterTypeLnUrlWithdrawSuccessData,
    FfiConverterTypeLocaleOverrides,
    FfiConverterTypeLocalizedName,
    FfiConverterTypeLogEntry,
    FfiConverterTypeMessageSuccessActionData,
    FfiConverterTypeNetwork,
    FfiConverterTypeNwcEvent,
    FfiConverterTypeOnchainPaymentLimitsResponse,
    FfiConverterTypePayAmount,
    FfiConverterTypePayOnchainRequest,
    FfiConverterTypePayment,
    FfiConverterTypePaymentDetails,
    FfiConverterTypePaymentMethod,
    FfiConverterTypePaymentState,
    FfiConverterTypePaymentType,
    FfiConverterTypePluginEventEmitter,
    FfiConverterTypePluginStorage,
    FfiConverterTypePrepareBuyBitcoinRequest,
    FfiConverterTypePrepareBuyBitcoinResponse,
    FfiConverterTypePrepareLnUrlPayRequest,
    FfiConverterTypePrepareLnUrlPayResponse,
    FfiConverterTypePreparePayOnchainRequest,
    FfiConverterTypePreparePayOnchainResponse,
    FfiConverterTypePrepareReceiveRequest,
    FfiConverterTypePrepareReceiveResponse,
    FfiConverterTypePrepareRefundRequest,
    FfiConverterTypePrepareRefundResponse,
    FfiConverterTypePrepareSendRequest,
    FfiConverterTypePrepareSendResponse,
    FfiConverterTypeRate,
    FfiConverterTypeReceiveAmount,
    FfiConverterTypeReceivePaymentRequest,
    FfiConverterTypeReceivePaymentResponse,
    FfiConverterTypeRecommendedFees,
    FfiConverterTypeRefundRequest,
    FfiConverterTypeRefundResponse,
    FfiConverterTypeRefundableSwap,
    FfiConverterTypeRestoreRequest,
    FfiConverterTypeRouteHint,
    FfiConverterTypeRouteHintHop,
    FfiConverterTypeSdkEvent,
    FfiConverterTypeSendDestination,
    FfiConverterTypeSendPaymentRequest,
    FfiConverterTypeSendPaymentResponse,
    FfiConverterTypeSignMessageRequest,
    FfiConverterTypeSignMessageResponse,
    FfiConverterTypeSuccessAction,
    FfiConverterTypeSuccessActionProcessed,
    FfiConverterTypeSymbol,
    FfiConverterTypeUrlSuccessActionData,
    FfiConverterTypeWalletInfo,
  },
});
