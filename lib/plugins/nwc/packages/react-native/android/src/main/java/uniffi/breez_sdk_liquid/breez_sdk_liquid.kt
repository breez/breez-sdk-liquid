// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.breez_sdk_liquid

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_breez_sdk_liquid_bindings_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_breez_sdk_liquid_bindings_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "breez_sdk_liquid_nwc"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceEventListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`e`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLoggerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`l`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePluginMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePluginMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`sdk`: Pointer,`storage`: Pointer,`eventEmitter`: Pointer,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePluginMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod4 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod5 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod6 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSignerMethod7 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("onEvent", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceEventListener(
    @JvmField internal var `onEvent`: UniffiCallbackInterfaceEventListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onEvent`: UniffiCallbackInterfaceEventListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceEventListener(`onEvent`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceEventListener) {
        `onEvent` = other.`onEvent`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("log", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceLogger(
    @JvmField internal var `log`: UniffiCallbackInterfaceLoggerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `log`: UniffiCallbackInterfaceLoggerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceLogger(`log`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceLogger) {
        `log` = other.`log`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("id", "onStart", "onStop", "uniffiFree")
internal open class UniffiVTableCallbackInterfacePlugin(
    @JvmField internal var `id`: UniffiCallbackInterfacePluginMethod0? = null,
    @JvmField internal var `onStart`: UniffiCallbackInterfacePluginMethod1? = null,
    @JvmField internal var `onStop`: UniffiCallbackInterfacePluginMethod2? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `id`: UniffiCallbackInterfacePluginMethod0? = null,
        `onStart`: UniffiCallbackInterfacePluginMethod1? = null,
        `onStop`: UniffiCallbackInterfacePluginMethod2? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfacePlugin(`id`,`onStart`,`onStop`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePlugin) {
        `id` = other.`id`
        `onStart` = other.`onStart`
        `onStop` = other.`onStop`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("xpub", "deriveXpub", "signEcdsa", "signEcdsaRecoverable", "slip77MasterBlindingKey", "hmacSha256", "eciesEncrypt", "eciesDecrypt", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSigner(
    @JvmField internal var `xpub`: UniffiCallbackInterfaceSignerMethod0? = null,
    @JvmField internal var `deriveXpub`: UniffiCallbackInterfaceSignerMethod1? = null,
    @JvmField internal var `signEcdsa`: UniffiCallbackInterfaceSignerMethod2? = null,
    @JvmField internal var `signEcdsaRecoverable`: UniffiCallbackInterfaceSignerMethod3? = null,
    @JvmField internal var `slip77MasterBlindingKey`: UniffiCallbackInterfaceSignerMethod4? = null,
    @JvmField internal var `hmacSha256`: UniffiCallbackInterfaceSignerMethod5? = null,
    @JvmField internal var `eciesEncrypt`: UniffiCallbackInterfaceSignerMethod6? = null,
    @JvmField internal var `eciesDecrypt`: UniffiCallbackInterfaceSignerMethod7? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `xpub`: UniffiCallbackInterfaceSignerMethod0? = null,
        `deriveXpub`: UniffiCallbackInterfaceSignerMethod1? = null,
        `signEcdsa`: UniffiCallbackInterfaceSignerMethod2? = null,
        `signEcdsaRecoverable`: UniffiCallbackInterfaceSignerMethod3? = null,
        `slip77MasterBlindingKey`: UniffiCallbackInterfaceSignerMethod4? = null,
        `hmacSha256`: UniffiCallbackInterfaceSignerMethod5? = null,
        `eciesEncrypt`: UniffiCallbackInterfaceSignerMethod6? = null,
        `eciesDecrypt`: UniffiCallbackInterfaceSignerMethod7? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSigner(`xpub`,`deriveXpub`,`signEcdsa`,`signEcdsaRecoverable`,`slip77MasterBlindingKey`,`hmacSha256`,`eciesEncrypt`,`eciesDecrypt`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSigner) {
        `xpub` = other.`xpub`
        `deriveXpub` = other.`deriveXpub`
        `signEcdsa` = other.`signEcdsa`
        `signEcdsaRecoverable` = other.`signEcdsaRecoverable`
        `slip77MasterBlindingKey` = other.`slip77MasterBlindingKey`
        `hmacSha256` = other.`hmacSha256`
        `eciesEncrypt` = other.`eciesEncrypt`
        `eciesDecrypt` = other.`eciesDecrypt`
        `uniffiFree` = other.`uniffiFree`
    }

}















































































































































































// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "breez_sdk_liquid")
            .also { lib: UniffiLib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                uniffiCallbackInterfaceEventListener.register(lib)
                uniffiCallbackInterfaceLogger.register(lib)
                uniffiCallbackInterfacePlugin.register(lib)
                uniffiCallbackInterfaceSigner.register(lib)
                }
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    fun uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(`ptr`: Pointer,`reqData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(`ptr`: Pointer,`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(`ptr`: Pointer,`webhookUrl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(`ptr`: Pointer,`id`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(`ptr`: Pointer,`req`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(`ptr`: Pointer,`event`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(`ptr`: Pointer,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(`ptr`: Pointer,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(`ptr`: Pointer,`key`: RustBuffer.ByValue,`value`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(`vtable`: UniffiVTableCallbackInterfaceEventListener,
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(`vtable`: UniffiVTableCallbackInterfaceLogger,
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(`vtable`: UniffiVTableCallbackInterfacePlugin,
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(`vtable`: UniffiVTableCallbackInterfaceSigner,
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_fn_func_connect(`req`: RustBuffer.ByValue,`plugins`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(`req`: RustBuffer.ByValue,`signer`: Long,`plugins`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_breez_sdk_liquid_bindings_fn_func_default_config(`network`: RustBuffer.ByValue,`breezApiKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(`logger`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_breez_sdk_liquid_bindings_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_breez_sdk_liquid_bindings_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_u8(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_u8(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_i8(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_i8(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_u16(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_u16(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_i16(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_i16(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_u32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_u32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_i32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_i32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_u64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_u64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_i64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_i64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_f32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_f32(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Float
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_f64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_f64(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Double
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_pointer(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_pointer(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_breez_sdk_liquid_bindings_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_cancel_void(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_free_void(`handle`: Long,
    ): Unit
    fun ffi_breez_sdk_liquid_bindings_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_breez_sdk_liquid_bindings_checksum_func_connect(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_func_default_config(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt(
    ): Short
    fun uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt(
    ): Short
    fun ffi_breez_sdk_liquid_bindings_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_breez_sdk_liquid_bindings_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_func_connect() != 56099.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_func_connect_with_signer() != 22815.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_func_default_config() != 20931.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_func_parse_invoice() != 45284.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_func_set_logger() != 32375.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_accept_payment_proposed_fees() != 57291.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_add_event_listener() != 65289.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_backup() != 3592.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_buy_bitcoin() != 53022.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_check_message() != 64029.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_create_bolt12_invoice() != 30488.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_disconnect() != 37717.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_fiat_rates() != 61824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_lightning_limits() != 61822.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_onchain_limits() != 51575.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_fetch_payment_proposed_fees() != 45806.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_info() != 4290.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_get_payment() != 25832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_fiat_currencies() != 38203.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_payments() != 39611.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_list_refundables() != 22886.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_auth() != 58655.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_pay() != 46650.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_lnurl_withdraw() != 60533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_parse() != 40166.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_pay_onchain() != 46079.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_buy_bitcoin() != 26608.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_lnurl_pay() != 14727.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_pay_onchain() != 1876.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_receive_payment() != 28769.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_refund() != 53467.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_prepare_send_payment() != 1183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_receive_payment() != 63548.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_recommended_fees() != 23255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_refund() != 31475.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_register_webhook() != 3912.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_remove_event_listener() != 16569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_rescan_onchain_swaps() != 14305.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_restore() != 63590.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_send_payment() != 63087.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sign_message() != 33731.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_sync() != 31783.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_bindingliquidsdk_unregister_webhook() != 34970.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_plugineventemitter_broadcast() != 56428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_get_item() != 50949.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_remove_item() != 35977.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_pluginstorage_set_item() != 49740.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_eventlistener_on_event() != 22441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_logger_log() != 36218.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_id() != 19661.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_start() != 26346.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_plugin_on_stop() != 59886.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_xpub() != 36847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_derive_xpub() != 8680.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa() != 48623.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_sign_ecdsa_recoverable() != 263.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_slip77_master_blinding_key() != 9707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_hmac_sha256() != 40934.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_encrypt() != 43772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_breez_sdk_liquid_bindings_checksum_method_signer_ecies_decrypt() != 45851.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}
public interface BindingLiquidSdkInterface {
    
    fun `acceptPaymentProposedFees`(`req`: AcceptPaymentProposedFeesRequest)
    
    fun `addEventListener`(`listener`: EventListener): kotlin.String
    
    fun `backup`(`req`: BackupRequest)
    
    fun `buyBitcoin`(`req`: BuyBitcoinRequest): kotlin.String
    
    fun `checkMessage`(`req`: CheckMessageRequest): CheckMessageResponse
    
    fun `createBolt12Invoice`(`req`: CreateBolt12InvoiceRequest): CreateBolt12InvoiceResponse
    
    fun `disconnect`()
    
    fun `fetchFiatRates`(): List<Rate>
    
    fun `fetchLightningLimits`(): LightningPaymentLimitsResponse
    
    fun `fetchOnchainLimits`(): OnchainPaymentLimitsResponse
    
    fun `fetchPaymentProposedFees`(`req`: FetchPaymentProposedFeesRequest): FetchPaymentProposedFeesResponse
    
    fun `getInfo`(): GetInfoResponse
    
    fun `getPayment`(`req`: GetPaymentRequest): Payment?
    
    fun `listFiatCurrencies`(): List<FiatCurrency>
    
    fun `listPayments`(`req`: ListPaymentsRequest): List<Payment>
    
    fun `listRefundables`(): List<RefundableSwap>
    
    fun `lnurlAuth`(`reqData`: LnUrlAuthRequestData): LnUrlCallbackStatus
    
    fun `lnurlPay`(`req`: LnUrlPayRequest): LnUrlPayResult
    
    fun `lnurlWithdraw`(`req`: LnUrlWithdrawRequest): LnUrlWithdrawResult
    
    fun `parse`(`input`: kotlin.String): InputType
    
    fun `payOnchain`(`req`: PayOnchainRequest): SendPaymentResponse
    
    fun `prepareBuyBitcoin`(`req`: PrepareBuyBitcoinRequest): PrepareBuyBitcoinResponse
    
    fun `prepareLnurlPay`(`req`: PrepareLnUrlPayRequest): PrepareLnUrlPayResponse
    
    fun `preparePayOnchain`(`req`: PreparePayOnchainRequest): PreparePayOnchainResponse
    
    fun `prepareReceivePayment`(`req`: PrepareReceiveRequest): PrepareReceiveResponse
    
    fun `prepareRefund`(`req`: PrepareRefundRequest): PrepareRefundResponse
    
    fun `prepareSendPayment`(`req`: PrepareSendRequest): PrepareSendResponse
    
    fun `receivePayment`(`req`: ReceivePaymentRequest): ReceivePaymentResponse
    
    fun `recommendedFees`(): RecommendedFees
    
    fun `refund`(`req`: RefundRequest): RefundResponse
    
    fun `registerWebhook`(`webhookUrl`: kotlin.String)
    
    fun `removeEventListener`(`id`: kotlin.String)
    
    fun `rescanOnchainSwaps`()
    
    fun `restore`(`req`: RestoreRequest)
    
    fun `sendPayment`(`req`: SendPaymentRequest): SendPaymentResponse
    
    fun `signMessage`(`req`: SignMessageRequest): SignMessageResponse
    
    fun `sync`()
    
    fun `unregisterWebhook`()
    
    companion object
}

open class BindingLiquidSdk: Disposable, AutoCloseable, BindingLiquidSdkInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_free_bindingliquidsdk(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_clone_bindingliquidsdk(pointer!!, status)
        }
    }

    
    @Throws(PaymentException::class)override fun `acceptPaymentProposedFees`(`req`: AcceptPaymentProposedFeesRequest)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_accept_payment_proposed_fees(
        it, FfiConverterTypeAcceptPaymentProposedFeesRequest.lower(`req`),_status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `addEventListener`(`listener`: EventListener): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_add_event_listener(
        it, FfiConverterTypeEventListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `backup`(`req`: BackupRequest)
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_backup(
        it, FfiConverterTypeBackupRequest.lower(`req`),_status)
}
    }
    
    

    
    @Throws(PaymentException::class)override fun `buyBitcoin`(`req`: BuyBitcoinRequest): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_buy_bitcoin(
        it, FfiConverterTypeBuyBitcoinRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `checkMessage`(`req`: CheckMessageRequest): CheckMessageResponse {
            return FfiConverterTypeCheckMessageResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_check_message(
        it, FfiConverterTypeCheckMessageRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `createBolt12Invoice`(`req`: CreateBolt12InvoiceRequest): CreateBolt12InvoiceResponse {
            return FfiConverterTypeCreateBolt12InvoiceResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_create_bolt12_invoice(
        it, FfiConverterTypeCreateBolt12InvoiceRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `disconnect`()
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_disconnect(
        it, _status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `fetchFiatRates`(): List<Rate> {
            return FfiConverterSequenceTypeRate.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_fiat_rates(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `fetchLightningLimits`(): LightningPaymentLimitsResponse {
            return FfiConverterTypeLightningPaymentLimitsResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_lightning_limits(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `fetchOnchainLimits`(): OnchainPaymentLimitsResponse {
            return FfiConverterTypeOnchainPaymentLimitsResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_onchain_limits(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `fetchPaymentProposedFees`(`req`: FetchPaymentProposedFeesRequest): FetchPaymentProposedFeesResponse {
            return FfiConverterTypeFetchPaymentProposedFeesResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_fetch_payment_proposed_fees(
        it, FfiConverterTypeFetchPaymentProposedFeesRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `getInfo`(): GetInfoResponse {
            return FfiConverterTypeGetInfoResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_info(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `getPayment`(`req`: GetPaymentRequest): Payment? {
            return FfiConverterOptionalTypePayment.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_get_payment(
        it, FfiConverterTypeGetPaymentRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `listFiatCurrencies`(): List<FiatCurrency> {
            return FfiConverterSequenceTypeFiatCurrency.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_fiat_currencies(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `listPayments`(`req`: ListPaymentsRequest): List<Payment> {
            return FfiConverterSequenceTypePayment.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_payments(
        it, FfiConverterTypeListPaymentsRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `listRefundables`(): List<RefundableSwap> {
            return FfiConverterSequenceTypeRefundableSwap.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_list_refundables(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(LnUrlAuthException::class)override fun `lnurlAuth`(`reqData`: LnUrlAuthRequestData): LnUrlCallbackStatus {
            return FfiConverterTypeLnUrlCallbackStatus.lift(
    callWithPointer {
    uniffiRustCallWithError(LnUrlAuthException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_auth(
        it, FfiConverterTypeLnUrlAuthRequestData.lower(`reqData`),_status)
}
    }
    )
    }
    

    
    @Throws(LnUrlPayException::class)override fun `lnurlPay`(`req`: LnUrlPayRequest): LnUrlPayResult {
            return FfiConverterTypeLnUrlPayResult.lift(
    callWithPointer {
    uniffiRustCallWithError(LnUrlPayException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_pay(
        it, FfiConverterTypeLnUrlPayRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(LnUrlWithdrawException::class)override fun `lnurlWithdraw`(`req`: LnUrlWithdrawRequest): LnUrlWithdrawResult {
            return FfiConverterTypeLnUrlWithdrawResult.lift(
    callWithPointer {
    uniffiRustCallWithError(LnUrlWithdrawException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_lnurl_withdraw(
        it, FfiConverterTypeLnUrlWithdrawRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `parse`(`input`: kotlin.String): InputType {
            return FfiConverterTypeInputType.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_parse(
        it, FfiConverterString.lower(`input`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `payOnchain`(`req`: PayOnchainRequest): SendPaymentResponse {
            return FfiConverterTypeSendPaymentResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_pay_onchain(
        it, FfiConverterTypePayOnchainRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `prepareBuyBitcoin`(`req`: PrepareBuyBitcoinRequest): PrepareBuyBitcoinResponse {
            return FfiConverterTypePrepareBuyBitcoinResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_buy_bitcoin(
        it, FfiConverterTypePrepareBuyBitcoinRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(LnUrlPayException::class)override fun `prepareLnurlPay`(`req`: PrepareLnUrlPayRequest): PrepareLnUrlPayResponse {
            return FfiConverterTypePrepareLnUrlPayResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(LnUrlPayException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_lnurl_pay(
        it, FfiConverterTypePrepareLnUrlPayRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `preparePayOnchain`(`req`: PreparePayOnchainRequest): PreparePayOnchainResponse {
            return FfiConverterTypePreparePayOnchainResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_pay_onchain(
        it, FfiConverterTypePreparePayOnchainRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `prepareReceivePayment`(`req`: PrepareReceiveRequest): PrepareReceiveResponse {
            return FfiConverterTypePrepareReceiveResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_receive_payment(
        it, FfiConverterTypePrepareReceiveRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `prepareRefund`(`req`: PrepareRefundRequest): PrepareRefundResponse {
            return FfiConverterTypePrepareRefundResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_refund(
        it, FfiConverterTypePrepareRefundRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `prepareSendPayment`(`req`: PrepareSendRequest): PrepareSendResponse {
            return FfiConverterTypePrepareSendResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_prepare_send_payment(
        it, FfiConverterTypePrepareSendRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `receivePayment`(`req`: ReceivePaymentRequest): ReceivePaymentResponse {
            return FfiConverterTypeReceivePaymentResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_receive_payment(
        it, FfiConverterTypeReceivePaymentRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `recommendedFees`(): RecommendedFees {
            return FfiConverterTypeRecommendedFees.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_recommended_fees(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(PaymentException::class)override fun `refund`(`req`: RefundRequest): RefundResponse {
            return FfiConverterTypeRefundResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_refund(
        it, FfiConverterTypeRefundRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `registerWebhook`(`webhookUrl`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_register_webhook(
        it, FfiConverterString.lower(`webhookUrl`),_status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `removeEventListener`(`id`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_remove_event_listener(
        it, FfiConverterString.lower(`id`),_status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `rescanOnchainSwaps`()
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_rescan_onchain_swaps(
        it, _status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `restore`(`req`: RestoreRequest)
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_restore(
        it, FfiConverterTypeRestoreRequest.lower(`req`),_status)
}
    }
    
    

    
    @Throws(PaymentException::class)override fun `sendPayment`(`req`: SendPaymentRequest): SendPaymentResponse {
            return FfiConverterTypeSendPaymentResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_send_payment(
        it, FfiConverterTypeSendPaymentRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `signMessage`(`req`: SignMessageRequest): SignMessageResponse {
            return FfiConverterTypeSignMessageResponse.lift(
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sign_message(
        it, FfiConverterTypeSignMessageRequest.lower(`req`),_status)
}
    }
    )
    }
    

    
    @Throws(SdkException::class)override fun `sync`()
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_sync(
        it, _status)
}
    }
    
    

    
    @Throws(SdkException::class)override fun `unregisterWebhook`()
        = 
    callWithPointer {
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_bindingliquidsdk_unregister_webhook(
        it, _status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeBindingLiquidSdk: FfiConverter<BindingLiquidSdk, Pointer> {

    override fun lower(value: BindingLiquidSdk): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): BindingLiquidSdk {
        return BindingLiquidSdk(value)
    }

    override fun read(buf: ByteBuffer): BindingLiquidSdk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: BindingLiquidSdk) = 8UL

    override fun write(value: BindingLiquidSdk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PluginEventEmitterInterface {
    
    fun `broadcast`(`event`: SdkEvent)
    
    companion object
}

open class PluginEventEmitter: Disposable, AutoCloseable, PluginEventEmitterInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_free_plugineventemitter(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_clone_plugineventemitter(pointer!!, status)
        }
    }

    override fun `broadcast`(`event`: SdkEvent)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_plugineventemitter_broadcast(
        it, FfiConverterTypeSdkEvent.lower(`event`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePluginEventEmitter: FfiConverter<PluginEventEmitter, Pointer> {

    override fun lower(value: PluginEventEmitter): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PluginEventEmitter {
        return PluginEventEmitter(value)
    }

    override fun read(buf: ByteBuffer): PluginEventEmitter {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PluginEventEmitter) = 8UL

    override fun write(value: PluginEventEmitter, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PluginStorageInterface {
    
    fun `getItem`(`key`: kotlin.String): kotlin.String?
    
    fun `removeItem`(`key`: kotlin.String)
    
    fun `setItem`(`key`: kotlin.String, `value`: kotlin.String)
    
    companion object
}

open class PluginStorage: Disposable, AutoCloseable, PluginStorageInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_free_pluginstorage(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_clone_pluginstorage(pointer!!, status)
        }
    }

    
    @Throws(PluginStorageException::class)override fun `getItem`(`key`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PluginStorageException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_get_item(
        it, FfiConverterString.lower(`key`),_status)
}
    }
    )
    }
    

    
    @Throws(PluginStorageException::class)override fun `removeItem`(`key`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PluginStorageException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_remove_item(
        it, FfiConverterString.lower(`key`),_status)
}
    }
    
    

    
    @Throws(PluginStorageException::class)override fun `setItem`(`key`: kotlin.String, `value`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PluginStorageException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_method_pluginstorage_set_item(
        it, FfiConverterString.lower(`key`),FfiConverterString.lower(`value`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePluginStorage: FfiConverter<PluginStorage, Pointer> {

    override fun lower(value: PluginStorage): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PluginStorage {
        return PluginStorage(value)
    }

    override fun read(buf: ByteBuffer): PluginStorage {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PluginStorage) = 8UL

    override fun write(value: PluginStorage, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



data class AcceptPaymentProposedFeesRequest (
    var `response`: FetchPaymentProposedFeesResponse
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAcceptPaymentProposedFeesRequest: FfiConverterRustBuffer<AcceptPaymentProposedFeesRequest> {
    override fun read(buf: ByteBuffer): AcceptPaymentProposedFeesRequest {
        return AcceptPaymentProposedFeesRequest(
            FfiConverterTypeFetchPaymentProposedFeesResponse.read(buf),
        )
    }

    override fun allocationSize(value: AcceptPaymentProposedFeesRequest) = (
            FfiConverterTypeFetchPaymentProposedFeesResponse.allocationSize(value.`response`)
    )

    override fun write(value: AcceptPaymentProposedFeesRequest, buf: ByteBuffer) {
            FfiConverterTypeFetchPaymentProposedFeesResponse.write(value.`response`, buf)
    }
}



data class AesSuccessActionData (
    var `description`: kotlin.String, 
    var `ciphertext`: kotlin.String, 
    var `iv`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAesSuccessActionData: FfiConverterRustBuffer<AesSuccessActionData> {
    override fun read(buf: ByteBuffer): AesSuccessActionData {
        return AesSuccessActionData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AesSuccessActionData) = (
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterString.allocationSize(value.`ciphertext`) +
            FfiConverterString.allocationSize(value.`iv`)
    )

    override fun write(value: AesSuccessActionData, buf: ByteBuffer) {
            FfiConverterString.write(value.`description`, buf)
            FfiConverterString.write(value.`ciphertext`, buf)
            FfiConverterString.write(value.`iv`, buf)
    }
}



data class AesSuccessActionDataDecrypted (
    var `description`: kotlin.String, 
    var `plaintext`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer<AesSuccessActionDataDecrypted> {
    override fun read(buf: ByteBuffer): AesSuccessActionDataDecrypted {
        return AesSuccessActionDataDecrypted(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AesSuccessActionDataDecrypted) = (
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterString.allocationSize(value.`plaintext`)
    )

    override fun write(value: AesSuccessActionDataDecrypted, buf: ByteBuffer) {
            FfiConverterString.write(value.`description`, buf)
            FfiConverterString.write(value.`plaintext`, buf)
    }
}



data class AssetBalance (
    var `assetId`: kotlin.String, 
    var `balanceSat`: kotlin.ULong, 
    var `name`: kotlin.String?, 
    var `ticker`: kotlin.String?, 
    var `balance`: kotlin.Double?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetBalance: FfiConverterRustBuffer<AssetBalance> {
    override fun read(buf: ByteBuffer): AssetBalance {
        return AssetBalance(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalDouble.read(buf),
        )
    }

    override fun allocationSize(value: AssetBalance) = (
            FfiConverterString.allocationSize(value.`assetId`) +
            FfiConverterULong.allocationSize(value.`balanceSat`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`ticker`) +
            FfiConverterOptionalDouble.allocationSize(value.`balance`)
    )

    override fun write(value: AssetBalance, buf: ByteBuffer) {
            FfiConverterString.write(value.`assetId`, buf)
            FfiConverterULong.write(value.`balanceSat`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`ticker`, buf)
            FfiConverterOptionalDouble.write(value.`balance`, buf)
    }
}



data class AssetInfo (
    var `name`: kotlin.String, 
    var `ticker`: kotlin.String, 
    var `amount`: kotlin.Double, 
    var `fees`: kotlin.Double?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetInfo: FfiConverterRustBuffer<AssetInfo> {
    override fun read(buf: ByteBuffer): AssetInfo {
        return AssetInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterOptionalDouble.read(buf),
        )
    }

    override fun allocationSize(value: AssetInfo) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`ticker`) +
            FfiConverterDouble.allocationSize(value.`amount`) +
            FfiConverterOptionalDouble.allocationSize(value.`fees`)
    )

    override fun write(value: AssetInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`ticker`, buf)
            FfiConverterDouble.write(value.`amount`, buf)
            FfiConverterOptionalDouble.write(value.`fees`, buf)
    }
}



data class AssetMetadata (
    var `assetId`: kotlin.String, 
    var `name`: kotlin.String, 
    var `ticker`: kotlin.String, 
    var `precision`: kotlin.UByte, 
    var `fiatId`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetMetadata: FfiConverterRustBuffer<AssetMetadata> {
    override fun read(buf: ByteBuffer): AssetMetadata {
        return AssetMetadata(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: AssetMetadata) = (
            FfiConverterString.allocationSize(value.`assetId`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`ticker`) +
            FfiConverterUByte.allocationSize(value.`precision`) +
            FfiConverterOptionalString.allocationSize(value.`fiatId`)
    )

    override fun write(value: AssetMetadata, buf: ByteBuffer) {
            FfiConverterString.write(value.`assetId`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`ticker`, buf)
            FfiConverterUByte.write(value.`precision`, buf)
            FfiConverterOptionalString.write(value.`fiatId`, buf)
    }
}



data class BackupRequest (
    var `backupPath`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBackupRequest: FfiConverterRustBuffer<BackupRequest> {
    override fun read(buf: ByteBuffer): BackupRequest {
        return BackupRequest(
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: BackupRequest) = (
            FfiConverterOptionalString.allocationSize(value.`backupPath`)
    )

    override fun write(value: BackupRequest, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`backupPath`, buf)
    }
}



data class BitcoinAddressData (
    var `address`: kotlin.String, 
    var `network`: Network, 
    var `amountSat`: kotlin.ULong?, 
    var `label`: kotlin.String?, 
    var `message`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBitcoinAddressData: FfiConverterRustBuffer<BitcoinAddressData> {
    override fun read(buf: ByteBuffer): BitcoinAddressData {
        return BitcoinAddressData(
            FfiConverterString.read(buf),
            FfiConverterTypeNetwork.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: BitcoinAddressData) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`) +
            FfiConverterOptionalULong.allocationSize(value.`amountSat`) +
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterOptionalString.allocationSize(value.`message`)
    )

    override fun write(value: BitcoinAddressData, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
            FfiConverterOptionalULong.write(value.`amountSat`, buf)
            FfiConverterOptionalString.write(value.`label`, buf)
            FfiConverterOptionalString.write(value.`message`, buf)
    }
}



data class BlockchainInfo (
    var `liquidTip`: kotlin.UInt, 
    var `bitcoinTip`: kotlin.UInt
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBlockchainInfo: FfiConverterRustBuffer<BlockchainInfo> {
    override fun read(buf: ByteBuffer): BlockchainInfo {
        return BlockchainInfo(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: BlockchainInfo) = (
            FfiConverterUInt.allocationSize(value.`liquidTip`) +
            FfiConverterUInt.allocationSize(value.`bitcoinTip`)
    )

    override fun write(value: BlockchainInfo, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`liquidTip`, buf)
            FfiConverterUInt.write(value.`bitcoinTip`, buf)
    }
}



data class BuyBitcoinRequest (
    var `prepareResponse`: PrepareBuyBitcoinResponse, 
    var `redirectUrl`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBuyBitcoinRequest: FfiConverterRustBuffer<BuyBitcoinRequest> {
    override fun read(buf: ByteBuffer): BuyBitcoinRequest {
        return BuyBitcoinRequest(
            FfiConverterTypePrepareBuyBitcoinResponse.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: BuyBitcoinRequest) = (
            FfiConverterTypePrepareBuyBitcoinResponse.allocationSize(value.`prepareResponse`) +
            FfiConverterOptionalString.allocationSize(value.`redirectUrl`)
    )

    override fun write(value: BuyBitcoinRequest, buf: ByteBuffer) {
            FfiConverterTypePrepareBuyBitcoinResponse.write(value.`prepareResponse`, buf)
            FfiConverterOptionalString.write(value.`redirectUrl`, buf)
    }
}



data class CheckMessageRequest (
    var `message`: kotlin.String, 
    var `pubkey`: kotlin.String, 
    var `signature`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer<CheckMessageRequest> {
    override fun read(buf: ByteBuffer): CheckMessageRequest {
        return CheckMessageRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: CheckMessageRequest) = (
            FfiConverterString.allocationSize(value.`message`) +
            FfiConverterString.allocationSize(value.`pubkey`) +
            FfiConverterString.allocationSize(value.`signature`)
    )

    override fun write(value: CheckMessageRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`message`, buf)
            FfiConverterString.write(value.`pubkey`, buf)
            FfiConverterString.write(value.`signature`, buf)
    }
}



data class CheckMessageResponse (
    var `isValid`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer<CheckMessageResponse> {
    override fun read(buf: ByteBuffer): CheckMessageResponse {
        return CheckMessageResponse(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: CheckMessageResponse) = (
            FfiConverterBoolean.allocationSize(value.`isValid`)
    )

    override fun write(value: CheckMessageResponse, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`isValid`, buf)
    }
}



data class Config (
    var `liquidExplorer`: BlockchainExplorer, 
    var `bitcoinExplorer`: BlockchainExplorer, 
    var `workingDir`: kotlin.String, 
    var `network`: LiquidNetwork, 
    var `paymentTimeoutSec`: kotlin.ULong, 
    var `syncServiceUrl`: kotlin.String?, 
    var `breezApiKey`: kotlin.String?, 
    var `zeroConfMaxAmountSat`: kotlin.ULong?, 
    var `useDefaultExternalInputParsers`: kotlin.Boolean = true, 
    var `useMagicRoutingHints`: kotlin.Boolean = true, 
    var `externalInputParsers`: List<ExternalInputParser>? = null, 
    var `onchainFeeRateLeewaySat`: kotlin.ULong? = null, 
    var `assetMetadata`: List<AssetMetadata>? = null, 
    var `sideswapApiKey`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConfig: FfiConverterRustBuffer<Config> {
    override fun read(buf: ByteBuffer): Config {
        return Config(
            FfiConverterTypeBlockchainExplorer.read(buf),
            FfiConverterTypeBlockchainExplorer.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeLiquidNetwork.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalSequenceTypeExternalInputParser.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalSequenceTypeAssetMetadata.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: Config) = (
            FfiConverterTypeBlockchainExplorer.allocationSize(value.`liquidExplorer`) +
            FfiConverterTypeBlockchainExplorer.allocationSize(value.`bitcoinExplorer`) +
            FfiConverterString.allocationSize(value.`workingDir`) +
            FfiConverterTypeLiquidNetwork.allocationSize(value.`network`) +
            FfiConverterULong.allocationSize(value.`paymentTimeoutSec`) +
            FfiConverterOptionalString.allocationSize(value.`syncServiceUrl`) +
            FfiConverterOptionalString.allocationSize(value.`breezApiKey`) +
            FfiConverterOptionalULong.allocationSize(value.`zeroConfMaxAmountSat`) +
            FfiConverterBoolean.allocationSize(value.`useDefaultExternalInputParsers`) +
            FfiConverterBoolean.allocationSize(value.`useMagicRoutingHints`) +
            FfiConverterOptionalSequenceTypeExternalInputParser.allocationSize(value.`externalInputParsers`) +
            FfiConverterOptionalULong.allocationSize(value.`onchainFeeRateLeewaySat`) +
            FfiConverterOptionalSequenceTypeAssetMetadata.allocationSize(value.`assetMetadata`) +
            FfiConverterOptionalString.allocationSize(value.`sideswapApiKey`)
    )

    override fun write(value: Config, buf: ByteBuffer) {
            FfiConverterTypeBlockchainExplorer.write(value.`liquidExplorer`, buf)
            FfiConverterTypeBlockchainExplorer.write(value.`bitcoinExplorer`, buf)
            FfiConverterString.write(value.`workingDir`, buf)
            FfiConverterTypeLiquidNetwork.write(value.`network`, buf)
            FfiConverterULong.write(value.`paymentTimeoutSec`, buf)
            FfiConverterOptionalString.write(value.`syncServiceUrl`, buf)
            FfiConverterOptionalString.write(value.`breezApiKey`, buf)
            FfiConverterOptionalULong.write(value.`zeroConfMaxAmountSat`, buf)
            FfiConverterBoolean.write(value.`useDefaultExternalInputParsers`, buf)
            FfiConverterBoolean.write(value.`useMagicRoutingHints`, buf)
            FfiConverterOptionalSequenceTypeExternalInputParser.write(value.`externalInputParsers`, buf)
            FfiConverterOptionalULong.write(value.`onchainFeeRateLeewaySat`, buf)
            FfiConverterOptionalSequenceTypeAssetMetadata.write(value.`assetMetadata`, buf)
            FfiConverterOptionalString.write(value.`sideswapApiKey`, buf)
    }
}



data class ConnectRequest (
    var `config`: Config, 
    var `mnemonic`: kotlin.String? = null, 
    var `passphrase`: kotlin.String? = null, 
    var `seed`: List<kotlin.UByte>? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectRequest: FfiConverterRustBuffer<ConnectRequest> {
    override fun read(buf: ByteBuffer): ConnectRequest {
        return ConnectRequest(
            FfiConverterTypeConfig.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ConnectRequest) = (
            FfiConverterTypeConfig.allocationSize(value.`config`) +
            FfiConverterOptionalString.allocationSize(value.`mnemonic`) +
            FfiConverterOptionalString.allocationSize(value.`passphrase`) +
            FfiConverterOptionalSequenceUByte.allocationSize(value.`seed`)
    )

    override fun write(value: ConnectRequest, buf: ByteBuffer) {
            FfiConverterTypeConfig.write(value.`config`, buf)
            FfiConverterOptionalString.write(value.`mnemonic`, buf)
            FfiConverterOptionalString.write(value.`passphrase`, buf)
            FfiConverterOptionalSequenceUByte.write(value.`seed`, buf)
    }
}



data class ConnectWithSignerRequest (
    var `config`: Config
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectWithSignerRequest: FfiConverterRustBuffer<ConnectWithSignerRequest> {
    override fun read(buf: ByteBuffer): ConnectWithSignerRequest {
        return ConnectWithSignerRequest(
            FfiConverterTypeConfig.read(buf),
        )
    }

    override fun allocationSize(value: ConnectWithSignerRequest) = (
            FfiConverterTypeConfig.allocationSize(value.`config`)
    )

    override fun write(value: ConnectWithSignerRequest, buf: ByteBuffer) {
            FfiConverterTypeConfig.write(value.`config`, buf)
    }
}



data class CreateBolt12InvoiceRequest (
    var `offer`: kotlin.String, 
    var `invoiceRequest`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCreateBolt12InvoiceRequest: FfiConverterRustBuffer<CreateBolt12InvoiceRequest> {
    override fun read(buf: ByteBuffer): CreateBolt12InvoiceRequest {
        return CreateBolt12InvoiceRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: CreateBolt12InvoiceRequest) = (
            FfiConverterString.allocationSize(value.`offer`) +
            FfiConverterString.allocationSize(value.`invoiceRequest`)
    )

    override fun write(value: CreateBolt12InvoiceRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`offer`, buf)
            FfiConverterString.write(value.`invoiceRequest`, buf)
    }
}



data class CreateBolt12InvoiceResponse (
    var `invoice`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCreateBolt12InvoiceResponse: FfiConverterRustBuffer<CreateBolt12InvoiceResponse> {
    override fun read(buf: ByteBuffer): CreateBolt12InvoiceResponse {
        return CreateBolt12InvoiceResponse(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: CreateBolt12InvoiceResponse) = (
            FfiConverterString.allocationSize(value.`invoice`)
    )

    override fun write(value: CreateBolt12InvoiceResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`invoice`, buf)
    }
}



data class CurrencyInfo (
    var `name`: kotlin.String, 
    var `fractionSize`: kotlin.UInt, 
    var `spacing`: kotlin.UInt?, 
    var `symbol`: Symbol?, 
    var `uniqSymbol`: Symbol?, 
    var `localizedName`: List<LocalizedName>, 
    var `localeOverrides`: List<LocaleOverrides>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer<CurrencyInfo> {
    override fun read(buf: ByteBuffer): CurrencyInfo {
        return CurrencyInfo(
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterOptionalTypeSymbol.read(buf),
            FfiConverterOptionalTypeSymbol.read(buf),
            FfiConverterSequenceTypeLocalizedName.read(buf),
            FfiConverterSequenceTypeLocaleOverrides.read(buf),
        )
    }

    override fun allocationSize(value: CurrencyInfo) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterUInt.allocationSize(value.`fractionSize`) +
            FfiConverterOptionalUInt.allocationSize(value.`spacing`) +
            FfiConverterOptionalTypeSymbol.allocationSize(value.`symbol`) +
            FfiConverterOptionalTypeSymbol.allocationSize(value.`uniqSymbol`) +
            FfiConverterSequenceTypeLocalizedName.allocationSize(value.`localizedName`) +
            FfiConverterSequenceTypeLocaleOverrides.allocationSize(value.`localeOverrides`)
    )

    override fun write(value: CurrencyInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterUInt.write(value.`fractionSize`, buf)
            FfiConverterOptionalUInt.write(value.`spacing`, buf)
            FfiConverterOptionalTypeSymbol.write(value.`symbol`, buf)
            FfiConverterOptionalTypeSymbol.write(value.`uniqSymbol`, buf)
            FfiConverterSequenceTypeLocalizedName.write(value.`localizedName`, buf)
            FfiConverterSequenceTypeLocaleOverrides.write(value.`localeOverrides`, buf)
    }
}



data class ExternalInputParser (
    var `providerId`: kotlin.String, 
    var `inputRegex`: kotlin.String, 
    var `parserUrl`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeExternalInputParser: FfiConverterRustBuffer<ExternalInputParser> {
    override fun read(buf: ByteBuffer): ExternalInputParser {
        return ExternalInputParser(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ExternalInputParser) = (
            FfiConverterString.allocationSize(value.`providerId`) +
            FfiConverterString.allocationSize(value.`inputRegex`) +
            FfiConverterString.allocationSize(value.`parserUrl`)
    )

    override fun write(value: ExternalInputParser, buf: ByteBuffer) {
            FfiConverterString.write(value.`providerId`, buf)
            FfiConverterString.write(value.`inputRegex`, buf)
            FfiConverterString.write(value.`parserUrl`, buf)
    }
}



data class FetchPaymentProposedFeesRequest (
    var `swapId`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFetchPaymentProposedFeesRequest: FfiConverterRustBuffer<FetchPaymentProposedFeesRequest> {
    override fun read(buf: ByteBuffer): FetchPaymentProposedFeesRequest {
        return FetchPaymentProposedFeesRequest(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: FetchPaymentProposedFeesRequest) = (
            FfiConverterString.allocationSize(value.`swapId`)
    )

    override fun write(value: FetchPaymentProposedFeesRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`swapId`, buf)
    }
}



data class FetchPaymentProposedFeesResponse (
    var `swapId`: kotlin.String, 
    var `feesSat`: kotlin.ULong, 
    var `payerAmountSat`: kotlin.ULong, 
    var `receiverAmountSat`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFetchPaymentProposedFeesResponse: FfiConverterRustBuffer<FetchPaymentProposedFeesResponse> {
    override fun read(buf: ByteBuffer): FetchPaymentProposedFeesResponse {
        return FetchPaymentProposedFeesResponse(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: FetchPaymentProposedFeesResponse) = (
            FfiConverterString.allocationSize(value.`swapId`) +
            FfiConverterULong.allocationSize(value.`feesSat`) +
            FfiConverterULong.allocationSize(value.`payerAmountSat`) +
            FfiConverterULong.allocationSize(value.`receiverAmountSat`)
    )

    override fun write(value: FetchPaymentProposedFeesResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`swapId`, buf)
            FfiConverterULong.write(value.`feesSat`, buf)
            FfiConverterULong.write(value.`payerAmountSat`, buf)
            FfiConverterULong.write(value.`receiverAmountSat`, buf)
    }
}



data class FiatCurrency (
    var `id`: kotlin.String, 
    var `info`: CurrencyInfo
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFiatCurrency: FfiConverterRustBuffer<FiatCurrency> {
    override fun read(buf: ByteBuffer): FiatCurrency {
        return FiatCurrency(
            FfiConverterString.read(buf),
            FfiConverterTypeCurrencyInfo.read(buf),
        )
    }

    override fun allocationSize(value: FiatCurrency) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterTypeCurrencyInfo.allocationSize(value.`info`)
    )

    override fun write(value: FiatCurrency, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterTypeCurrencyInfo.write(value.`info`, buf)
    }
}



data class GetInfoResponse (
    var `walletInfo`: WalletInfo, 
    var `blockchainInfo`: BlockchainInfo
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer<GetInfoResponse> {
    override fun read(buf: ByteBuffer): GetInfoResponse {
        return GetInfoResponse(
            FfiConverterTypeWalletInfo.read(buf),
            FfiConverterTypeBlockchainInfo.read(buf),
        )
    }

    override fun allocationSize(value: GetInfoResponse) = (
            FfiConverterTypeWalletInfo.allocationSize(value.`walletInfo`) +
            FfiConverterTypeBlockchainInfo.allocationSize(value.`blockchainInfo`)
    )

    override fun write(value: GetInfoResponse, buf: ByteBuffer) {
            FfiConverterTypeWalletInfo.write(value.`walletInfo`, buf)
            FfiConverterTypeBlockchainInfo.write(value.`blockchainInfo`, buf)
    }
}



/**
 * ///////////////////////////////
 */
data class LnInvoice (
    var `bolt11`: kotlin.String, 
    var `network`: Network, 
    var `payeePubkey`: kotlin.String, 
    var `paymentHash`: kotlin.String, 
    var `description`: kotlin.String?, 
    var `descriptionHash`: kotlin.String?, 
    var `amountMsat`: kotlin.ULong?, 
    var `timestamp`: kotlin.ULong, 
    var `expiry`: kotlin.ULong, 
    var `routingHints`: List<RouteHint>, 
    var `paymentSecret`: List<kotlin.UByte>, 
    var `minFinalCltvExpiryDelta`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLNInvoice: FfiConverterRustBuffer<LnInvoice> {
    override fun read(buf: ByteBuffer): LnInvoice {
        return LnInvoice(
            FfiConverterString.read(buf),
            FfiConverterTypeNetwork.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceTypeRouteHint.read(buf),
            FfiConverterSequenceUByte.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: LnInvoice) = (
            FfiConverterString.allocationSize(value.`bolt11`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`) +
            FfiConverterString.allocationSize(value.`payeePubkey`) +
            FfiConverterString.allocationSize(value.`paymentHash`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalString.allocationSize(value.`descriptionHash`) +
            FfiConverterOptionalULong.allocationSize(value.`amountMsat`) +
            FfiConverterULong.allocationSize(value.`timestamp`) +
            FfiConverterULong.allocationSize(value.`expiry`) +
            FfiConverterSequenceTypeRouteHint.allocationSize(value.`routingHints`) +
            FfiConverterSequenceUByte.allocationSize(value.`paymentSecret`) +
            FfiConverterULong.allocationSize(value.`minFinalCltvExpiryDelta`)
    )

    override fun write(value: LnInvoice, buf: ByteBuffer) {
            FfiConverterString.write(value.`bolt11`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
            FfiConverterString.write(value.`payeePubkey`, buf)
            FfiConverterString.write(value.`paymentHash`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalString.write(value.`descriptionHash`, buf)
            FfiConverterOptionalULong.write(value.`amountMsat`, buf)
            FfiConverterULong.write(value.`timestamp`, buf)
            FfiConverterULong.write(value.`expiry`, buf)
            FfiConverterSequenceTypeRouteHint.write(value.`routingHints`, buf)
            FfiConverterSequenceUByte.write(value.`paymentSecret`, buf)
            FfiConverterULong.write(value.`minFinalCltvExpiryDelta`, buf)
    }
}



data class LnOffer (
    var `offer`: kotlin.String, 
    var `chains`: List<kotlin.String>, 
    var `paths`: List<LnOfferBlindedPath>, 
    var `description`: kotlin.String?, 
    var `signingPubkey`: kotlin.String?, 
    var `minAmount`: Amount?, 
    var `absoluteExpiry`: kotlin.ULong?, 
    var `issuer`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLNOffer: FfiConverterRustBuffer<LnOffer> {
    override fun read(buf: ByteBuffer): LnOffer {
        return LnOffer(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterSequenceTypeLnOfferBlindedPath.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeAmount.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LnOffer) = (
            FfiConverterString.allocationSize(value.`offer`) +
            FfiConverterSequenceString.allocationSize(value.`chains`) +
            FfiConverterSequenceTypeLnOfferBlindedPath.allocationSize(value.`paths`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalString.allocationSize(value.`signingPubkey`) +
            FfiConverterOptionalTypeAmount.allocationSize(value.`minAmount`) +
            FfiConverterOptionalULong.allocationSize(value.`absoluteExpiry`) +
            FfiConverterOptionalString.allocationSize(value.`issuer`)
    )

    override fun write(value: LnOffer, buf: ByteBuffer) {
            FfiConverterString.write(value.`offer`, buf)
            FfiConverterSequenceString.write(value.`chains`, buf)
            FfiConverterSequenceTypeLnOfferBlindedPath.write(value.`paths`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalString.write(value.`signingPubkey`, buf)
            FfiConverterOptionalTypeAmount.write(value.`minAmount`, buf)
            FfiConverterOptionalULong.write(value.`absoluteExpiry`, buf)
            FfiConverterOptionalString.write(value.`issuer`, buf)
    }
}



data class LightningPaymentLimitsResponse (
    var `send`: Limits, 
    var `receive`: Limits
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLightningPaymentLimitsResponse: FfiConverterRustBuffer<LightningPaymentLimitsResponse> {
    override fun read(buf: ByteBuffer): LightningPaymentLimitsResponse {
        return LightningPaymentLimitsResponse(
            FfiConverterTypeLimits.read(buf),
            FfiConverterTypeLimits.read(buf),
        )
    }

    override fun allocationSize(value: LightningPaymentLimitsResponse) = (
            FfiConverterTypeLimits.allocationSize(value.`send`) +
            FfiConverterTypeLimits.allocationSize(value.`receive`)
    )

    override fun write(value: LightningPaymentLimitsResponse, buf: ByteBuffer) {
            FfiConverterTypeLimits.write(value.`send`, buf)
            FfiConverterTypeLimits.write(value.`receive`, buf)
    }
}



data class Limits (
    var `minSat`: kotlin.ULong, 
    var `maxSat`: kotlin.ULong, 
    var `maxZeroConfSat`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLimits: FfiConverterRustBuffer<Limits> {
    override fun read(buf: ByteBuffer): Limits {
        return Limits(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: Limits) = (
            FfiConverterULong.allocationSize(value.`minSat`) +
            FfiConverterULong.allocationSize(value.`maxSat`) +
            FfiConverterULong.allocationSize(value.`maxZeroConfSat`)
    )

    override fun write(value: Limits, buf: ByteBuffer) {
            FfiConverterULong.write(value.`minSat`, buf)
            FfiConverterULong.write(value.`maxSat`, buf)
            FfiConverterULong.write(value.`maxZeroConfSat`, buf)
    }
}



data class LiquidAddressData (
    var `address`: kotlin.String, 
    var `network`: Network, 
    var `assetId`: kotlin.String?, 
    var `amount`: kotlin.Double?, 
    var `amountSat`: kotlin.ULong?, 
    var `label`: kotlin.String?, 
    var `message`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLiquidAddressData: FfiConverterRustBuffer<LiquidAddressData> {
    override fun read(buf: ByteBuffer): LiquidAddressData {
        return LiquidAddressData(
            FfiConverterString.read(buf),
            FfiConverterTypeNetwork.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalDouble.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LiquidAddressData) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`) +
            FfiConverterOptionalString.allocationSize(value.`assetId`) +
            FfiConverterOptionalDouble.allocationSize(value.`amount`) +
            FfiConverterOptionalULong.allocationSize(value.`amountSat`) +
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterOptionalString.allocationSize(value.`message`)
    )

    override fun write(value: LiquidAddressData, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
            FfiConverterOptionalString.write(value.`assetId`, buf)
            FfiConverterOptionalDouble.write(value.`amount`, buf)
            FfiConverterOptionalULong.write(value.`amountSat`, buf)
            FfiConverterOptionalString.write(value.`label`, buf)
            FfiConverterOptionalString.write(value.`message`, buf)
    }
}



data class ListPaymentsRequest (
    var `filters`: List<PaymentType>? = null, 
    var `states`: List<PaymentState>? = null, 
    var `fromTimestamp`: kotlin.Long? = null, 
    var `toTimestamp`: kotlin.Long? = null, 
    var `offset`: kotlin.UInt? = null, 
    var `limit`: kotlin.UInt? = null, 
    var `details`: ListPaymentDetails? = null, 
    var `sortAscending`: kotlin.Boolean? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer<ListPaymentsRequest> {
    override fun read(buf: ByteBuffer): ListPaymentsRequest {
        return ListPaymentsRequest(
            FfiConverterOptionalSequenceTypePaymentType.read(buf),
            FfiConverterOptionalSequenceTypePaymentState.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterOptionalTypeListPaymentDetails.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ListPaymentsRequest) = (
            FfiConverterOptionalSequenceTypePaymentType.allocationSize(value.`filters`) +
            FfiConverterOptionalSequenceTypePaymentState.allocationSize(value.`states`) +
            FfiConverterOptionalLong.allocationSize(value.`fromTimestamp`) +
            FfiConverterOptionalLong.allocationSize(value.`toTimestamp`) +
            FfiConverterOptionalUInt.allocationSize(value.`offset`) +
            FfiConverterOptionalUInt.allocationSize(value.`limit`) +
            FfiConverterOptionalTypeListPaymentDetails.allocationSize(value.`details`) +
            FfiConverterOptionalBoolean.allocationSize(value.`sortAscending`)
    )

    override fun write(value: ListPaymentsRequest, buf: ByteBuffer) {
            FfiConverterOptionalSequenceTypePaymentType.write(value.`filters`, buf)
            FfiConverterOptionalSequenceTypePaymentState.write(value.`states`, buf)
            FfiConverterOptionalLong.write(value.`fromTimestamp`, buf)
            FfiConverterOptionalLong.write(value.`toTimestamp`, buf)
            FfiConverterOptionalUInt.write(value.`offset`, buf)
            FfiConverterOptionalUInt.write(value.`limit`, buf)
            FfiConverterOptionalTypeListPaymentDetails.write(value.`details`, buf)
            FfiConverterOptionalBoolean.write(value.`sortAscending`, buf)
    }
}



data class LnOfferBlindedPath (
    var `blindedHops`: List<kotlin.String>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnOfferBlindedPath: FfiConverterRustBuffer<LnOfferBlindedPath> {
    override fun read(buf: ByteBuffer): LnOfferBlindedPath {
        return LnOfferBlindedPath(
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: LnOfferBlindedPath) = (
            FfiConverterSequenceString.allocationSize(value.`blindedHops`)
    )

    override fun write(value: LnOfferBlindedPath, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`blindedHops`, buf)
    }
}



data class LnUrlAuthRequestData (
    var `k1`: kotlin.String, 
    var `domain`: kotlin.String, 
    var `url`: kotlin.String, 
    var `action`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlAuthRequestData: FfiConverterRustBuffer<LnUrlAuthRequestData> {
    override fun read(buf: ByteBuffer): LnUrlAuthRequestData {
        return LnUrlAuthRequestData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlAuthRequestData) = (
            FfiConverterString.allocationSize(value.`k1`) +
            FfiConverterString.allocationSize(value.`domain`) +
            FfiConverterString.allocationSize(value.`url`) +
            FfiConverterOptionalString.allocationSize(value.`action`)
    )

    override fun write(value: LnUrlAuthRequestData, buf: ByteBuffer) {
            FfiConverterString.write(value.`k1`, buf)
            FfiConverterString.write(value.`domain`, buf)
            FfiConverterString.write(value.`url`, buf)
            FfiConverterOptionalString.write(value.`action`, buf)
    }
}



data class LnUrlErrorData (
    var `reason`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlErrorData: FfiConverterRustBuffer<LnUrlErrorData> {
    override fun read(buf: ByteBuffer): LnUrlErrorData {
        return LnUrlErrorData(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlErrorData) = (
            FfiConverterString.allocationSize(value.`reason`)
    )

    override fun write(value: LnUrlErrorData, buf: ByteBuffer) {
            FfiConverterString.write(value.`reason`, buf)
    }
}



data class LnUrlInfo (
    var `lnAddress`: kotlin.String?, 
    var `lnurlPayComment`: kotlin.String?, 
    var `lnurlPayDomain`: kotlin.String?, 
    var `lnurlPayMetadata`: kotlin.String?, 
    var `lnurlPaySuccessAction`: SuccessActionProcessed?, 
    var `lnurlPayUnprocessedSuccessAction`: SuccessAction?, 
    var `lnurlWithdrawEndpoint`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlInfo: FfiConverterRustBuffer<LnUrlInfo> {
    override fun read(buf: ByteBuffer): LnUrlInfo {
        return LnUrlInfo(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            FfiConverterOptionalTypeSuccessAction.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlInfo) = (
            FfiConverterOptionalString.allocationSize(value.`lnAddress`) +
            FfiConverterOptionalString.allocationSize(value.`lnurlPayComment`) +
            FfiConverterOptionalString.allocationSize(value.`lnurlPayDomain`) +
            FfiConverterOptionalString.allocationSize(value.`lnurlPayMetadata`) +
            FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(value.`lnurlPaySuccessAction`) +
            FfiConverterOptionalTypeSuccessAction.allocationSize(value.`lnurlPayUnprocessedSuccessAction`) +
            FfiConverterOptionalString.allocationSize(value.`lnurlWithdrawEndpoint`)
    )

    override fun write(value: LnUrlInfo, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`lnAddress`, buf)
            FfiConverterOptionalString.write(value.`lnurlPayComment`, buf)
            FfiConverterOptionalString.write(value.`lnurlPayDomain`, buf)
            FfiConverterOptionalString.write(value.`lnurlPayMetadata`, buf)
            FfiConverterOptionalTypeSuccessActionProcessed.write(value.`lnurlPaySuccessAction`, buf)
            FfiConverterOptionalTypeSuccessAction.write(value.`lnurlPayUnprocessedSuccessAction`, buf)
            FfiConverterOptionalString.write(value.`lnurlWithdrawEndpoint`, buf)
    }
}



data class LnUrlPayErrorData (
    var `paymentHash`: kotlin.String, 
    var `reason`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPayErrorData: FfiConverterRustBuffer<LnUrlPayErrorData> {
    override fun read(buf: ByteBuffer): LnUrlPayErrorData {
        return LnUrlPayErrorData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlPayErrorData) = (
            FfiConverterString.allocationSize(value.`paymentHash`) +
            FfiConverterString.allocationSize(value.`reason`)
    )

    override fun write(value: LnUrlPayErrorData, buf: ByteBuffer) {
            FfiConverterString.write(value.`paymentHash`, buf)
            FfiConverterString.write(value.`reason`, buf)
    }
}



data class LnUrlPayRequest (
    var `prepareResponse`: PrepareLnUrlPayResponse
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPayRequest: FfiConverterRustBuffer<LnUrlPayRequest> {
    override fun read(buf: ByteBuffer): LnUrlPayRequest {
        return LnUrlPayRequest(
            FfiConverterTypePrepareLnUrlPayResponse.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlPayRequest) = (
            FfiConverterTypePrepareLnUrlPayResponse.allocationSize(value.`prepareResponse`)
    )

    override fun write(value: LnUrlPayRequest, buf: ByteBuffer) {
            FfiConverterTypePrepareLnUrlPayResponse.write(value.`prepareResponse`, buf)
    }
}



data class LnUrlPayRequestData (
    var `callback`: kotlin.String, 
    var `minSendable`: kotlin.ULong, 
    var `maxSendable`: kotlin.ULong, 
    var `metadataStr`: kotlin.String, 
    var `commentAllowed`: kotlin.UShort, 
    var `domain`: kotlin.String, 
    var `allowsNostr`: kotlin.Boolean, 
    var `nostrPubkey`: kotlin.String?, 
    var `lnAddress`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer<LnUrlPayRequestData> {
    override fun read(buf: ByteBuffer): LnUrlPayRequestData {
        return LnUrlPayRequestData(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUShort.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlPayRequestData) = (
            FfiConverterString.allocationSize(value.`callback`) +
            FfiConverterULong.allocationSize(value.`minSendable`) +
            FfiConverterULong.allocationSize(value.`maxSendable`) +
            FfiConverterString.allocationSize(value.`metadataStr`) +
            FfiConverterUShort.allocationSize(value.`commentAllowed`) +
            FfiConverterString.allocationSize(value.`domain`) +
            FfiConverterBoolean.allocationSize(value.`allowsNostr`) +
            FfiConverterOptionalString.allocationSize(value.`nostrPubkey`) +
            FfiConverterOptionalString.allocationSize(value.`lnAddress`)
    )

    override fun write(value: LnUrlPayRequestData, buf: ByteBuffer) {
            FfiConverterString.write(value.`callback`, buf)
            FfiConverterULong.write(value.`minSendable`, buf)
            FfiConverterULong.write(value.`maxSendable`, buf)
            FfiConverterString.write(value.`metadataStr`, buf)
            FfiConverterUShort.write(value.`commentAllowed`, buf)
            FfiConverterString.write(value.`domain`, buf)
            FfiConverterBoolean.write(value.`allowsNostr`, buf)
            FfiConverterOptionalString.write(value.`nostrPubkey`, buf)
            FfiConverterOptionalString.write(value.`lnAddress`, buf)
    }
}



data class LnUrlPaySuccessData (
    var `successAction`: SuccessActionProcessed?, 
    var `payment`: Payment
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPaySuccessData: FfiConverterRustBuffer<LnUrlPaySuccessData> {
    override fun read(buf: ByteBuffer): LnUrlPaySuccessData {
        return LnUrlPaySuccessData(
            FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            FfiConverterTypePayment.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlPaySuccessData) = (
            FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(value.`successAction`) +
            FfiConverterTypePayment.allocationSize(value.`payment`)
    )

    override fun write(value: LnUrlPaySuccessData, buf: ByteBuffer) {
            FfiConverterOptionalTypeSuccessActionProcessed.write(value.`successAction`, buf)
            FfiConverterTypePayment.write(value.`payment`, buf)
    }
}



data class LnUrlWithdrawRequest (
    var `data`: LnUrlWithdrawRequestData, 
    var `amountMsat`: kotlin.ULong, 
    var `description`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlWithdrawRequest: FfiConverterRustBuffer<LnUrlWithdrawRequest> {
    override fun read(buf: ByteBuffer): LnUrlWithdrawRequest {
        return LnUrlWithdrawRequest(
            FfiConverterTypeLnUrlWithdrawRequestData.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlWithdrawRequest) = (
            FfiConverterTypeLnUrlWithdrawRequestData.allocationSize(value.`data`) +
            FfiConverterULong.allocationSize(value.`amountMsat`) +
            FfiConverterOptionalString.allocationSize(value.`description`)
    )

    override fun write(value: LnUrlWithdrawRequest, buf: ByteBuffer) {
            FfiConverterTypeLnUrlWithdrawRequestData.write(value.`data`, buf)
            FfiConverterULong.write(value.`amountMsat`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
    }
}



data class LnUrlWithdrawRequestData (
    var `callback`: kotlin.String, 
    var `k1`: kotlin.String, 
    var `defaultDescription`: kotlin.String, 
    var `minWithdrawable`: kotlin.ULong, 
    var `maxWithdrawable`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlWithdrawRequestData: FfiConverterRustBuffer<LnUrlWithdrawRequestData> {
    override fun read(buf: ByteBuffer): LnUrlWithdrawRequestData {
        return LnUrlWithdrawRequestData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlWithdrawRequestData) = (
            FfiConverterString.allocationSize(value.`callback`) +
            FfiConverterString.allocationSize(value.`k1`) +
            FfiConverterString.allocationSize(value.`defaultDescription`) +
            FfiConverterULong.allocationSize(value.`minWithdrawable`) +
            FfiConverterULong.allocationSize(value.`maxWithdrawable`)
    )

    override fun write(value: LnUrlWithdrawRequestData, buf: ByteBuffer) {
            FfiConverterString.write(value.`callback`, buf)
            FfiConverterString.write(value.`k1`, buf)
            FfiConverterString.write(value.`defaultDescription`, buf)
            FfiConverterULong.write(value.`minWithdrawable`, buf)
            FfiConverterULong.write(value.`maxWithdrawable`, buf)
    }
}



data class LnUrlWithdrawSuccessData (
    var `invoice`: LnInvoice
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlWithdrawSuccessData: FfiConverterRustBuffer<LnUrlWithdrawSuccessData> {
    override fun read(buf: ByteBuffer): LnUrlWithdrawSuccessData {
        return LnUrlWithdrawSuccessData(
            FfiConverterTypeLNInvoice.read(buf),
        )
    }

    override fun allocationSize(value: LnUrlWithdrawSuccessData) = (
            FfiConverterTypeLNInvoice.allocationSize(value.`invoice`)
    )

    override fun write(value: LnUrlWithdrawSuccessData, buf: ByteBuffer) {
            FfiConverterTypeLNInvoice.write(value.`invoice`, buf)
    }
}



data class LocaleOverrides (
    var `locale`: kotlin.String, 
    var `spacing`: kotlin.UInt?, 
    var `symbol`: Symbol
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer<LocaleOverrides> {
    override fun read(buf: ByteBuffer): LocaleOverrides {
        return LocaleOverrides(
            FfiConverterString.read(buf),
            FfiConverterOptionalUInt.read(buf),
            FfiConverterTypeSymbol.read(buf),
        )
    }

    override fun allocationSize(value: LocaleOverrides) = (
            FfiConverterString.allocationSize(value.`locale`) +
            FfiConverterOptionalUInt.allocationSize(value.`spacing`) +
            FfiConverterTypeSymbol.allocationSize(value.`symbol`)
    )

    override fun write(value: LocaleOverrides, buf: ByteBuffer) {
            FfiConverterString.write(value.`locale`, buf)
            FfiConverterOptionalUInt.write(value.`spacing`, buf)
            FfiConverterTypeSymbol.write(value.`symbol`, buf)
    }
}



data class LocalizedName (
    var `locale`: kotlin.String, 
    var `name`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLocalizedName: FfiConverterRustBuffer<LocalizedName> {
    override fun read(buf: ByteBuffer): LocalizedName {
        return LocalizedName(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LocalizedName) = (
            FfiConverterString.allocationSize(value.`locale`) +
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: LocalizedName, buf: ByteBuffer) {
            FfiConverterString.write(value.`locale`, buf)
            FfiConverterString.write(value.`name`, buf)
    }
}



data class LogEntry (
    var `line`: kotlin.String, 
    var `level`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLogEntry: FfiConverterRustBuffer<LogEntry> {
    override fun read(buf: ByteBuffer): LogEntry {
        return LogEntry(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LogEntry) = (
            FfiConverterString.allocationSize(value.`line`) +
            FfiConverterString.allocationSize(value.`level`)
    )

    override fun write(value: LogEntry, buf: ByteBuffer) {
            FfiConverterString.write(value.`line`, buf)
            FfiConverterString.write(value.`level`, buf)
    }
}



data class MessageSuccessActionData (
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer<MessageSuccessActionData> {
    override fun read(buf: ByteBuffer): MessageSuccessActionData {
        return MessageSuccessActionData(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MessageSuccessActionData) = (
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: MessageSuccessActionData, buf: ByteBuffer) {
            FfiConverterString.write(value.`message`, buf)
    }
}



data class OnchainPaymentLimitsResponse (
    var `send`: Limits, 
    var `receive`: Limits
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOnchainPaymentLimitsResponse: FfiConverterRustBuffer<OnchainPaymentLimitsResponse> {
    override fun read(buf: ByteBuffer): OnchainPaymentLimitsResponse {
        return OnchainPaymentLimitsResponse(
            FfiConverterTypeLimits.read(buf),
            FfiConverterTypeLimits.read(buf),
        )
    }

    override fun allocationSize(value: OnchainPaymentLimitsResponse) = (
            FfiConverterTypeLimits.allocationSize(value.`send`) +
            FfiConverterTypeLimits.allocationSize(value.`receive`)
    )

    override fun write(value: OnchainPaymentLimitsResponse, buf: ByteBuffer) {
            FfiConverterTypeLimits.write(value.`send`, buf)
            FfiConverterTypeLimits.write(value.`receive`, buf)
    }
}



data class PayOnchainRequest (
    var `address`: kotlin.String, 
    var `prepareResponse`: PreparePayOnchainResponse
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePayOnchainRequest: FfiConverterRustBuffer<PayOnchainRequest> {
    override fun read(buf: ByteBuffer): PayOnchainRequest {
        return PayOnchainRequest(
            FfiConverterString.read(buf),
            FfiConverterTypePreparePayOnchainResponse.read(buf),
        )
    }

    override fun allocationSize(value: PayOnchainRequest) = (
            FfiConverterString.allocationSize(value.`address`) +
            FfiConverterTypePreparePayOnchainResponse.allocationSize(value.`prepareResponse`)
    )

    override fun write(value: PayOnchainRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`address`, buf)
            FfiConverterTypePreparePayOnchainResponse.write(value.`prepareResponse`, buf)
    }
}



data class Payment (
    var `timestamp`: kotlin.UInt, 
    var `amountSat`: kotlin.ULong, 
    var `feesSat`: kotlin.ULong, 
    var `paymentType`: PaymentType, 
    var `status`: PaymentState, 
    var `details`: PaymentDetails, 
    var `swapperFeesSat`: kotlin.ULong? = null, 
    var `destination`: kotlin.String? = null, 
    var `txId`: kotlin.String? = null, 
    var `unblindingData`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePayment: FfiConverterRustBuffer<Payment> {
    override fun read(buf: ByteBuffer): Payment {
        return Payment(
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypePaymentType.read(buf),
            FfiConverterTypePaymentState.read(buf),
            FfiConverterTypePaymentDetails.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: Payment) = (
            FfiConverterUInt.allocationSize(value.`timestamp`) +
            FfiConverterULong.allocationSize(value.`amountSat`) +
            FfiConverterULong.allocationSize(value.`feesSat`) +
            FfiConverterTypePaymentType.allocationSize(value.`paymentType`) +
            FfiConverterTypePaymentState.allocationSize(value.`status`) +
            FfiConverterTypePaymentDetails.allocationSize(value.`details`) +
            FfiConverterOptionalULong.allocationSize(value.`swapperFeesSat`) +
            FfiConverterOptionalString.allocationSize(value.`destination`) +
            FfiConverterOptionalString.allocationSize(value.`txId`) +
            FfiConverterOptionalString.allocationSize(value.`unblindingData`)
    )

    override fun write(value: Payment, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`timestamp`, buf)
            FfiConverterULong.write(value.`amountSat`, buf)
            FfiConverterULong.write(value.`feesSat`, buf)
            FfiConverterTypePaymentType.write(value.`paymentType`, buf)
            FfiConverterTypePaymentState.write(value.`status`, buf)
            FfiConverterTypePaymentDetails.write(value.`details`, buf)
            FfiConverterOptionalULong.write(value.`swapperFeesSat`, buf)
            FfiConverterOptionalString.write(value.`destination`, buf)
            FfiConverterOptionalString.write(value.`txId`, buf)
            FfiConverterOptionalString.write(value.`unblindingData`, buf)
    }
}



data class PrepareBuyBitcoinRequest (
    var `provider`: BuyBitcoinProvider, 
    var `amountSat`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareBuyBitcoinRequest: FfiConverterRustBuffer<PrepareBuyBitcoinRequest> {
    override fun read(buf: ByteBuffer): PrepareBuyBitcoinRequest {
        return PrepareBuyBitcoinRequest(
            FfiConverterTypeBuyBitcoinProvider.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PrepareBuyBitcoinRequest) = (
            FfiConverterTypeBuyBitcoinProvider.allocationSize(value.`provider`) +
            FfiConverterULong.allocationSize(value.`amountSat`)
    )

    override fun write(value: PrepareBuyBitcoinRequest, buf: ByteBuffer) {
            FfiConverterTypeBuyBitcoinProvider.write(value.`provider`, buf)
            FfiConverterULong.write(value.`amountSat`, buf)
    }
}



data class PrepareBuyBitcoinResponse (
    var `provider`: BuyBitcoinProvider, 
    var `amountSat`: kotlin.ULong, 
    var `feesSat`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareBuyBitcoinResponse: FfiConverterRustBuffer<PrepareBuyBitcoinResponse> {
    override fun read(buf: ByteBuffer): PrepareBuyBitcoinResponse {
        return PrepareBuyBitcoinResponse(
            FfiConverterTypeBuyBitcoinProvider.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PrepareBuyBitcoinResponse) = (
            FfiConverterTypeBuyBitcoinProvider.allocationSize(value.`provider`) +
            FfiConverterULong.allocationSize(value.`amountSat`) +
            FfiConverterULong.allocationSize(value.`feesSat`)
    )

    override fun write(value: PrepareBuyBitcoinResponse, buf: ByteBuffer) {
            FfiConverterTypeBuyBitcoinProvider.write(value.`provider`, buf)
            FfiConverterULong.write(value.`amountSat`, buf)
            FfiConverterULong.write(value.`feesSat`, buf)
    }
}



data class PrepareLnUrlPayRequest (
    var `data`: LnUrlPayRequestData, 
    var `amount`: PayAmount, 
    var `bip353Address`: kotlin.String? = null, 
    var `comment`: kotlin.String? = null, 
    var `validateSuccessActionUrl`: kotlin.Boolean? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareLnUrlPayRequest: FfiConverterRustBuffer<PrepareLnUrlPayRequest> {
    override fun read(buf: ByteBuffer): PrepareLnUrlPayRequest {
        return PrepareLnUrlPayRequest(
            FfiConverterTypeLnUrlPayRequestData.read(buf),
            FfiConverterTypePayAmount.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: PrepareLnUrlPayRequest) = (
            FfiConverterTypeLnUrlPayRequestData.allocationSize(value.`data`) +
            FfiConverterTypePayAmount.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`bip353Address`) +
            FfiConverterOptionalString.allocationSize(value.`comment`) +
            FfiConverterOptionalBoolean.allocationSize(value.`validateSuccessActionUrl`)
    )

    override fun write(value: PrepareLnUrlPayRequest, buf: ByteBuffer) {
            FfiConverterTypeLnUrlPayRequestData.write(value.`data`, buf)
            FfiConverterTypePayAmount.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`bip353Address`, buf)
            FfiConverterOptionalString.write(value.`comment`, buf)
            FfiConverterOptionalBoolean.write(value.`validateSuccessActionUrl`, buf)
    }
}



data class PrepareLnUrlPayResponse (
    var `destination`: SendDestination, 
    var `feesSat`: kotlin.ULong, 
    var `data`: LnUrlPayRequestData, 
    var `amount`: PayAmount, 
    var `comment`: kotlin.String? = null, 
    var `successAction`: SuccessAction? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareLnUrlPayResponse: FfiConverterRustBuffer<PrepareLnUrlPayResponse> {
    override fun read(buf: ByteBuffer): PrepareLnUrlPayResponse {
        return PrepareLnUrlPayResponse(
            FfiConverterTypeSendDestination.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeLnUrlPayRequestData.read(buf),
            FfiConverterTypePayAmount.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeSuccessAction.read(buf),
        )
    }

    override fun allocationSize(value: PrepareLnUrlPayResponse) = (
            FfiConverterTypeSendDestination.allocationSize(value.`destination`) +
            FfiConverterULong.allocationSize(value.`feesSat`) +
            FfiConverterTypeLnUrlPayRequestData.allocationSize(value.`data`) +
            FfiConverterTypePayAmount.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`comment`) +
            FfiConverterOptionalTypeSuccessAction.allocationSize(value.`successAction`)
    )

    override fun write(value: PrepareLnUrlPayResponse, buf: ByteBuffer) {
            FfiConverterTypeSendDestination.write(value.`destination`, buf)
            FfiConverterULong.write(value.`feesSat`, buf)
            FfiConverterTypeLnUrlPayRequestData.write(value.`data`, buf)
            FfiConverterTypePayAmount.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`comment`, buf)
            FfiConverterOptionalTypeSuccessAction.write(value.`successAction`, buf)
    }
}



data class PreparePayOnchainRequest (
    var `amount`: PayAmount, 
    var `feeRateSatPerVbyte`: kotlin.UInt? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePreparePayOnchainRequest: FfiConverterRustBuffer<PreparePayOnchainRequest> {
    override fun read(buf: ByteBuffer): PreparePayOnchainRequest {
        return PreparePayOnchainRequest(
            FfiConverterTypePayAmount.read(buf),
            FfiConverterOptionalUInt.read(buf),
        )
    }

    override fun allocationSize(value: PreparePayOnchainRequest) = (
            FfiConverterTypePayAmount.allocationSize(value.`amount`) +
            FfiConverterOptionalUInt.allocationSize(value.`feeRateSatPerVbyte`)
    )

    override fun write(value: PreparePayOnchainRequest, buf: ByteBuffer) {
            FfiConverterTypePayAmount.write(value.`amount`, buf)
            FfiConverterOptionalUInt.write(value.`feeRateSatPerVbyte`, buf)
    }
}



data class PreparePayOnchainResponse (
    var `receiverAmountSat`: kotlin.ULong, 
    var `claimFeesSat`: kotlin.ULong, 
    var `totalFeesSat`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePreparePayOnchainResponse: FfiConverterRustBuffer<PreparePayOnchainResponse> {
    override fun read(buf: ByteBuffer): PreparePayOnchainResponse {
        return PreparePayOnchainResponse(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PreparePayOnchainResponse) = (
            FfiConverterULong.allocationSize(value.`receiverAmountSat`) +
            FfiConverterULong.allocationSize(value.`claimFeesSat`) +
            FfiConverterULong.allocationSize(value.`totalFeesSat`)
    )

    override fun write(value: PreparePayOnchainResponse, buf: ByteBuffer) {
            FfiConverterULong.write(value.`receiverAmountSat`, buf)
            FfiConverterULong.write(value.`claimFeesSat`, buf)
            FfiConverterULong.write(value.`totalFeesSat`, buf)
    }
}



data class PrepareReceiveRequest (
    var `paymentMethod`: PaymentMethod, 
    var `amount`: ReceiveAmount? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareReceiveRequest: FfiConverterRustBuffer<PrepareReceiveRequest> {
    override fun read(buf: ByteBuffer): PrepareReceiveRequest {
        return PrepareReceiveRequest(
            FfiConverterTypePaymentMethod.read(buf),
            FfiConverterOptionalTypeReceiveAmount.read(buf),
        )
    }

    override fun allocationSize(value: PrepareReceiveRequest) = (
            FfiConverterTypePaymentMethod.allocationSize(value.`paymentMethod`) +
            FfiConverterOptionalTypeReceiveAmount.allocationSize(value.`amount`)
    )

    override fun write(value: PrepareReceiveRequest, buf: ByteBuffer) {
            FfiConverterTypePaymentMethod.write(value.`paymentMethod`, buf)
            FfiConverterOptionalTypeReceiveAmount.write(value.`amount`, buf)
    }
}



data class PrepareReceiveResponse (
    var `paymentMethod`: PaymentMethod, 
    var `feesSat`: kotlin.ULong, 
    var `amount`: ReceiveAmount?, 
    var `minPayerAmountSat`: kotlin.ULong?, 
    var `maxPayerAmountSat`: kotlin.ULong?, 
    var `swapperFeerate`: kotlin.Double?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareReceiveResponse: FfiConverterRustBuffer<PrepareReceiveResponse> {
    override fun read(buf: ByteBuffer): PrepareReceiveResponse {
        return PrepareReceiveResponse(
            FfiConverterTypePaymentMethod.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalTypeReceiveAmount.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalDouble.read(buf),
        )
    }

    override fun allocationSize(value: PrepareReceiveResponse) = (
            FfiConverterTypePaymentMethod.allocationSize(value.`paymentMethod`) +
            FfiConverterULong.allocationSize(value.`feesSat`) +
            FfiConverterOptionalTypeReceiveAmount.allocationSize(value.`amount`) +
            FfiConverterOptionalULong.allocationSize(value.`minPayerAmountSat`) +
            FfiConverterOptionalULong.allocationSize(value.`maxPayerAmountSat`) +
            FfiConverterOptionalDouble.allocationSize(value.`swapperFeerate`)
    )

    override fun write(value: PrepareReceiveResponse, buf: ByteBuffer) {
            FfiConverterTypePaymentMethod.write(value.`paymentMethod`, buf)
            FfiConverterULong.write(value.`feesSat`, buf)
            FfiConverterOptionalTypeReceiveAmount.write(value.`amount`, buf)
            FfiConverterOptionalULong.write(value.`minPayerAmountSat`, buf)
            FfiConverterOptionalULong.write(value.`maxPayerAmountSat`, buf)
            FfiConverterOptionalDouble.write(value.`swapperFeerate`, buf)
    }
}



data class PrepareRefundRequest (
    var `swapAddress`: kotlin.String, 
    var `refundAddress`: kotlin.String, 
    var `feeRateSatPerVbyte`: kotlin.UInt
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareRefundRequest: FfiConverterRustBuffer<PrepareRefundRequest> {
    override fun read(buf: ByteBuffer): PrepareRefundRequest {
        return PrepareRefundRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: PrepareRefundRequest) = (
            FfiConverterString.allocationSize(value.`swapAddress`) +
            FfiConverterString.allocationSize(value.`refundAddress`) +
            FfiConverterUInt.allocationSize(value.`feeRateSatPerVbyte`)
    )

    override fun write(value: PrepareRefundRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`swapAddress`, buf)
            FfiConverterString.write(value.`refundAddress`, buf)
            FfiConverterUInt.write(value.`feeRateSatPerVbyte`, buf)
    }
}



data class PrepareRefundResponse (
    var `txVsize`: kotlin.UInt, 
    var `txFeeSat`: kotlin.ULong, 
    var `lastRefundTxId`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareRefundResponse: FfiConverterRustBuffer<PrepareRefundResponse> {
    override fun read(buf: ByteBuffer): PrepareRefundResponse {
        return PrepareRefundResponse(
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PrepareRefundResponse) = (
            FfiConverterUInt.allocationSize(value.`txVsize`) +
            FfiConverterULong.allocationSize(value.`txFeeSat`) +
            FfiConverterOptionalString.allocationSize(value.`lastRefundTxId`)
    )

    override fun write(value: PrepareRefundResponse, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`txVsize`, buf)
            FfiConverterULong.write(value.`txFeeSat`, buf)
            FfiConverterOptionalString.write(value.`lastRefundTxId`, buf)
    }
}



data class PrepareSendRequest (
    var `destination`: kotlin.String, 
    var `amount`: PayAmount? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareSendRequest: FfiConverterRustBuffer<PrepareSendRequest> {
    override fun read(buf: ByteBuffer): PrepareSendRequest {
        return PrepareSendRequest(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypePayAmount.read(buf),
        )
    }

    override fun allocationSize(value: PrepareSendRequest) = (
            FfiConverterString.allocationSize(value.`destination`) +
            FfiConverterOptionalTypePayAmount.allocationSize(value.`amount`)
    )

    override fun write(value: PrepareSendRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`destination`, buf)
            FfiConverterOptionalTypePayAmount.write(value.`amount`, buf)
    }
}



data class PrepareSendResponse (
    var `destination`: SendDestination, 
    var `amount`: PayAmount?, 
    var `feesSat`: kotlin.ULong?, 
    var `estimatedAssetFees`: kotlin.Double?, 
    var `exchangeAmountSat`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrepareSendResponse: FfiConverterRustBuffer<PrepareSendResponse> {
    override fun read(buf: ByteBuffer): PrepareSendResponse {
        return PrepareSendResponse(
            FfiConverterTypeSendDestination.read(buf),
            FfiConverterOptionalTypePayAmount.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalDouble.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: PrepareSendResponse) = (
            FfiConverterTypeSendDestination.allocationSize(value.`destination`) +
            FfiConverterOptionalTypePayAmount.allocationSize(value.`amount`) +
            FfiConverterOptionalULong.allocationSize(value.`feesSat`) +
            FfiConverterOptionalDouble.allocationSize(value.`estimatedAssetFees`) +
            FfiConverterOptionalULong.allocationSize(value.`exchangeAmountSat`)
    )

    override fun write(value: PrepareSendResponse, buf: ByteBuffer) {
            FfiConverterTypeSendDestination.write(value.`destination`, buf)
            FfiConverterOptionalTypePayAmount.write(value.`amount`, buf)
            FfiConverterOptionalULong.write(value.`feesSat`, buf)
            FfiConverterOptionalDouble.write(value.`estimatedAssetFees`, buf)
            FfiConverterOptionalULong.write(value.`exchangeAmountSat`, buf)
    }
}



data class Rate (
    var `coin`: kotlin.String, 
    var `value`: kotlin.Double
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRate: FfiConverterRustBuffer<Rate> {
    override fun read(buf: ByteBuffer): Rate {
        return Rate(
            FfiConverterString.read(buf),
            FfiConverterDouble.read(buf),
        )
    }

    override fun allocationSize(value: Rate) = (
            FfiConverterString.allocationSize(value.`coin`) +
            FfiConverterDouble.allocationSize(value.`value`)
    )

    override fun write(value: Rate, buf: ByteBuffer) {
            FfiConverterString.write(value.`coin`, buf)
            FfiConverterDouble.write(value.`value`, buf)
    }
}



data class ReceivePaymentRequest (
    var `prepareResponse`: PrepareReceiveResponse, 
    var `description`: kotlin.String? = null, 
    var `useDescriptionHash`: kotlin.Boolean? = null, 
    var `payerNote`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer<ReceivePaymentRequest> {
    override fun read(buf: ByteBuffer): ReceivePaymentRequest {
        return ReceivePaymentRequest(
            FfiConverterTypePrepareReceiveResponse.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ReceivePaymentRequest) = (
            FfiConverterTypePrepareReceiveResponse.allocationSize(value.`prepareResponse`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalBoolean.allocationSize(value.`useDescriptionHash`) +
            FfiConverterOptionalString.allocationSize(value.`payerNote`)
    )

    override fun write(value: ReceivePaymentRequest, buf: ByteBuffer) {
            FfiConverterTypePrepareReceiveResponse.write(value.`prepareResponse`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalBoolean.write(value.`useDescriptionHash`, buf)
            FfiConverterOptionalString.write(value.`payerNote`, buf)
    }
}



data class ReceivePaymentResponse (
    var `destination`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer<ReceivePaymentResponse> {
    override fun read(buf: ByteBuffer): ReceivePaymentResponse {
        return ReceivePaymentResponse(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ReceivePaymentResponse) = (
            FfiConverterString.allocationSize(value.`destination`)
    )

    override fun write(value: ReceivePaymentResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`destination`, buf)
    }
}



data class RecommendedFees (
    var `fastestFee`: kotlin.ULong, 
    var `halfHourFee`: kotlin.ULong, 
    var `hourFee`: kotlin.ULong, 
    var `economyFee`: kotlin.ULong, 
    var `minimumFee`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRecommendedFees: FfiConverterRustBuffer<RecommendedFees> {
    override fun read(buf: ByteBuffer): RecommendedFees {
        return RecommendedFees(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: RecommendedFees) = (
            FfiConverterULong.allocationSize(value.`fastestFee`) +
            FfiConverterULong.allocationSize(value.`halfHourFee`) +
            FfiConverterULong.allocationSize(value.`hourFee`) +
            FfiConverterULong.allocationSize(value.`economyFee`) +
            FfiConverterULong.allocationSize(value.`minimumFee`)
    )

    override fun write(value: RecommendedFees, buf: ByteBuffer) {
            FfiConverterULong.write(value.`fastestFee`, buf)
            FfiConverterULong.write(value.`halfHourFee`, buf)
            FfiConverterULong.write(value.`hourFee`, buf)
            FfiConverterULong.write(value.`economyFee`, buf)
            FfiConverterULong.write(value.`minimumFee`, buf)
    }
}



data class RefundRequest (
    var `swapAddress`: kotlin.String, 
    var `refundAddress`: kotlin.String, 
    var `feeRateSatPerVbyte`: kotlin.UInt
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRefundRequest: FfiConverterRustBuffer<RefundRequest> {
    override fun read(buf: ByteBuffer): RefundRequest {
        return RefundRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: RefundRequest) = (
            FfiConverterString.allocationSize(value.`swapAddress`) +
            FfiConverterString.allocationSize(value.`refundAddress`) +
            FfiConverterUInt.allocationSize(value.`feeRateSatPerVbyte`)
    )

    override fun write(value: RefundRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`swapAddress`, buf)
            FfiConverterString.write(value.`refundAddress`, buf)
            FfiConverterUInt.write(value.`feeRateSatPerVbyte`, buf)
    }
}



data class RefundResponse (
    var `refundTxId`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRefundResponse: FfiConverterRustBuffer<RefundResponse> {
    override fun read(buf: ByteBuffer): RefundResponse {
        return RefundResponse(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RefundResponse) = (
            FfiConverterString.allocationSize(value.`refundTxId`)
    )

    override fun write(value: RefundResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`refundTxId`, buf)
    }
}



data class RefundableSwap (
    var `swapAddress`: kotlin.String, 
    var `timestamp`: kotlin.UInt, 
    var `amountSat`: kotlin.ULong, 
    var `lastRefundTxId`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRefundableSwap: FfiConverterRustBuffer<RefundableSwap> {
    override fun read(buf: ByteBuffer): RefundableSwap {
        return RefundableSwap(
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: RefundableSwap) = (
            FfiConverterString.allocationSize(value.`swapAddress`) +
            FfiConverterUInt.allocationSize(value.`timestamp`) +
            FfiConverterULong.allocationSize(value.`amountSat`) +
            FfiConverterOptionalString.allocationSize(value.`lastRefundTxId`)
    )

    override fun write(value: RefundableSwap, buf: ByteBuffer) {
            FfiConverterString.write(value.`swapAddress`, buf)
            FfiConverterUInt.write(value.`timestamp`, buf)
            FfiConverterULong.write(value.`amountSat`, buf)
            FfiConverterOptionalString.write(value.`lastRefundTxId`, buf)
    }
}



data class RestoreRequest (
    var `backupPath`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRestoreRequest: FfiConverterRustBuffer<RestoreRequest> {
    override fun read(buf: ByteBuffer): RestoreRequest {
        return RestoreRequest(
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: RestoreRequest) = (
            FfiConverterOptionalString.allocationSize(value.`backupPath`)
    )

    override fun write(value: RestoreRequest, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`backupPath`, buf)
    }
}



data class RouteHint (
    var `hops`: List<RouteHintHop>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRouteHint: FfiConverterRustBuffer<RouteHint> {
    override fun read(buf: ByteBuffer): RouteHint {
        return RouteHint(
            FfiConverterSequenceTypeRouteHintHop.read(buf),
        )
    }

    override fun allocationSize(value: RouteHint) = (
            FfiConverterSequenceTypeRouteHintHop.allocationSize(value.`hops`)
    )

    override fun write(value: RouteHint, buf: ByteBuffer) {
            FfiConverterSequenceTypeRouteHintHop.write(value.`hops`, buf)
    }
}



data class RouteHintHop (
    var `srcNodeId`: kotlin.String, 
    var `shortChannelId`: kotlin.String, 
    var `feesBaseMsat`: kotlin.UInt, 
    var `feesProportionalMillionths`: kotlin.UInt, 
    var `cltvExpiryDelta`: kotlin.ULong, 
    var `htlcMinimumMsat`: kotlin.ULong?, 
    var `htlcMaximumMsat`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRouteHintHop: FfiConverterRustBuffer<RouteHintHop> {
    override fun read(buf: ByteBuffer): RouteHintHop {
        return RouteHintHop(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: RouteHintHop) = (
            FfiConverterString.allocationSize(value.`srcNodeId`) +
            FfiConverterString.allocationSize(value.`shortChannelId`) +
            FfiConverterUInt.allocationSize(value.`feesBaseMsat`) +
            FfiConverterUInt.allocationSize(value.`feesProportionalMillionths`) +
            FfiConverterULong.allocationSize(value.`cltvExpiryDelta`) +
            FfiConverterOptionalULong.allocationSize(value.`htlcMinimumMsat`) +
            FfiConverterOptionalULong.allocationSize(value.`htlcMaximumMsat`)
    )

    override fun write(value: RouteHintHop, buf: ByteBuffer) {
            FfiConverterString.write(value.`srcNodeId`, buf)
            FfiConverterString.write(value.`shortChannelId`, buf)
            FfiConverterUInt.write(value.`feesBaseMsat`, buf)
            FfiConverterUInt.write(value.`feesProportionalMillionths`, buf)
            FfiConverterULong.write(value.`cltvExpiryDelta`, buf)
            FfiConverterOptionalULong.write(value.`htlcMinimumMsat`, buf)
            FfiConverterOptionalULong.write(value.`htlcMaximumMsat`, buf)
    }
}



data class SendPaymentRequest (
    var `prepareResponse`: PrepareSendResponse, 
    var `useAssetFees`: kotlin.Boolean? = null, 
    var `payerNote`: kotlin.String? = null
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer<SendPaymentRequest> {
    override fun read(buf: ByteBuffer): SendPaymentRequest {
        return SendPaymentRequest(
            FfiConverterTypePrepareSendResponse.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: SendPaymentRequest) = (
            FfiConverterTypePrepareSendResponse.allocationSize(value.`prepareResponse`) +
            FfiConverterOptionalBoolean.allocationSize(value.`useAssetFees`) +
            FfiConverterOptionalString.allocationSize(value.`payerNote`)
    )

    override fun write(value: SendPaymentRequest, buf: ByteBuffer) {
            FfiConverterTypePrepareSendResponse.write(value.`prepareResponse`, buf)
            FfiConverterOptionalBoolean.write(value.`useAssetFees`, buf)
            FfiConverterOptionalString.write(value.`payerNote`, buf)
    }
}



data class SendPaymentResponse (
    var `payment`: Payment
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer<SendPaymentResponse> {
    override fun read(buf: ByteBuffer): SendPaymentResponse {
        return SendPaymentResponse(
            FfiConverterTypePayment.read(buf),
        )
    }

    override fun allocationSize(value: SendPaymentResponse) = (
            FfiConverterTypePayment.allocationSize(value.`payment`)
    )

    override fun write(value: SendPaymentResponse, buf: ByteBuffer) {
            FfiConverterTypePayment.write(value.`payment`, buf)
    }
}



data class SignMessageRequest (
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer<SignMessageRequest> {
    override fun read(buf: ByteBuffer): SignMessageRequest {
        return SignMessageRequest(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SignMessageRequest) = (
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: SignMessageRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`message`, buf)
    }
}



data class SignMessageResponse (
    var `signature`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer<SignMessageResponse> {
    override fun read(buf: ByteBuffer): SignMessageResponse {
        return SignMessageResponse(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SignMessageResponse) = (
            FfiConverterString.allocationSize(value.`signature`)
    )

    override fun write(value: SignMessageResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`signature`, buf)
    }
}



data class Symbol (
    var `grapheme`: kotlin.String?, 
    var `template`: kotlin.String?, 
    var `rtl`: kotlin.Boolean?, 
    var `position`: kotlin.UInt?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSymbol: FfiConverterRustBuffer<Symbol> {
    override fun read(buf: ByteBuffer): Symbol {
        return Symbol(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalUInt.read(buf),
        )
    }

    override fun allocationSize(value: Symbol) = (
            FfiConverterOptionalString.allocationSize(value.`grapheme`) +
            FfiConverterOptionalString.allocationSize(value.`template`) +
            FfiConverterOptionalBoolean.allocationSize(value.`rtl`) +
            FfiConverterOptionalUInt.allocationSize(value.`position`)
    )

    override fun write(value: Symbol, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`grapheme`, buf)
            FfiConverterOptionalString.write(value.`template`, buf)
            FfiConverterOptionalBoolean.write(value.`rtl`, buf)
            FfiConverterOptionalUInt.write(value.`position`, buf)
    }
}



data class UrlSuccessActionData (
    var `description`: kotlin.String, 
    var `url`: kotlin.String, 
    var `matchesCallbackDomain`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer<UrlSuccessActionData> {
    override fun read(buf: ByteBuffer): UrlSuccessActionData {
        return UrlSuccessActionData(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: UrlSuccessActionData) = (
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterString.allocationSize(value.`url`) +
            FfiConverterBoolean.allocationSize(value.`matchesCallbackDomain`)
    )

    override fun write(value: UrlSuccessActionData, buf: ByteBuffer) {
            FfiConverterString.write(value.`description`, buf)
            FfiConverterString.write(value.`url`, buf)
            FfiConverterBoolean.write(value.`matchesCallbackDomain`, buf)
    }
}



data class WalletInfo (
    var `balanceSat`: kotlin.ULong, 
    var `pendingSendSat`: kotlin.ULong, 
    var `pendingReceiveSat`: kotlin.ULong, 
    var `fingerprint`: kotlin.String, 
    var `pubkey`: kotlin.String, 
    var `assetBalances`: List<AssetBalance>
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletInfo: FfiConverterRustBuffer<WalletInfo> {
    override fun read(buf: ByteBuffer): WalletInfo {
        return WalletInfo(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeAssetBalance.read(buf),
        )
    }

    override fun allocationSize(value: WalletInfo) = (
            FfiConverterULong.allocationSize(value.`balanceSat`) +
            FfiConverterULong.allocationSize(value.`pendingSendSat`) +
            FfiConverterULong.allocationSize(value.`pendingReceiveSat`) +
            FfiConverterString.allocationSize(value.`fingerprint`) +
            FfiConverterString.allocationSize(value.`pubkey`) +
            FfiConverterSequenceTypeAssetBalance.allocationSize(value.`assetBalances`)
    )

    override fun write(value: WalletInfo, buf: ByteBuffer) {
            FfiConverterULong.write(value.`balanceSat`, buf)
            FfiConverterULong.write(value.`pendingSendSat`, buf)
            FfiConverterULong.write(value.`pendingReceiveSat`, buf)
            FfiConverterString.write(value.`fingerprint`, buf)
            FfiConverterString.write(value.`pubkey`, buf)
            FfiConverterSequenceTypeAssetBalance.write(value.`assetBalances`, buf)
    }
}



sealed class AesSuccessActionDataResult {
    
    data class Decrypted(
        val `data`: AesSuccessActionDataDecrypted) : AesSuccessActionDataResult() {
        companion object
    }
    
    data class ErrorStatus(
        val `reason`: kotlin.String) : AesSuccessActionDataResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAesSuccessActionDataResult : FfiConverterRustBuffer<AesSuccessActionDataResult>{
    override fun read(buf: ByteBuffer): AesSuccessActionDataResult {
        return when(buf.getInt()) {
            1 -> AesSuccessActionDataResult.Decrypted(
                FfiConverterTypeAesSuccessActionDataDecrypted.read(buf),
                )
            2 -> AesSuccessActionDataResult.ErrorStatus(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AesSuccessActionDataResult) = when(value) {
        is AesSuccessActionDataResult.Decrypted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAesSuccessActionDataDecrypted.allocationSize(value.`data`)
            )
        }
        is AesSuccessActionDataResult.ErrorStatus -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`reason`)
            )
        }
    }

    override fun write(value: AesSuccessActionDataResult, buf: ByteBuffer) {
        when(value) {
            is AesSuccessActionDataResult.Decrypted -> {
                buf.putInt(1)
                FfiConverterTypeAesSuccessActionDataDecrypted.write(value.`data`, buf)
                Unit
            }
            is AesSuccessActionDataResult.ErrorStatus -> {
                buf.putInt(2)
                FfiConverterString.write(value.`reason`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class Amount {
    
    data class Bitcoin(
        val `amountMsat`: kotlin.ULong) : Amount() {
        companion object
    }
    
    data class Currency(
        val `iso4217Code`: kotlin.String, 
        val `fractionalAmount`: kotlin.ULong) : Amount() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAmount : FfiConverterRustBuffer<Amount>{
    override fun read(buf: ByteBuffer): Amount {
        return when(buf.getInt()) {
            1 -> Amount.Bitcoin(
                FfiConverterULong.read(buf),
                )
            2 -> Amount.Currency(
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Amount) = when(value) {
        is Amount.Bitcoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.`amountMsat`)
            )
        }
        is Amount.Currency -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`iso4217Code`)
                + FfiConverterULong.allocationSize(value.`fractionalAmount`)
            )
        }
    }

    override fun write(value: Amount, buf: ByteBuffer) {
        when(value) {
            is Amount.Bitcoin -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`amountMsat`, buf)
                Unit
            }
            is Amount.Currency -> {
                buf.putInt(2)
                FfiConverterString.write(value.`iso4217Code`, buf)
                FfiConverterULong.write(value.`fractionalAmount`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class BlockchainExplorer {
    
    data class Electrum(
        val `url`: kotlin.String) : BlockchainExplorer() {
        companion object
    }
    
    data class Esplora(
        val `url`: kotlin.String, 
        val `useWaterfalls`: kotlin.Boolean) : BlockchainExplorer() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBlockchainExplorer : FfiConverterRustBuffer<BlockchainExplorer>{
    override fun read(buf: ByteBuffer): BlockchainExplorer {
        return when(buf.getInt()) {
            1 -> BlockchainExplorer.Electrum(
                FfiConverterString.read(buf),
                )
            2 -> BlockchainExplorer.Esplora(
                FfiConverterString.read(buf),
                FfiConverterBoolean.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BlockchainExplorer) = when(value) {
        is BlockchainExplorer.Electrum -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`url`)
            )
        }
        is BlockchainExplorer.Esplora -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`url`)
                + FfiConverterBoolean.allocationSize(value.`useWaterfalls`)
            )
        }
    }

    override fun write(value: BlockchainExplorer, buf: ByteBuffer) {
        when(value) {
            is BlockchainExplorer.Electrum -> {
                buf.putInt(1)
                FfiConverterString.write(value.`url`, buf)
                Unit
            }
            is BlockchainExplorer.Esplora -> {
                buf.putInt(2)
                FfiConverterString.write(value.`url`, buf)
                FfiConverterBoolean.write(value.`useWaterfalls`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class BuyBitcoinProvider {
    
    MOONPAY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeBuyBitcoinProvider: FfiConverterRustBuffer<BuyBitcoinProvider> {
    override fun read(buf: ByteBuffer) = try {
        BuyBitcoinProvider.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BuyBitcoinProvider) = 4UL

    override fun write(value: BuyBitcoinProvider, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class GetPaymentRequest {
    
    data class PaymentHash(
        val `paymentHash`: kotlin.String) : GetPaymentRequest() {
        companion object
    }
    
    data class SwapId(
        val `swapId`: kotlin.String) : GetPaymentRequest() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGetPaymentRequest : FfiConverterRustBuffer<GetPaymentRequest>{
    override fun read(buf: ByteBuffer): GetPaymentRequest {
        return when(buf.getInt()) {
            1 -> GetPaymentRequest.PaymentHash(
                FfiConverterString.read(buf),
                )
            2 -> GetPaymentRequest.SwapId(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GetPaymentRequest) = when(value) {
        is GetPaymentRequest.PaymentHash -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`paymentHash`)
            )
        }
        is GetPaymentRequest.SwapId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`swapId`)
            )
        }
    }

    override fun write(value: GetPaymentRequest, buf: ByteBuffer) {
        when(value) {
            is GetPaymentRequest.PaymentHash -> {
                buf.putInt(1)
                FfiConverterString.write(value.`paymentHash`, buf)
                Unit
            }
            is GetPaymentRequest.SwapId -> {
                buf.putInt(2)
                FfiConverterString.write(value.`swapId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class InputType {
    
    data class BitcoinAddress(
        val `address`: BitcoinAddressData) : InputType() {
        companion object
    }
    
    data class LiquidAddress(
        val `address`: LiquidAddressData) : InputType() {
        companion object
    }
    
    data class Bolt11(
        val `invoice`: LnInvoice) : InputType() {
        companion object
    }
    
    data class Bolt12Offer(
        val `offer`: LnOffer, 
        val `bip353Address`: kotlin.String?) : InputType() {
        companion object
    }
    
    data class NodeId(
        val `nodeId`: kotlin.String) : InputType() {
        companion object
    }
    
    data class Url(
        val `url`: kotlin.String) : InputType() {
        companion object
    }
    
    data class LnUrlPay(
        val `data`: LnUrlPayRequestData, 
        val `bip353Address`: kotlin.String?) : InputType() {
        companion object
    }
    
    data class LnUrlWithdraw(
        val `data`: LnUrlWithdrawRequestData) : InputType() {
        companion object
    }
    
    data class LnUrlAuth(
        val `data`: LnUrlAuthRequestData) : InputType() {
        companion object
    }
    
    data class LnUrlError(
        val `data`: LnUrlErrorData) : InputType() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeInputType : FfiConverterRustBuffer<InputType>{
    override fun read(buf: ByteBuffer): InputType {
        return when(buf.getInt()) {
            1 -> InputType.BitcoinAddress(
                FfiConverterTypeBitcoinAddressData.read(buf),
                )
            2 -> InputType.LiquidAddress(
                FfiConverterTypeLiquidAddressData.read(buf),
                )
            3 -> InputType.Bolt11(
                FfiConverterTypeLNInvoice.read(buf),
                )
            4 -> InputType.Bolt12Offer(
                FfiConverterTypeLNOffer.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            5 -> InputType.NodeId(
                FfiConverterString.read(buf),
                )
            6 -> InputType.Url(
                FfiConverterString.read(buf),
                )
            7 -> InputType.LnUrlPay(
                FfiConverterTypeLnUrlPayRequestData.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            8 -> InputType.LnUrlWithdraw(
                FfiConverterTypeLnUrlWithdrawRequestData.read(buf),
                )
            9 -> InputType.LnUrlAuth(
                FfiConverterTypeLnUrlAuthRequestData.read(buf),
                )
            10 -> InputType.LnUrlError(
                FfiConverterTypeLnUrlErrorData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: InputType) = when(value) {
        is InputType.BitcoinAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBitcoinAddressData.allocationSize(value.`address`)
            )
        }
        is InputType.LiquidAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLiquidAddressData.allocationSize(value.`address`)
            )
        }
        is InputType.Bolt11 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLNInvoice.allocationSize(value.`invoice`)
            )
        }
        is InputType.Bolt12Offer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLNOffer.allocationSize(value.`offer`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
            )
        }
        is InputType.NodeId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`nodeId`)
            )
        }
        is InputType.Url -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`url`)
            )
        }
        is InputType.LnUrlPay -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlPayRequestData.allocationSize(value.`data`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
            )
        }
        is InputType.LnUrlWithdraw -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlWithdrawRequestData.allocationSize(value.`data`)
            )
        }
        is InputType.LnUrlAuth -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlAuthRequestData.allocationSize(value.`data`)
            )
        }
        is InputType.LnUrlError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlErrorData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: InputType, buf: ByteBuffer) {
        when(value) {
            is InputType.BitcoinAddress -> {
                buf.putInt(1)
                FfiConverterTypeBitcoinAddressData.write(value.`address`, buf)
                Unit
            }
            is InputType.LiquidAddress -> {
                buf.putInt(2)
                FfiConverterTypeLiquidAddressData.write(value.`address`, buf)
                Unit
            }
            is InputType.Bolt11 -> {
                buf.putInt(3)
                FfiConverterTypeLNInvoice.write(value.`invoice`, buf)
                Unit
            }
            is InputType.Bolt12Offer -> {
                buf.putInt(4)
                FfiConverterTypeLNOffer.write(value.`offer`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                Unit
            }
            is InputType.NodeId -> {
                buf.putInt(5)
                FfiConverterString.write(value.`nodeId`, buf)
                Unit
            }
            is InputType.Url -> {
                buf.putInt(6)
                FfiConverterString.write(value.`url`, buf)
                Unit
            }
            is InputType.LnUrlPay -> {
                buf.putInt(7)
                FfiConverterTypeLnUrlPayRequestData.write(value.`data`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                Unit
            }
            is InputType.LnUrlWithdraw -> {
                buf.putInt(8)
                FfiConverterTypeLnUrlWithdrawRequestData.write(value.`data`, buf)
                Unit
            }
            is InputType.LnUrlAuth -> {
                buf.putInt(9)
                FfiConverterTypeLnUrlAuthRequestData.write(value.`data`, buf)
                Unit
            }
            is InputType.LnUrlError -> {
                buf.putInt(10)
                FfiConverterTypeLnUrlErrorData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class LiquidNetwork {
    
    MAINNET,
    TESTNET,
    REGTEST;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLiquidNetwork: FfiConverterRustBuffer<LiquidNetwork> {
    override fun read(buf: ByteBuffer) = try {
        LiquidNetwork.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LiquidNetwork) = 4UL

    override fun write(value: LiquidNetwork, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class ListPaymentDetails {
    
    data class Liquid(
        val `assetId`: kotlin.String?, 
        val `destination`: kotlin.String?) : ListPaymentDetails() {
        companion object
    }
    
    data class Bitcoin(
        val `address`: kotlin.String?) : ListPaymentDetails() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeListPaymentDetails : FfiConverterRustBuffer<ListPaymentDetails>{
    override fun read(buf: ByteBuffer): ListPaymentDetails {
        return when(buf.getInt()) {
            1 -> ListPaymentDetails.Liquid(
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            2 -> ListPaymentDetails.Bitcoin(
                FfiConverterOptionalString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ListPaymentDetails) = when(value) {
        is ListPaymentDetails.Liquid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`assetId`)
                + FfiConverterOptionalString.allocationSize(value.`destination`)
            )
        }
        is ListPaymentDetails.Bitcoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`address`)
            )
        }
    }

    override fun write(value: ListPaymentDetails, buf: ByteBuffer) {
        when(value) {
            is ListPaymentDetails.Liquid -> {
                buf.putInt(1)
                FfiConverterOptionalString.write(value.`assetId`, buf)
                FfiConverterOptionalString.write(value.`destination`, buf)
                Unit
            }
            is ListPaymentDetails.Bitcoin -> {
                buf.putInt(2)
                FfiConverterOptionalString.write(value.`address`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class LnUrlAuthException: kotlin.Exception() {
    
    class Generic(
        
        val `err`: kotlin.String
        ) : LnUrlAuthException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidUri(
        
        val `err`: kotlin.String
        ) : LnUrlAuthException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class ServiceConnectivity(
        
        val `err`: kotlin.String
        ) : LnUrlAuthException() {
        override val message
            get() = "err=${ `err` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LnUrlAuthException> {
        override fun lift(error_buf: RustBuffer.ByValue): LnUrlAuthException = FfiConverterTypeLnUrlAuthError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlAuthError : FfiConverterRustBuffer<LnUrlAuthException> {
    override fun read(buf: ByteBuffer): LnUrlAuthException {
        

        return when(buf.getInt()) {
            1 -> LnUrlAuthException.Generic(
                FfiConverterString.read(buf),
                )
            2 -> LnUrlAuthException.InvalidUri(
                FfiConverterString.read(buf),
                )
            3 -> LnUrlAuthException.ServiceConnectivity(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlAuthException): ULong {
        return when(value) {
            is LnUrlAuthException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlAuthException.InvalidUri -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlAuthException.ServiceConnectivity -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
        }
    }

    override fun write(value: LnUrlAuthException, buf: ByteBuffer) {
        when(value) {
            is LnUrlAuthException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlAuthException.InvalidUri -> {
                buf.putInt(2)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlAuthException.ServiceConnectivity -> {
                buf.putInt(3)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class LnUrlCallbackStatus {
    
    object Ok : LnUrlCallbackStatus()
    
    
    data class ErrorStatus(
        val `data`: LnUrlErrorData) : LnUrlCallbackStatus() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlCallbackStatus : FfiConverterRustBuffer<LnUrlCallbackStatus>{
    override fun read(buf: ByteBuffer): LnUrlCallbackStatus {
        return when(buf.getInt()) {
            1 -> LnUrlCallbackStatus.Ok
            2 -> LnUrlCallbackStatus.ErrorStatus(
                FfiConverterTypeLnUrlErrorData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlCallbackStatus) = when(value) {
        is LnUrlCallbackStatus.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LnUrlCallbackStatus.ErrorStatus -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlErrorData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: LnUrlCallbackStatus, buf: ByteBuffer) {
        when(value) {
            is LnUrlCallbackStatus.Ok -> {
                buf.putInt(1)
                Unit
            }
            is LnUrlCallbackStatus.ErrorStatus -> {
                buf.putInt(2)
                FfiConverterTypeLnUrlErrorData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class LnUrlPayException: kotlin.Exception() {
    
    class AlreadyPaid(
        ) : LnUrlPayException() {
        override val message
            get() = ""
    }
    
    class Generic(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InsufficientBalance(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidAmount(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidInvoice(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidNetwork(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidUri(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvoiceExpired(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class PaymentFailed(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class PaymentTimeout(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class RouteNotFound(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class RouteTooExpensive(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class ServiceConnectivity(
        
        val `err`: kotlin.String
        ) : LnUrlPayException() {
        override val message
            get() = "err=${ `err` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LnUrlPayException> {
        override fun lift(error_buf: RustBuffer.ByValue): LnUrlPayException = FfiConverterTypeLnUrlPayError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPayError : FfiConverterRustBuffer<LnUrlPayException> {
    override fun read(buf: ByteBuffer): LnUrlPayException {
        

        return when(buf.getInt()) {
            1 -> LnUrlPayException.AlreadyPaid()
            2 -> LnUrlPayException.Generic(
                FfiConverterString.read(buf),
                )
            3 -> LnUrlPayException.InsufficientBalance(
                FfiConverterString.read(buf),
                )
            4 -> LnUrlPayException.InvalidAmount(
                FfiConverterString.read(buf),
                )
            5 -> LnUrlPayException.InvalidInvoice(
                FfiConverterString.read(buf),
                )
            6 -> LnUrlPayException.InvalidNetwork(
                FfiConverterString.read(buf),
                )
            7 -> LnUrlPayException.InvalidUri(
                FfiConverterString.read(buf),
                )
            8 -> LnUrlPayException.InvoiceExpired(
                FfiConverterString.read(buf),
                )
            9 -> LnUrlPayException.PaymentFailed(
                FfiConverterString.read(buf),
                )
            10 -> LnUrlPayException.PaymentTimeout(
                FfiConverterString.read(buf),
                )
            11 -> LnUrlPayException.RouteNotFound(
                FfiConverterString.read(buf),
                )
            12 -> LnUrlPayException.RouteTooExpensive(
                FfiConverterString.read(buf),
                )
            13 -> LnUrlPayException.ServiceConnectivity(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlPayException): ULong {
        return when(value) {
            is LnUrlPayException.AlreadyPaid -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is LnUrlPayException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InsufficientBalance -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InvalidAmount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InvalidInvoice -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InvalidNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InvalidUri -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.InvoiceExpired -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.PaymentFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.PaymentTimeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.RouteNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.RouteTooExpensive -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlPayException.ServiceConnectivity -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
        }
    }

    override fun write(value: LnUrlPayException, buf: ByteBuffer) {
        when(value) {
            is LnUrlPayException.AlreadyPaid -> {
                buf.putInt(1)
                Unit
            }
            is LnUrlPayException.Generic -> {
                buf.putInt(2)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InsufficientBalance -> {
                buf.putInt(3)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InvalidAmount -> {
                buf.putInt(4)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InvalidInvoice -> {
                buf.putInt(5)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InvalidNetwork -> {
                buf.putInt(6)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InvalidUri -> {
                buf.putInt(7)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.InvoiceExpired -> {
                buf.putInt(8)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.PaymentFailed -> {
                buf.putInt(9)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.PaymentTimeout -> {
                buf.putInt(10)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.RouteNotFound -> {
                buf.putInt(11)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.RouteTooExpensive -> {
                buf.putInt(12)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlPayException.ServiceConnectivity -> {
                buf.putInt(13)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * /////////////////////////////
 * ///////////////////////////////
 */
sealed class LnUrlPayResult {
    
    data class EndpointSuccess(
        val `data`: LnUrlPaySuccessData) : LnUrlPayResult() {
        companion object
    }
    
    data class EndpointError(
        val `data`: LnUrlErrorData) : LnUrlPayResult() {
        companion object
    }
    
    data class PayError(
        val `data`: LnUrlPayErrorData) : LnUrlPayResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlPayResult : FfiConverterRustBuffer<LnUrlPayResult>{
    override fun read(buf: ByteBuffer): LnUrlPayResult {
        return when(buf.getInt()) {
            1 -> LnUrlPayResult.EndpointSuccess(
                FfiConverterTypeLnUrlPaySuccessData.read(buf),
                )
            2 -> LnUrlPayResult.EndpointError(
                FfiConverterTypeLnUrlErrorData.read(buf),
                )
            3 -> LnUrlPayResult.PayError(
                FfiConverterTypeLnUrlPayErrorData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlPayResult) = when(value) {
        is LnUrlPayResult.EndpointSuccess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlPaySuccessData.allocationSize(value.`data`)
            )
        }
        is LnUrlPayResult.EndpointError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlErrorData.allocationSize(value.`data`)
            )
        }
        is LnUrlPayResult.PayError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlPayErrorData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: LnUrlPayResult, buf: ByteBuffer) {
        when(value) {
            is LnUrlPayResult.EndpointSuccess -> {
                buf.putInt(1)
                FfiConverterTypeLnUrlPaySuccessData.write(value.`data`, buf)
                Unit
            }
            is LnUrlPayResult.EndpointError -> {
                buf.putInt(2)
                FfiConverterTypeLnUrlErrorData.write(value.`data`, buf)
                Unit
            }
            is LnUrlPayResult.PayError -> {
                buf.putInt(3)
                FfiConverterTypeLnUrlPayErrorData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class LnUrlWithdrawException: kotlin.Exception() {
    
    class Generic(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidAmount(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidInvoice(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvalidUri(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class ServiceConnectivity(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    
    class InvoiceNoRoutingHints(
        
        val `err`: kotlin.String
        ) : LnUrlWithdrawException() {
        override val message
            get() = "err=${ `err` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LnUrlWithdrawException> {
        override fun lift(error_buf: RustBuffer.ByValue): LnUrlWithdrawException = FfiConverterTypeLnUrlWithdrawError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlWithdrawError : FfiConverterRustBuffer<LnUrlWithdrawException> {
    override fun read(buf: ByteBuffer): LnUrlWithdrawException {
        

        return when(buf.getInt()) {
            1 -> LnUrlWithdrawException.Generic(
                FfiConverterString.read(buf),
                )
            2 -> LnUrlWithdrawException.InvalidAmount(
                FfiConverterString.read(buf),
                )
            3 -> LnUrlWithdrawException.InvalidInvoice(
                FfiConverterString.read(buf),
                )
            4 -> LnUrlWithdrawException.InvalidUri(
                FfiConverterString.read(buf),
                )
            5 -> LnUrlWithdrawException.ServiceConnectivity(
                FfiConverterString.read(buf),
                )
            6 -> LnUrlWithdrawException.InvoiceNoRoutingHints(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlWithdrawException): ULong {
        return when(value) {
            is LnUrlWithdrawException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlWithdrawException.InvalidAmount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlWithdrawException.InvalidInvoice -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlWithdrawException.InvalidUri -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlWithdrawException.ServiceConnectivity -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
            is LnUrlWithdrawException.InvoiceNoRoutingHints -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
        }
    }

    override fun write(value: LnUrlWithdrawException, buf: ByteBuffer) {
        when(value) {
            is LnUrlWithdrawException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlWithdrawException.InvalidAmount -> {
                buf.putInt(2)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlWithdrawException.InvalidInvoice -> {
                buf.putInt(3)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlWithdrawException.InvalidUri -> {
                buf.putInt(4)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlWithdrawException.ServiceConnectivity -> {
                buf.putInt(5)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is LnUrlWithdrawException.InvoiceNoRoutingHints -> {
                buf.putInt(6)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class LnUrlWithdrawResult {
    
    data class Ok(
        val `data`: LnUrlWithdrawSuccessData) : LnUrlWithdrawResult() {
        companion object
    }
    
    data class Timeout(
        val `data`: LnUrlWithdrawSuccessData) : LnUrlWithdrawResult() {
        companion object
    }
    
    data class ErrorStatus(
        val `data`: LnUrlErrorData) : LnUrlWithdrawResult() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLnUrlWithdrawResult : FfiConverterRustBuffer<LnUrlWithdrawResult>{
    override fun read(buf: ByteBuffer): LnUrlWithdrawResult {
        return when(buf.getInt()) {
            1 -> LnUrlWithdrawResult.Ok(
                FfiConverterTypeLnUrlWithdrawSuccessData.read(buf),
                )
            2 -> LnUrlWithdrawResult.Timeout(
                FfiConverterTypeLnUrlWithdrawSuccessData.read(buf),
                )
            3 -> LnUrlWithdrawResult.ErrorStatus(
                FfiConverterTypeLnUrlErrorData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LnUrlWithdrawResult) = when(value) {
        is LnUrlWithdrawResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlWithdrawSuccessData.allocationSize(value.`data`)
            )
        }
        is LnUrlWithdrawResult.Timeout -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlWithdrawSuccessData.allocationSize(value.`data`)
            )
        }
        is LnUrlWithdrawResult.ErrorStatus -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLnUrlErrorData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: LnUrlWithdrawResult, buf: ByteBuffer) {
        when(value) {
            is LnUrlWithdrawResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeLnUrlWithdrawSuccessData.write(value.`data`, buf)
                Unit
            }
            is LnUrlWithdrawResult.Timeout -> {
                buf.putInt(2)
                FfiConverterTypeLnUrlWithdrawSuccessData.write(value.`data`, buf)
                Unit
            }
            is LnUrlWithdrawResult.ErrorStatus -> {
                buf.putInt(3)
                FfiConverterTypeLnUrlErrorData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class Network {
    
    BITCOIN,
    TESTNET,
    SIGNET,
    REGTEST;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNetwork: FfiConverterRustBuffer<Network> {
    override fun read(buf: ByteBuffer) = try {
        Network.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Network) = 4UL

    override fun write(value: Network, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class NwcEvent {
    
    object ConnectedHandled : NwcEvent()
    
    
    object DisconnectedHandled : NwcEvent()
    
    
    data class PayInvoiceHandled(
        val `success`: kotlin.Boolean, 
        val `preimage`: kotlin.String?, 
        val `feesSat`: kotlin.ULong?, 
        val `error`: kotlin.String?) : NwcEvent() {
        companion object
    }
    
    object ListTransactionsHandled : NwcEvent()
    
    
    object GetBalanceHandled : NwcEvent()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNwcEvent : FfiConverterRustBuffer<NwcEvent>{
    override fun read(buf: ByteBuffer): NwcEvent {
        return when(buf.getInt()) {
            1 -> NwcEvent.ConnectedHandled
            2 -> NwcEvent.DisconnectedHandled
            3 -> NwcEvent.PayInvoiceHandled(
                FfiConverterBoolean.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalULong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            4 -> NwcEvent.ListTransactionsHandled
            5 -> NwcEvent.GetBalanceHandled
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NwcEvent) = when(value) {
        is NwcEvent.ConnectedHandled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NwcEvent.DisconnectedHandled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NwcEvent.PayInvoiceHandled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`success`)
                + FfiConverterOptionalString.allocationSize(value.`preimage`)
                + FfiConverterOptionalULong.allocationSize(value.`feesSat`)
                + FfiConverterOptionalString.allocationSize(value.`error`)
            )
        }
        is NwcEvent.ListTransactionsHandled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NwcEvent.GetBalanceHandled -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: NwcEvent, buf: ByteBuffer) {
        when(value) {
            is NwcEvent.ConnectedHandled -> {
                buf.putInt(1)
                Unit
            }
            is NwcEvent.DisconnectedHandled -> {
                buf.putInt(2)
                Unit
            }
            is NwcEvent.PayInvoiceHandled -> {
                buf.putInt(3)
                FfiConverterBoolean.write(value.`success`, buf)
                FfiConverterOptionalString.write(value.`preimage`, buf)
                FfiConverterOptionalULong.write(value.`feesSat`, buf)
                FfiConverterOptionalString.write(value.`error`, buf)
                Unit
            }
            is NwcEvent.ListTransactionsHandled -> {
                buf.putInt(4)
                Unit
            }
            is NwcEvent.GetBalanceHandled -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PayAmount {
    
    data class Bitcoin(
        val `receiverAmountSat`: kotlin.ULong) : PayAmount() {
        companion object
    }
    
    data class Asset(
        val `toAsset`: kotlin.String, 
        val `receiverAmount`: kotlin.Double, 
        val `estimateAssetFees`: kotlin.Boolean?, 
        val `fromAsset`: kotlin.String?) : PayAmount() {
        companion object
    }
    
    object Drain : PayAmount()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePayAmount : FfiConverterRustBuffer<PayAmount>{
    override fun read(buf: ByteBuffer): PayAmount {
        return when(buf.getInt()) {
            1 -> PayAmount.Bitcoin(
                FfiConverterULong.read(buf),
                )
            2 -> PayAmount.Asset(
                FfiConverterString.read(buf),
                FfiConverterDouble.read(buf),
                FfiConverterOptionalBoolean.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            3 -> PayAmount.Drain
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PayAmount) = when(value) {
        is PayAmount.Bitcoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.`receiverAmountSat`)
            )
        }
        is PayAmount.Asset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`toAsset`)
                + FfiConverterDouble.allocationSize(value.`receiverAmount`)
                + FfiConverterOptionalBoolean.allocationSize(value.`estimateAssetFees`)
                + FfiConverterOptionalString.allocationSize(value.`fromAsset`)
            )
        }
        is PayAmount.Drain -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: PayAmount, buf: ByteBuffer) {
        when(value) {
            is PayAmount.Bitcoin -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`receiverAmountSat`, buf)
                Unit
            }
            is PayAmount.Asset -> {
                buf.putInt(2)
                FfiConverterString.write(value.`toAsset`, buf)
                FfiConverterDouble.write(value.`receiverAmount`, buf)
                FfiConverterOptionalBoolean.write(value.`estimateAssetFees`, buf)
                FfiConverterOptionalString.write(value.`fromAsset`, buf)
                Unit
            }
            is PayAmount.Drain -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PaymentDetails {
    
    data class Lightning(
        val `swapId`: kotlin.String, 
        val `description`: kotlin.String, 
        val `liquidExpirationBlockheight`: kotlin.UInt, 
        val `preimage`: kotlin.String?, 
        val `invoice`: kotlin.String?, 
        val `bolt12Offer`: kotlin.String?, 
        val `paymentHash`: kotlin.String?, 
        val `destinationPubkey`: kotlin.String?, 
        val `lnurlInfo`: LnUrlInfo?, 
        val `bip353Address`: kotlin.String?, 
        val `payerNote`: kotlin.String?, 
        val `claimTxId`: kotlin.String?, 
        val `refundTxId`: kotlin.String?, 
        val `refundTxAmountSat`: kotlin.ULong?) : PaymentDetails() {
        companion object
    }
    
    data class Liquid(
        val `assetId`: kotlin.String, 
        val `destination`: kotlin.String, 
        val `description`: kotlin.String, 
        val `assetInfo`: AssetInfo?, 
        val `lnurlInfo`: LnUrlInfo?, 
        val `bip353Address`: kotlin.String?, 
        val `payerNote`: kotlin.String?) : PaymentDetails() {
        companion object
    }
    
    data class Bitcoin(
        val `swapId`: kotlin.String, 
        val `bitcoinAddress`: kotlin.String, 
        val `description`: kotlin.String, 
        val `autoAcceptedFees`: kotlin.Boolean, 
        val `bitcoinExpirationBlockheight`: kotlin.UInt?, 
        val `liquidExpirationBlockheight`: kotlin.UInt?, 
        val `lockupTxId`: kotlin.String?, 
        val `claimTxId`: kotlin.String?, 
        val `refundTxId`: kotlin.String?, 
        val `refundTxAmountSat`: kotlin.ULong?) : PaymentDetails() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentDetails : FfiConverterRustBuffer<PaymentDetails>{
    override fun read(buf: ByteBuffer): PaymentDetails {
        return when(buf.getInt()) {
            1 -> PaymentDetails.Lightning(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterUInt.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeLnUrlInfo.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalULong.read(buf),
                )
            2 -> PaymentDetails.Liquid(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterOptionalTypeAssetInfo.read(buf),
                FfiConverterOptionalTypeLnUrlInfo.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            3 -> PaymentDetails.Bitcoin(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterBoolean.read(buf),
                FfiConverterOptionalUInt.read(buf),
                FfiConverterOptionalUInt.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentDetails) = when(value) {
        is PaymentDetails.Lightning -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`swapId`)
                + FfiConverterString.allocationSize(value.`description`)
                + FfiConverterUInt.allocationSize(value.`liquidExpirationBlockheight`)
                + FfiConverterOptionalString.allocationSize(value.`preimage`)
                + FfiConverterOptionalString.allocationSize(value.`invoice`)
                + FfiConverterOptionalString.allocationSize(value.`bolt12Offer`)
                + FfiConverterOptionalString.allocationSize(value.`paymentHash`)
                + FfiConverterOptionalString.allocationSize(value.`destinationPubkey`)
                + FfiConverterOptionalTypeLnUrlInfo.allocationSize(value.`lnurlInfo`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
                + FfiConverterOptionalString.allocationSize(value.`payerNote`)
                + FfiConverterOptionalString.allocationSize(value.`claimTxId`)
                + FfiConverterOptionalString.allocationSize(value.`refundTxId`)
                + FfiConverterOptionalULong.allocationSize(value.`refundTxAmountSat`)
            )
        }
        is PaymentDetails.Liquid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`assetId`)
                + FfiConverterString.allocationSize(value.`destination`)
                + FfiConverterString.allocationSize(value.`description`)
                + FfiConverterOptionalTypeAssetInfo.allocationSize(value.`assetInfo`)
                + FfiConverterOptionalTypeLnUrlInfo.allocationSize(value.`lnurlInfo`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
                + FfiConverterOptionalString.allocationSize(value.`payerNote`)
            )
        }
        is PaymentDetails.Bitcoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`swapId`)
                + FfiConverterString.allocationSize(value.`bitcoinAddress`)
                + FfiConverterString.allocationSize(value.`description`)
                + FfiConverterBoolean.allocationSize(value.`autoAcceptedFees`)
                + FfiConverterOptionalUInt.allocationSize(value.`bitcoinExpirationBlockheight`)
                + FfiConverterOptionalUInt.allocationSize(value.`liquidExpirationBlockheight`)
                + FfiConverterOptionalString.allocationSize(value.`lockupTxId`)
                + FfiConverterOptionalString.allocationSize(value.`claimTxId`)
                + FfiConverterOptionalString.allocationSize(value.`refundTxId`)
                + FfiConverterOptionalULong.allocationSize(value.`refundTxAmountSat`)
            )
        }
    }

    override fun write(value: PaymentDetails, buf: ByteBuffer) {
        when(value) {
            is PaymentDetails.Lightning -> {
                buf.putInt(1)
                FfiConverterString.write(value.`swapId`, buf)
                FfiConverterString.write(value.`description`, buf)
                FfiConverterUInt.write(value.`liquidExpirationBlockheight`, buf)
                FfiConverterOptionalString.write(value.`preimage`, buf)
                FfiConverterOptionalString.write(value.`invoice`, buf)
                FfiConverterOptionalString.write(value.`bolt12Offer`, buf)
                FfiConverterOptionalString.write(value.`paymentHash`, buf)
                FfiConverterOptionalString.write(value.`destinationPubkey`, buf)
                FfiConverterOptionalTypeLnUrlInfo.write(value.`lnurlInfo`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                FfiConverterOptionalString.write(value.`payerNote`, buf)
                FfiConverterOptionalString.write(value.`claimTxId`, buf)
                FfiConverterOptionalString.write(value.`refundTxId`, buf)
                FfiConverterOptionalULong.write(value.`refundTxAmountSat`, buf)
                Unit
            }
            is PaymentDetails.Liquid -> {
                buf.putInt(2)
                FfiConverterString.write(value.`assetId`, buf)
                FfiConverterString.write(value.`destination`, buf)
                FfiConverterString.write(value.`description`, buf)
                FfiConverterOptionalTypeAssetInfo.write(value.`assetInfo`, buf)
                FfiConverterOptionalTypeLnUrlInfo.write(value.`lnurlInfo`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                FfiConverterOptionalString.write(value.`payerNote`, buf)
                Unit
            }
            is PaymentDetails.Bitcoin -> {
                buf.putInt(3)
                FfiConverterString.write(value.`swapId`, buf)
                FfiConverterString.write(value.`bitcoinAddress`, buf)
                FfiConverterString.write(value.`description`, buf)
                FfiConverterBoolean.write(value.`autoAcceptedFees`, buf)
                FfiConverterOptionalUInt.write(value.`bitcoinExpirationBlockheight`, buf)
                FfiConverterOptionalUInt.write(value.`liquidExpirationBlockheight`, buf)
                FfiConverterOptionalString.write(value.`lockupTxId`, buf)
                FfiConverterOptionalString.write(value.`claimTxId`, buf)
                FfiConverterOptionalString.write(value.`refundTxId`, buf)
                FfiConverterOptionalULong.write(value.`refundTxAmountSat`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class PaymentException(message: String): kotlin.Exception(message) {
        
        class AlreadyClaimed(message: String) : PaymentException(message)
        
        class AlreadyPaid(message: String) : PaymentException(message)
        
        class PaymentInProgress(message: String) : PaymentException(message)
        
        class AmountOutOfRange(message: String) : PaymentException(message)
        
        class AmountMissing(message: String) : PaymentException(message)
        
        class AssetException(message: String) : PaymentException(message)
        
        class Generic(message: String) : PaymentException(message)
        
        class InvalidOrExpiredFees(message: String) : PaymentException(message)
        
        class InsufficientFunds(message: String) : PaymentException(message)
        
        class InvalidDescription(message: String) : PaymentException(message)
        
        class InvalidInvoice(message: String) : PaymentException(message)
        
        class InvalidNetwork(message: String) : PaymentException(message)
        
        class InvalidPreimage(message: String) : PaymentException(message)
        
        class PairsNotFound(message: String) : PaymentException(message)
        
        class PaymentTimeout(message: String) : PaymentException(message)
        
        class PersistException(message: String) : PaymentException(message)
        
        class ReceiveException(message: String) : PaymentException(message)
        
        class Refunded(message: String) : PaymentException(message)
        
        class SelfTransferNotSupported(message: String) : PaymentException(message)
        
        class SendException(message: String) : PaymentException(message)
        
        class SignerException(message: String) : PaymentException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PaymentException> {
        override fun lift(error_buf: RustBuffer.ByValue): PaymentException = FfiConverterTypePaymentError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentError : FfiConverterRustBuffer<PaymentException> {
    override fun read(buf: ByteBuffer): PaymentException {
        
            return when(buf.getInt()) {
            1 -> PaymentException.AlreadyClaimed(FfiConverterString.read(buf))
            2 -> PaymentException.AlreadyPaid(FfiConverterString.read(buf))
            3 -> PaymentException.PaymentInProgress(FfiConverterString.read(buf))
            4 -> PaymentException.AmountOutOfRange(FfiConverterString.read(buf))
            5 -> PaymentException.AmountMissing(FfiConverterString.read(buf))
            6 -> PaymentException.AssetException(FfiConverterString.read(buf))
            7 -> PaymentException.Generic(FfiConverterString.read(buf))
            8 -> PaymentException.InvalidOrExpiredFees(FfiConverterString.read(buf))
            9 -> PaymentException.InsufficientFunds(FfiConverterString.read(buf))
            10 -> PaymentException.InvalidDescription(FfiConverterString.read(buf))
            11 -> PaymentException.InvalidInvoice(FfiConverterString.read(buf))
            12 -> PaymentException.InvalidNetwork(FfiConverterString.read(buf))
            13 -> PaymentException.InvalidPreimage(FfiConverterString.read(buf))
            14 -> PaymentException.PairsNotFound(FfiConverterString.read(buf))
            15 -> PaymentException.PaymentTimeout(FfiConverterString.read(buf))
            16 -> PaymentException.PersistException(FfiConverterString.read(buf))
            17 -> PaymentException.ReceiveException(FfiConverterString.read(buf))
            18 -> PaymentException.Refunded(FfiConverterString.read(buf))
            19 -> PaymentException.SelfTransferNotSupported(FfiConverterString.read(buf))
            20 -> PaymentException.SendException(FfiConverterString.read(buf))
            21 -> PaymentException.SignerException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: PaymentException): ULong {
        return 4UL
    }

    override fun write(value: PaymentException, buf: ByteBuffer) {
        when(value) {
            is PaymentException.AlreadyClaimed -> {
                buf.putInt(1)
                Unit
            }
            is PaymentException.AlreadyPaid -> {
                buf.putInt(2)
                Unit
            }
            is PaymentException.PaymentInProgress -> {
                buf.putInt(3)
                Unit
            }
            is PaymentException.AmountOutOfRange -> {
                buf.putInt(4)
                Unit
            }
            is PaymentException.AmountMissing -> {
                buf.putInt(5)
                Unit
            }
            is PaymentException.AssetException -> {
                buf.putInt(6)
                Unit
            }
            is PaymentException.Generic -> {
                buf.putInt(7)
                Unit
            }
            is PaymentException.InvalidOrExpiredFees -> {
                buf.putInt(8)
                Unit
            }
            is PaymentException.InsufficientFunds -> {
                buf.putInt(9)
                Unit
            }
            is PaymentException.InvalidDescription -> {
                buf.putInt(10)
                Unit
            }
            is PaymentException.InvalidInvoice -> {
                buf.putInt(11)
                Unit
            }
            is PaymentException.InvalidNetwork -> {
                buf.putInt(12)
                Unit
            }
            is PaymentException.InvalidPreimage -> {
                buf.putInt(13)
                Unit
            }
            is PaymentException.PairsNotFound -> {
                buf.putInt(14)
                Unit
            }
            is PaymentException.PaymentTimeout -> {
                buf.putInt(15)
                Unit
            }
            is PaymentException.PersistException -> {
                buf.putInt(16)
                Unit
            }
            is PaymentException.ReceiveException -> {
                buf.putInt(17)
                Unit
            }
            is PaymentException.Refunded -> {
                buf.putInt(18)
                Unit
            }
            is PaymentException.SelfTransferNotSupported -> {
                buf.putInt(19)
                Unit
            }
            is PaymentException.SendException -> {
                buf.putInt(20)
                Unit
            }
            is PaymentException.SignerException -> {
                buf.putInt(21)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class PaymentMethod {
    
    LIGHTNING,
    BOLT11_INVOICE,
    BOLT12_OFFER,
    BITCOIN_ADDRESS,
    LIQUID_ADDRESS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentMethod: FfiConverterRustBuffer<PaymentMethod> {
    override fun read(buf: ByteBuffer) = try {
        PaymentMethod.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentMethod) = 4UL

    override fun write(value: PaymentMethod, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PaymentState {
    
    CREATED,
    PENDING,
    COMPLETE,
    FAILED,
    TIMED_OUT,
    REFUNDABLE,
    REFUND_PENDING,
    WAITING_FEE_ACCEPTANCE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentState: FfiConverterRustBuffer<PaymentState> {
    override fun read(buf: ByteBuffer) = try {
        PaymentState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentState) = 4UL

    override fun write(value: PaymentState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class PaymentType {
    
    RECEIVE,
    SEND;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentType: FfiConverterRustBuffer<PaymentType> {
    override fun read(buf: ByteBuffer) = try {
        PaymentType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentType) = 4UL

    override fun write(value: PaymentType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class PluginStorageException: kotlin.Exception() {
    
    class Generic(
        
        val `err`: kotlin.String
        ) : PluginStorageException() {
        override val message
            get() = "err=${ `err` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PluginStorageException> {
        override fun lift(error_buf: RustBuffer.ByValue): PluginStorageException = FfiConverterTypePluginStorageError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePluginStorageError : FfiConverterRustBuffer<PluginStorageException> {
    override fun read(buf: ByteBuffer): PluginStorageException {
        

        return when(buf.getInt()) {
            1 -> PluginStorageException.Generic(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PluginStorageException): ULong {
        return when(value) {
            is PluginStorageException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
        }
    }

    override fun write(value: PluginStorageException, buf: ByteBuffer) {
        when(value) {
            is PluginStorageException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class ReceiveAmount {
    
    data class Bitcoin(
        val `payerAmountSat`: kotlin.ULong) : ReceiveAmount() {
        companion object
    }
    
    data class Asset(
        val `assetId`: kotlin.String, 
        val `payerAmount`: kotlin.Double?) : ReceiveAmount() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceiveAmount : FfiConverterRustBuffer<ReceiveAmount>{
    override fun read(buf: ByteBuffer): ReceiveAmount {
        return when(buf.getInt()) {
            1 -> ReceiveAmount.Bitcoin(
                FfiConverterULong.read(buf),
                )
            2 -> ReceiveAmount.Asset(
                FfiConverterString.read(buf),
                FfiConverterOptionalDouble.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ReceiveAmount) = when(value) {
        is ReceiveAmount.Bitcoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.`payerAmountSat`)
            )
        }
        is ReceiveAmount.Asset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`assetId`)
                + FfiConverterOptionalDouble.allocationSize(value.`payerAmount`)
            )
        }
    }

    override fun write(value: ReceiveAmount, buf: ByteBuffer) {
        when(value) {
            is ReceiveAmount.Bitcoin -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`payerAmountSat`, buf)
                Unit
            }
            is ReceiveAmount.Asset -> {
                buf.putInt(2)
                FfiConverterString.write(value.`assetId`, buf)
                FfiConverterOptionalDouble.write(value.`payerAmount`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * /////////////////////////////
 */
sealed class SdkException(message: String): kotlin.Exception(message) {
        
        class AlreadyStarted(message: String) : SdkException(message)
        
        class Generic(message: String) : SdkException(message)
        
        class NotStarted(message: String) : SdkException(message)
        
        class ServiceConnectivity(message: String) : SdkException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SdkException> {
        override fun lift(error_buf: RustBuffer.ByValue): SdkException = FfiConverterTypeSdkError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSdkError : FfiConverterRustBuffer<SdkException> {
    override fun read(buf: ByteBuffer): SdkException {
        
            return when(buf.getInt()) {
            1 -> SdkException.AlreadyStarted(FfiConverterString.read(buf))
            2 -> SdkException.Generic(FfiConverterString.read(buf))
            3 -> SdkException.NotStarted(FfiConverterString.read(buf))
            4 -> SdkException.ServiceConnectivity(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: SdkException): ULong {
        return 4UL
    }

    override fun write(value: SdkException, buf: ByteBuffer) {
        when(value) {
            is SdkException.AlreadyStarted -> {
                buf.putInt(1)
                Unit
            }
            is SdkException.Generic -> {
                buf.putInt(2)
                Unit
            }
            is SdkException.NotStarted -> {
                buf.putInt(3)
                Unit
            }
            is SdkException.ServiceConnectivity -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SdkEvent {
    
    data class PaymentFailed(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentPending(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentRefundable(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentRefunded(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentRefundPending(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentSucceeded(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentWaitingConfirmation(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    data class PaymentWaitingFeeAcceptance(
        val `details`: Payment) : SdkEvent() {
        companion object
    }
    
    object Synced : SdkEvent()
    
    
    data class DataSynced(
        val `didPullNewRecords`: kotlin.Boolean) : SdkEvent() {
        companion object
    }
    
    data class Nwc(
        val `eventId`: kotlin.String, 
        val `details`: NwcEvent) : SdkEvent() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSdkEvent : FfiConverterRustBuffer<SdkEvent>{
    override fun read(buf: ByteBuffer): SdkEvent {
        return when(buf.getInt()) {
            1 -> SdkEvent.PaymentFailed(
                FfiConverterTypePayment.read(buf),
                )
            2 -> SdkEvent.PaymentPending(
                FfiConverterTypePayment.read(buf),
                )
            3 -> SdkEvent.PaymentRefundable(
                FfiConverterTypePayment.read(buf),
                )
            4 -> SdkEvent.PaymentRefunded(
                FfiConverterTypePayment.read(buf),
                )
            5 -> SdkEvent.PaymentRefundPending(
                FfiConverterTypePayment.read(buf),
                )
            6 -> SdkEvent.PaymentSucceeded(
                FfiConverterTypePayment.read(buf),
                )
            7 -> SdkEvent.PaymentWaitingConfirmation(
                FfiConverterTypePayment.read(buf),
                )
            8 -> SdkEvent.PaymentWaitingFeeAcceptance(
                FfiConverterTypePayment.read(buf),
                )
            9 -> SdkEvent.Synced
            10 -> SdkEvent.DataSynced(
                FfiConverterBoolean.read(buf),
                )
            11 -> SdkEvent.Nwc(
                FfiConverterString.read(buf),
                FfiConverterTypeNwcEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SdkEvent) = when(value) {
        is SdkEvent.PaymentFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentPending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentRefundable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentRefunded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentRefundPending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentSucceeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentWaitingConfirmation -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.PaymentWaitingFeeAcceptance -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePayment.allocationSize(value.`details`)
            )
        }
        is SdkEvent.Synced -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SdkEvent.DataSynced -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`didPullNewRecords`)
            )
        }
        is SdkEvent.Nwc -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
                + FfiConverterTypeNwcEvent.allocationSize(value.`details`)
            )
        }
    }

    override fun write(value: SdkEvent, buf: ByteBuffer) {
        when(value) {
            is SdkEvent.PaymentFailed -> {
                buf.putInt(1)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentPending -> {
                buf.putInt(2)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentRefundable -> {
                buf.putInt(3)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentRefunded -> {
                buf.putInt(4)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentRefundPending -> {
                buf.putInt(5)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentSucceeded -> {
                buf.putInt(6)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentWaitingConfirmation -> {
                buf.putInt(7)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.PaymentWaitingFeeAcceptance -> {
                buf.putInt(8)
                FfiConverterTypePayment.write(value.`details`, buf)
                Unit
            }
            is SdkEvent.Synced -> {
                buf.putInt(9)
                Unit
            }
            is SdkEvent.DataSynced -> {
                buf.putInt(10)
                FfiConverterBoolean.write(value.`didPullNewRecords`, buf)
                Unit
            }
            is SdkEvent.Nwc -> {
                buf.putInt(11)
                FfiConverterString.write(value.`eventId`, buf)
                FfiConverterTypeNwcEvent.write(value.`details`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendDestination {
    
    data class LiquidAddress(
        val `addressData`: LiquidAddressData, 
        val `bip353Address`: kotlin.String?) : SendDestination() {
        companion object
    }
    
    data class Bolt11(
        val `invoice`: LnInvoice, 
        val `bip353Address`: kotlin.String?) : SendDestination() {
        companion object
    }
    
    data class Bolt12(
        val `offer`: LnOffer, 
        val `receiverAmountSat`: kotlin.ULong, 
        val `bip353Address`: kotlin.String?) : SendDestination() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendDestination : FfiConverterRustBuffer<SendDestination>{
    override fun read(buf: ByteBuffer): SendDestination {
        return when(buf.getInt()) {
            1 -> SendDestination.LiquidAddress(
                FfiConverterTypeLiquidAddressData.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            2 -> SendDestination.Bolt11(
                FfiConverterTypeLNInvoice.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            3 -> SendDestination.Bolt12(
                FfiConverterTypeLNOffer.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendDestination) = when(value) {
        is SendDestination.LiquidAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLiquidAddressData.allocationSize(value.`addressData`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
            )
        }
        is SendDestination.Bolt11 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLNInvoice.allocationSize(value.`invoice`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
            )
        }
        is SendDestination.Bolt12 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLNOffer.allocationSize(value.`offer`)
                + FfiConverterULong.allocationSize(value.`receiverAmountSat`)
                + FfiConverterOptionalString.allocationSize(value.`bip353Address`)
            )
        }
    }

    override fun write(value: SendDestination, buf: ByteBuffer) {
        when(value) {
            is SendDestination.LiquidAddress -> {
                buf.putInt(1)
                FfiConverterTypeLiquidAddressData.write(value.`addressData`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                Unit
            }
            is SendDestination.Bolt11 -> {
                buf.putInt(2)
                FfiConverterTypeLNInvoice.write(value.`invoice`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                Unit
            }
            is SendDestination.Bolt12 -> {
                buf.putInt(3)
                FfiConverterTypeLNOffer.write(value.`offer`, buf)
                FfiConverterULong.write(value.`receiverAmountSat`, buf)
                FfiConverterOptionalString.write(value.`bip353Address`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SignerException: kotlin.Exception() {
    
    class Generic(
        
        val `err`: kotlin.String
        ) : SignerException() {
        override val message
            get() = "err=${ `err` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SignerException> {
        override fun lift(error_buf: RustBuffer.ByValue): SignerException = FfiConverterTypeSignerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSignerError : FfiConverterRustBuffer<SignerException> {
    override fun read(buf: ByteBuffer): SignerException {
        

        return when(buf.getInt()) {
            1 -> SignerException.Generic(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignerException): ULong {
        return when(value) {
            is SignerException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`err`)
            )
        }
    }

    override fun write(value: SignerException, buf: ByteBuffer) {
        when(value) {
            is SignerException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SuccessAction {
    
    data class Aes(
        val `data`: AesSuccessActionData) : SuccessAction() {
        companion object
    }
    
    data class Message(
        val `data`: MessageSuccessActionData) : SuccessAction() {
        companion object
    }
    
    data class Url(
        val `data`: UrlSuccessActionData) : SuccessAction() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSuccessAction : FfiConverterRustBuffer<SuccessAction>{
    override fun read(buf: ByteBuffer): SuccessAction {
        return when(buf.getInt()) {
            1 -> SuccessAction.Aes(
                FfiConverterTypeAesSuccessActionData.read(buf),
                )
            2 -> SuccessAction.Message(
                FfiConverterTypeMessageSuccessActionData.read(buf),
                )
            3 -> SuccessAction.Url(
                FfiConverterTypeUrlSuccessActionData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SuccessAction) = when(value) {
        is SuccessAction.Aes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAesSuccessActionData.allocationSize(value.`data`)
            )
        }
        is SuccessAction.Message -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageSuccessActionData.allocationSize(value.`data`)
            )
        }
        is SuccessAction.Url -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUrlSuccessActionData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: SuccessAction, buf: ByteBuffer) {
        when(value) {
            is SuccessAction.Aes -> {
                buf.putInt(1)
                FfiConverterTypeAesSuccessActionData.write(value.`data`, buf)
                Unit
            }
            is SuccessAction.Message -> {
                buf.putInt(2)
                FfiConverterTypeMessageSuccessActionData.write(value.`data`, buf)
                Unit
            }
            is SuccessAction.Url -> {
                buf.putInt(3)
                FfiConverterTypeUrlSuccessActionData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SuccessActionProcessed {
    
    data class Aes(
        val `result`: AesSuccessActionDataResult) : SuccessActionProcessed() {
        companion object
    }
    
    data class Message(
        val `data`: MessageSuccessActionData) : SuccessActionProcessed() {
        companion object
    }
    
    data class Url(
        val `data`: UrlSuccessActionData) : SuccessActionProcessed() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSuccessActionProcessed : FfiConverterRustBuffer<SuccessActionProcessed>{
    override fun read(buf: ByteBuffer): SuccessActionProcessed {
        return when(buf.getInt()) {
            1 -> SuccessActionProcessed.Aes(
                FfiConverterTypeAesSuccessActionDataResult.read(buf),
                )
            2 -> SuccessActionProcessed.Message(
                FfiConverterTypeMessageSuccessActionData.read(buf),
                )
            3 -> SuccessActionProcessed.Url(
                FfiConverterTypeUrlSuccessActionData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SuccessActionProcessed) = when(value) {
        is SuccessActionProcessed.Aes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAesSuccessActionDataResult.allocationSize(value.`result`)
            )
        }
        is SuccessActionProcessed.Message -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageSuccessActionData.allocationSize(value.`data`)
            )
        }
        is SuccessActionProcessed.Url -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUrlSuccessActionData.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: SuccessActionProcessed, buf: ByteBuffer) {
        when(value) {
            is SuccessActionProcessed.Aes -> {
                buf.putInt(1)
                FfiConverterTypeAesSuccessActionDataResult.write(value.`result`, buf)
                Unit
            }
            is SuccessActionProcessed.Message -> {
                buf.putInt(2)
                FfiConverterTypeMessageSuccessActionData.write(value.`data`, buf)
                Unit
            }
            is SuccessActionProcessed.Url -> {
                buf.putInt(3)
                FfiConverterTypeUrlSuccessActionData.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







public interface EventListener {
    
    fun `onEvent`(`e`: SdkEvent)
    
    companion object
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceEventListener {
    internal object `onEvent`: UniffiCallbackInterfaceEventListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`e`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeEventListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onEvent`(
                    FfiConverterTypeSdkEvent.lift(`e`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeEventListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceEventListener.UniffiByValue(
        `onEvent`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_eventlistener(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeEventListener: FfiConverterCallbackInterface<EventListener>()





public interface Logger {
    
    fun `log`(`l`: LogEntry)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceLogger {
    internal object `log`: UniffiCallbackInterfaceLoggerMethod0 {
        override fun callback(`uniffiHandle`: Long,`l`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLogger.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`log`(
                    FfiConverterTypeLogEntry.lift(`l`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeLogger.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceLogger.UniffiByValue(
        `log`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_logger(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeLogger: FfiConverterCallbackInterface<Logger>()





public interface Plugin {
    
    fun `id`(): kotlin.String
    
    fun `onStart`(`sdk`: BindingLiquidSdk, `storage`: PluginStorage, `eventEmitter`: PluginEventEmitter)
    
    fun `onStop`()
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePlugin {
    internal object `id`: UniffiCallbackInterfacePluginMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePlugin.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`id`(
                )
            }
            val writeReturn = { value: kotlin.String -> uniffiOutReturn.setValue(FfiConverterString.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onStart`: UniffiCallbackInterfacePluginMethod1 {
        override fun callback(`uniffiHandle`: Long,`sdk`: Pointer,`storage`: Pointer,`eventEmitter`: Pointer,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePlugin.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onStart`(
                    FfiConverterTypeBindingLiquidSdk.lift(`sdk`),
                    FfiConverterTypePluginStorage.lift(`storage`),
                    FfiConverterTypePluginEventEmitter.lift(`eventEmitter`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `onStop`: UniffiCallbackInterfacePluginMethod2 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePlugin.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onStop`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePlugin.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePlugin.UniffiByValue(
        `id`,
        `onStart`,
        `onStop`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_plugin(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypePlugin: FfiConverterCallbackInterface<Plugin>()





public interface Signer {
    
    fun `xpub`(): List<kotlin.UByte>
    
    fun `deriveXpub`(`derivationPath`: kotlin.String): List<kotlin.UByte>
    
    fun `signEcdsa`(`msg`: List<kotlin.UByte>, `derivationPath`: kotlin.String): List<kotlin.UByte>
    
    fun `signEcdsaRecoverable`(`msg`: List<kotlin.UByte>): List<kotlin.UByte>
    
    fun `slip77MasterBlindingKey`(): List<kotlin.UByte>
    
    fun `hmacSha256`(`msg`: List<kotlin.UByte>, `derivationPath`: kotlin.String): List<kotlin.UByte>
    
    fun `eciesEncrypt`(`msg`: List<kotlin.UByte>): List<kotlin.UByte>
    
    fun `eciesDecrypt`(`msg`: List<kotlin.UByte>): List<kotlin.UByte>
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSigner {
    internal object `xpub`: UniffiCallbackInterfaceSignerMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`xpub`(
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `deriveXpub`: UniffiCallbackInterfaceSignerMethod1 {
        override fun callback(`uniffiHandle`: Long,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`deriveXpub`(
                    FfiConverterString.lift(`derivationPath`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `signEcdsa`: UniffiCallbackInterfaceSignerMethod2 {
        override fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`signEcdsa`(
                    FfiConverterSequenceUByte.lift(`msg`),
                    FfiConverterString.lift(`derivationPath`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `signEcdsaRecoverable`: UniffiCallbackInterfaceSignerMethod3 {
        override fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`signEcdsaRecoverable`(
                    FfiConverterSequenceUByte.lift(`msg`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `slip77MasterBlindingKey`: UniffiCallbackInterfaceSignerMethod4 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`slip77MasterBlindingKey`(
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `hmacSha256`: UniffiCallbackInterfaceSignerMethod5 {
        override fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`derivationPath`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`hmacSha256`(
                    FfiConverterSequenceUByte.lift(`msg`),
                    FfiConverterString.lift(`derivationPath`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `eciesEncrypt`: UniffiCallbackInterfaceSignerMethod6 {
        override fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`eciesEncrypt`(
                    FfiConverterSequenceUByte.lift(`msg`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }
    internal object `eciesDecrypt`: UniffiCallbackInterfaceSignerMethod7 {
        override fun callback(`uniffiHandle`: Long,`msg`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSigner.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`eciesDecrypt`(
                    FfiConverterSequenceUByte.lift(`msg`),
                )
            }
            val writeReturn = { value: List<kotlin.UByte> -> uniffiOutReturn.setValue(FfiConverterSequenceUByte.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: SignerException -> FfiConverterTypeSignerError.lower(e) }
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSigner.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSigner.UniffiByValue(
        `xpub`,
        `deriveXpub`,
        `signEcdsa`,
        `signEcdsaRecoverable`,
        `slip77MasterBlindingKey`,
        `hmacSha256`,
        `eciesEncrypt`,
        `eciesDecrypt`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_breez_sdk_liquid_bindings_fn_init_callback_vtable_signer(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeSigner: FfiConverterCallbackInterface<Signer>()




/**
 * @suppress
 */
public object FfiConverterOptionalUInt: FfiConverterRustBuffer<kotlin.UInt?> {
    override fun read(buf: ByteBuffer): kotlin.UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: kotlin.UInt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalLong: FfiConverterRustBuffer<kotlin.Long?> {
    override fun read(buf: ByteBuffer): kotlin.Long? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterLong.read(buf)
    }

    override fun allocationSize(value: kotlin.Long?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterLong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Long?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterLong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalDouble: FfiConverterRustBuffer<kotlin.Double?> {
    override fun read(buf: ByteBuffer): kotlin.Double? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDouble.read(buf)
    }

    override fun allocationSize(value: kotlin.Double?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDouble.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Double?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDouble.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalBoolean: FfiConverterRustBuffer<kotlin.Boolean?> {
    override fun read(buf: ByteBuffer): kotlin.Boolean? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterBoolean.read(buf)
    }

    override fun allocationSize(value: kotlin.Boolean?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterBoolean.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Boolean?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterBoolean.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAssetInfo: FfiConverterRustBuffer<AssetInfo?> {
    override fun read(buf: ByteBuffer): AssetInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAssetInfo.read(buf)
    }

    override fun allocationSize(value: AssetInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAssetInfo.allocationSize(value)
        }
    }

    override fun write(value: AssetInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAssetInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeLnUrlInfo: FfiConverterRustBuffer<LnUrlInfo?> {
    override fun read(buf: ByteBuffer): LnUrlInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeLnUrlInfo.read(buf)
    }

    override fun allocationSize(value: LnUrlInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeLnUrlInfo.allocationSize(value)
        }
    }

    override fun write(value: LnUrlInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeLnUrlInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePayment: FfiConverterRustBuffer<Payment?> {
    override fun read(buf: ByteBuffer): Payment? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePayment.read(buf)
    }

    override fun allocationSize(value: Payment?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePayment.allocationSize(value)
        }
    }

    override fun write(value: Payment?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePayment.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSymbol: FfiConverterRustBuffer<Symbol?> {
    override fun read(buf: ByteBuffer): Symbol? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSymbol.read(buf)
    }

    override fun allocationSize(value: Symbol?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSymbol.allocationSize(value)
        }
    }

    override fun write(value: Symbol?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSymbol.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAmount: FfiConverterRustBuffer<Amount?> {
    override fun read(buf: ByteBuffer): Amount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAmount.read(buf)
    }

    override fun allocationSize(value: Amount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAmount.allocationSize(value)
        }
    }

    override fun write(value: Amount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeListPaymentDetails: FfiConverterRustBuffer<ListPaymentDetails?> {
    override fun read(buf: ByteBuffer): ListPaymentDetails? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeListPaymentDetails.read(buf)
    }

    override fun allocationSize(value: ListPaymentDetails?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeListPaymentDetails.allocationSize(value)
        }
    }

    override fun write(value: ListPaymentDetails?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeListPaymentDetails.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePayAmount: FfiConverterRustBuffer<PayAmount?> {
    override fun read(buf: ByteBuffer): PayAmount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePayAmount.read(buf)
    }

    override fun allocationSize(value: PayAmount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePayAmount.allocationSize(value)
        }
    }

    override fun write(value: PayAmount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePayAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeReceiveAmount: FfiConverterRustBuffer<ReceiveAmount?> {
    override fun read(buf: ByteBuffer): ReceiveAmount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeReceiveAmount.read(buf)
    }

    override fun allocationSize(value: ReceiveAmount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeReceiveAmount.allocationSize(value)
        }
    }

    override fun write(value: ReceiveAmount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeReceiveAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSuccessAction: FfiConverterRustBuffer<SuccessAction?> {
    override fun read(buf: ByteBuffer): SuccessAction? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSuccessAction.read(buf)
    }

    override fun allocationSize(value: SuccessAction?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSuccessAction.allocationSize(value)
        }
    }

    override fun write(value: SuccessAction?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSuccessAction.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSuccessActionProcessed: FfiConverterRustBuffer<SuccessActionProcessed?> {
    override fun read(buf: ByteBuffer): SuccessActionProcessed? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSuccessActionProcessed.read(buf)
    }

    override fun allocationSize(value: SuccessActionProcessed?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSuccessActionProcessed.allocationSize(value)
        }
    }

    override fun write(value: SuccessActionProcessed?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSuccessActionProcessed.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceUByte: FfiConverterRustBuffer<List<kotlin.UByte>?> {
    override fun read(buf: ByteBuffer): List<kotlin.UByte>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceUByte.read(buf)
    }

    override fun allocationSize(value: List<kotlin.UByte>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceUByte.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.UByte>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceUByte.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeAssetMetadata: FfiConverterRustBuffer<List<AssetMetadata>?> {
    override fun read(buf: ByteBuffer): List<AssetMetadata>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeAssetMetadata.read(buf)
    }

    override fun allocationSize(value: List<AssetMetadata>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeAssetMetadata.allocationSize(value)
        }
    }

    override fun write(value: List<AssetMetadata>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeAssetMetadata.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeExternalInputParser: FfiConverterRustBuffer<List<ExternalInputParser>?> {
    override fun read(buf: ByteBuffer): List<ExternalInputParser>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeExternalInputParser.read(buf)
    }

    override fun allocationSize(value: List<ExternalInputParser>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeExternalInputParser.allocationSize(value)
        }
    }

    override fun write(value: List<ExternalInputParser>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeExternalInputParser.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypePaymentState: FfiConverterRustBuffer<List<PaymentState>?> {
    override fun read(buf: ByteBuffer): List<PaymentState>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypePaymentState.read(buf)
    }

    override fun allocationSize(value: List<PaymentState>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypePaymentState.allocationSize(value)
        }
    }

    override fun write(value: List<PaymentState>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypePaymentState.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypePaymentType: FfiConverterRustBuffer<List<PaymentType>?> {
    override fun read(buf: ByteBuffer): List<PaymentType>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypePaymentType.read(buf)
    }

    override fun allocationSize(value: List<PaymentType>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypePaymentType.allocationSize(value)
        }
    }

    override fun write(value: List<PaymentType>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypePaymentType.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypePlugin: FfiConverterRustBuffer<List<Plugin>?> {
    override fun read(buf: ByteBuffer): List<Plugin>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypePlugin.read(buf)
    }

    override fun allocationSize(value: List<Plugin>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypePlugin.allocationSize(value)
        }
    }

    override fun write(value: List<Plugin>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypePlugin.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceUByte: FfiConverterRustBuffer<List<kotlin.UByte>> {
    override fun read(buf: ByteBuffer): List<kotlin.UByte> {
        val len = buf.getInt()
        return List<kotlin.UByte>(len) {
            FfiConverterUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UByte>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UByte>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUByte.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAssetBalance: FfiConverterRustBuffer<List<AssetBalance>> {
    override fun read(buf: ByteBuffer): List<AssetBalance> {
        val len = buf.getInt()
        return List<AssetBalance>(len) {
            FfiConverterTypeAssetBalance.read(buf)
        }
    }

    override fun allocationSize(value: List<AssetBalance>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAssetBalance.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AssetBalance>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAssetBalance.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAssetMetadata: FfiConverterRustBuffer<List<AssetMetadata>> {
    override fun read(buf: ByteBuffer): List<AssetMetadata> {
        val len = buf.getInt()
        return List<AssetMetadata>(len) {
            FfiConverterTypeAssetMetadata.read(buf)
        }
    }

    override fun allocationSize(value: List<AssetMetadata>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAssetMetadata.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AssetMetadata>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAssetMetadata.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeExternalInputParser: FfiConverterRustBuffer<List<ExternalInputParser>> {
    override fun read(buf: ByteBuffer): List<ExternalInputParser> {
        val len = buf.getInt()
        return List<ExternalInputParser>(len) {
            FfiConverterTypeExternalInputParser.read(buf)
        }
    }

    override fun allocationSize(value: List<ExternalInputParser>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeExternalInputParser.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ExternalInputParser>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeExternalInputParser.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer<List<FiatCurrency>> {
    override fun read(buf: ByteBuffer): List<FiatCurrency> {
        val len = buf.getInt()
        return List<FiatCurrency>(len) {
            FfiConverterTypeFiatCurrency.read(buf)
        }
    }

    override fun allocationSize(value: List<FiatCurrency>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFiatCurrency.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FiatCurrency>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFiatCurrency.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLnOfferBlindedPath: FfiConverterRustBuffer<List<LnOfferBlindedPath>> {
    override fun read(buf: ByteBuffer): List<LnOfferBlindedPath> {
        val len = buf.getInt()
        return List<LnOfferBlindedPath>(len) {
            FfiConverterTypeLnOfferBlindedPath.read(buf)
        }
    }

    override fun allocationSize(value: List<LnOfferBlindedPath>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLnOfferBlindedPath.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LnOfferBlindedPath>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLnOfferBlindedPath.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer<List<LocaleOverrides>> {
    override fun read(buf: ByteBuffer): List<LocaleOverrides> {
        val len = buf.getInt()
        return List<LocaleOverrides>(len) {
            FfiConverterTypeLocaleOverrides.read(buf)
        }
    }

    override fun allocationSize(value: List<LocaleOverrides>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLocaleOverrides.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LocaleOverrides>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLocaleOverrides.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer<List<LocalizedName>> {
    override fun read(buf: ByteBuffer): List<LocalizedName> {
        val len = buf.getInt()
        return List<LocalizedName>(len) {
            FfiConverterTypeLocalizedName.read(buf)
        }
    }

    override fun allocationSize(value: List<LocalizedName>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLocalizedName.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LocalizedName>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLocalizedName.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePayment: FfiConverterRustBuffer<List<Payment>> {
    override fun read(buf: ByteBuffer): List<Payment> {
        val len = buf.getInt()
        return List<Payment>(len) {
            FfiConverterTypePayment.read(buf)
        }
    }

    override fun allocationSize(value: List<Payment>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePayment.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Payment>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePayment.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRate: FfiConverterRustBuffer<List<Rate>> {
    override fun read(buf: ByteBuffer): List<Rate> {
        val len = buf.getInt()
        return List<Rate>(len) {
            FfiConverterTypeRate.read(buf)
        }
    }

    override fun allocationSize(value: List<Rate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Rate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRate.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRefundableSwap: FfiConverterRustBuffer<List<RefundableSwap>> {
    override fun read(buf: ByteBuffer): List<RefundableSwap> {
        val len = buf.getInt()
        return List<RefundableSwap>(len) {
            FfiConverterTypeRefundableSwap.read(buf)
        }
    }

    override fun allocationSize(value: List<RefundableSwap>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRefundableSwap.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RefundableSwap>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRefundableSwap.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRouteHint: FfiConverterRustBuffer<List<RouteHint>> {
    override fun read(buf: ByteBuffer): List<RouteHint> {
        val len = buf.getInt()
        return List<RouteHint>(len) {
            FfiConverterTypeRouteHint.read(buf)
        }
    }

    override fun allocationSize(value: List<RouteHint>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRouteHint.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RouteHint>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRouteHint.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer<List<RouteHintHop>> {
    override fun read(buf: ByteBuffer): List<RouteHintHop> {
        val len = buf.getInt()
        return List<RouteHintHop>(len) {
            FfiConverterTypeRouteHintHop.read(buf)
        }
    }

    override fun allocationSize(value: List<RouteHintHop>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRouteHintHop.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RouteHintHop>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRouteHintHop.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentState: FfiConverterRustBuffer<List<PaymentState>> {
    override fun read(buf: ByteBuffer): List<PaymentState> {
        val len = buf.getInt()
        return List<PaymentState>(len) {
            FfiConverterTypePaymentState.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentState>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentState.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentState>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentState.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentType: FfiConverterRustBuffer<List<PaymentType>> {
    override fun read(buf: ByteBuffer): List<PaymentType> {
        val len = buf.getInt()
        return List<PaymentType>(len) {
            FfiConverterTypePaymentType.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentType.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePlugin: FfiConverterRustBuffer<List<Plugin>> {
    override fun read(buf: ByteBuffer): List<Plugin> {
        val len = buf.getInt()
        return List<Plugin>(len) {
            FfiConverterTypePlugin.read(buf)
        }
    }

    override fun allocationSize(value: List<Plugin>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePlugin.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Plugin>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePlugin.write(it, buf)
        }
    }
}
    @Throws(SdkException::class) fun `connect`(`req`: ConnectRequest, `plugins`: List<Plugin>?): BindingLiquidSdk {
            return FfiConverterTypeBindingLiquidSdk.lift(
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_func_connect(
        FfiConverterTypeConnectRequest.lower(`req`),FfiConverterOptionalSequenceTypePlugin.lower(`plugins`),_status)
}
    )
    }
    

    @Throws(SdkException::class) fun `connectWithSigner`(`req`: ConnectWithSignerRequest, `signer`: Signer, `plugins`: List<Plugin>?): BindingLiquidSdk {
            return FfiConverterTypeBindingLiquidSdk.lift(
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_func_connect_with_signer(
        FfiConverterTypeConnectWithSignerRequest.lower(`req`),FfiConverterTypeSigner.lower(`signer`),FfiConverterOptionalSequenceTypePlugin.lower(`plugins`),_status)
}
    )
    }
    

    @Throws(SdkException::class) fun `defaultConfig`(`network`: LiquidNetwork, `breezApiKey`: kotlin.String?): Config {
            return FfiConverterTypeConfig.lift(
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_func_default_config(
        FfiConverterTypeLiquidNetwork.lower(`network`),FfiConverterOptionalString.lower(`breezApiKey`),_status)
}
    )
    }
    

    @Throws(PaymentException::class) fun `parseInvoice`(`input`: kotlin.String): LnInvoice {
            return FfiConverterTypeLNInvoice.lift(
    uniffiRustCallWithError(PaymentException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_func_parse_invoice(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

    @Throws(SdkException::class) fun `setLogger`(`logger`: Logger)
        = 
    uniffiRustCallWithError(SdkException) { _status ->
    UniffiLib.INSTANCE.uniffi_breez_sdk_liquid_bindings_fn_func_set_logger(
        FfiConverterTypeLogger.lower(`logger`),_status)
}
    
    


