// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'duplicates.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$LnUrlAuthError {

 String get err;
/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlAuthErrorCopyWith<LnUrlAuthError> get copyWith => _$LnUrlAuthErrorCopyWithImpl<LnUrlAuthError>(this as LnUrlAuthError, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlAuthError&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlAuthError(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlAuthErrorCopyWith<$Res>  {
  factory $LnUrlAuthErrorCopyWith(LnUrlAuthError value, $Res Function(LnUrlAuthError) _then) = _$LnUrlAuthErrorCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlAuthErrorCopyWithImpl<$Res>
    implements $LnUrlAuthErrorCopyWith<$Res> {
  _$LnUrlAuthErrorCopyWithImpl(this._self, this._then);

  final LnUrlAuthError _self;
  final $Res Function(LnUrlAuthError) _then;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? err = null,}) {
  return _then(_self.copyWith(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc


class LnUrlAuthError_Generic extends LnUrlAuthError {
  const LnUrlAuthError_Generic({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlAuthError_GenericCopyWith<LnUrlAuthError_Generic> get copyWith => _$LnUrlAuthError_GenericCopyWithImpl<LnUrlAuthError_Generic>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlAuthError_Generic&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlAuthError.generic(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlAuthError_GenericCopyWith<$Res> implements $LnUrlAuthErrorCopyWith<$Res> {
  factory $LnUrlAuthError_GenericCopyWith(LnUrlAuthError_Generic value, $Res Function(LnUrlAuthError_Generic) _then) = _$LnUrlAuthError_GenericCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlAuthError_GenericCopyWithImpl<$Res>
    implements $LnUrlAuthError_GenericCopyWith<$Res> {
  _$LnUrlAuthError_GenericCopyWithImpl(this._self, this._then);

  final LnUrlAuthError_Generic _self;
  final $Res Function(LnUrlAuthError_Generic) _then;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlAuthError_Generic(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlAuthError_InvalidUri extends LnUrlAuthError {
  const LnUrlAuthError_InvalidUri({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlAuthError_InvalidUriCopyWith<LnUrlAuthError_InvalidUri> get copyWith => _$LnUrlAuthError_InvalidUriCopyWithImpl<LnUrlAuthError_InvalidUri>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlAuthError_InvalidUri&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlAuthError.invalidUri(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlAuthError_InvalidUriCopyWith<$Res> implements $LnUrlAuthErrorCopyWith<$Res> {
  factory $LnUrlAuthError_InvalidUriCopyWith(LnUrlAuthError_InvalidUri value, $Res Function(LnUrlAuthError_InvalidUri) _then) = _$LnUrlAuthError_InvalidUriCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlAuthError_InvalidUriCopyWithImpl<$Res>
    implements $LnUrlAuthError_InvalidUriCopyWith<$Res> {
  _$LnUrlAuthError_InvalidUriCopyWithImpl(this._self, this._then);

  final LnUrlAuthError_InvalidUri _self;
  final $Res Function(LnUrlAuthError_InvalidUri) _then;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlAuthError_InvalidUri(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlAuthError_ServiceConnectivity extends LnUrlAuthError {
  const LnUrlAuthError_ServiceConnectivity({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlAuthError_ServiceConnectivityCopyWith<LnUrlAuthError_ServiceConnectivity> get copyWith => _$LnUrlAuthError_ServiceConnectivityCopyWithImpl<LnUrlAuthError_ServiceConnectivity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlAuthError_ServiceConnectivity&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlAuthError.serviceConnectivity(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlAuthError_ServiceConnectivityCopyWith<$Res> implements $LnUrlAuthErrorCopyWith<$Res> {
  factory $LnUrlAuthError_ServiceConnectivityCopyWith(LnUrlAuthError_ServiceConnectivity value, $Res Function(LnUrlAuthError_ServiceConnectivity) _then) = _$LnUrlAuthError_ServiceConnectivityCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlAuthError_ServiceConnectivityCopyWithImpl<$Res>
    implements $LnUrlAuthError_ServiceConnectivityCopyWith<$Res> {
  _$LnUrlAuthError_ServiceConnectivityCopyWithImpl(this._self, this._then);

  final LnUrlAuthError_ServiceConnectivity _self;
  final $Res Function(LnUrlAuthError_ServiceConnectivity) _then;

/// Create a copy of LnUrlAuthError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlAuthError_ServiceConnectivity(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$LnUrlCallbackStatus {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlCallbackStatus);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LnUrlCallbackStatus()';
}


}

/// @nodoc
class $LnUrlCallbackStatusCopyWith<$Res>  {
$LnUrlCallbackStatusCopyWith(LnUrlCallbackStatus _, $Res Function(LnUrlCallbackStatus) __);
}


/// @nodoc


class LnUrlCallbackStatus_Ok extends LnUrlCallbackStatus {
  const LnUrlCallbackStatus_Ok(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlCallbackStatus_Ok);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LnUrlCallbackStatus.ok()';
}


}




/// @nodoc


class LnUrlCallbackStatus_ErrorStatus extends LnUrlCallbackStatus {
  const LnUrlCallbackStatus_ErrorStatus({required this.data}): super._();
  

 final  LnUrlErrorData data;

/// Create a copy of LnUrlCallbackStatus
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlCallbackStatus_ErrorStatusCopyWith<LnUrlCallbackStatus_ErrorStatus> get copyWith => _$LnUrlCallbackStatus_ErrorStatusCopyWithImpl<LnUrlCallbackStatus_ErrorStatus>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlCallbackStatus_ErrorStatus&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'LnUrlCallbackStatus.errorStatus(data: $data)';
}


}

/// @nodoc
abstract mixin class $LnUrlCallbackStatus_ErrorStatusCopyWith<$Res> implements $LnUrlCallbackStatusCopyWith<$Res> {
  factory $LnUrlCallbackStatus_ErrorStatusCopyWith(LnUrlCallbackStatus_ErrorStatus value, $Res Function(LnUrlCallbackStatus_ErrorStatus) _then) = _$LnUrlCallbackStatus_ErrorStatusCopyWithImpl;
@useResult
$Res call({
 LnUrlErrorData data
});




}
/// @nodoc
class _$LnUrlCallbackStatus_ErrorStatusCopyWithImpl<$Res>
    implements $LnUrlCallbackStatus_ErrorStatusCopyWith<$Res> {
  _$LnUrlCallbackStatus_ErrorStatusCopyWithImpl(this._self, this._then);

  final LnUrlCallbackStatus_ErrorStatus _self;
  final $Res Function(LnUrlCallbackStatus_ErrorStatus) _then;

/// Create a copy of LnUrlCallbackStatus
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(LnUrlCallbackStatus_ErrorStatus(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LnUrlErrorData,
  ));
}


}

/// @nodoc
mixin _$LnUrlPayError {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LnUrlPayError()';
}


}

/// @nodoc
class $LnUrlPayErrorCopyWith<$Res>  {
$LnUrlPayErrorCopyWith(LnUrlPayError _, $Res Function(LnUrlPayError) __);
}


/// @nodoc


class LnUrlPayError_AlreadyPaid extends LnUrlPayError {
  const LnUrlPayError_AlreadyPaid(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_AlreadyPaid);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LnUrlPayError.alreadyPaid()';
}


}




/// @nodoc


class LnUrlPayError_Generic extends LnUrlPayError {
  const LnUrlPayError_Generic({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_GenericCopyWith<LnUrlPayError_Generic> get copyWith => _$LnUrlPayError_GenericCopyWithImpl<LnUrlPayError_Generic>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_Generic&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.generic(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_GenericCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_GenericCopyWith(LnUrlPayError_Generic value, $Res Function(LnUrlPayError_Generic) _then) = _$LnUrlPayError_GenericCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_GenericCopyWithImpl<$Res>
    implements $LnUrlPayError_GenericCopyWith<$Res> {
  _$LnUrlPayError_GenericCopyWithImpl(this._self, this._then);

  final LnUrlPayError_Generic _self;
  final $Res Function(LnUrlPayError_Generic) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_Generic(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InsufficientBalance extends LnUrlPayError {
  const LnUrlPayError_InsufficientBalance({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InsufficientBalanceCopyWith<LnUrlPayError_InsufficientBalance> get copyWith => _$LnUrlPayError_InsufficientBalanceCopyWithImpl<LnUrlPayError_InsufficientBalance>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InsufficientBalance&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.insufficientBalance(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InsufficientBalanceCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InsufficientBalanceCopyWith(LnUrlPayError_InsufficientBalance value, $Res Function(LnUrlPayError_InsufficientBalance) _then) = _$LnUrlPayError_InsufficientBalanceCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InsufficientBalanceCopyWithImpl<$Res>
    implements $LnUrlPayError_InsufficientBalanceCopyWith<$Res> {
  _$LnUrlPayError_InsufficientBalanceCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InsufficientBalance _self;
  final $Res Function(LnUrlPayError_InsufficientBalance) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InsufficientBalance(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InvalidAmount extends LnUrlPayError {
  const LnUrlPayError_InvalidAmount({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InvalidAmountCopyWith<LnUrlPayError_InvalidAmount> get copyWith => _$LnUrlPayError_InvalidAmountCopyWithImpl<LnUrlPayError_InvalidAmount>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InvalidAmount&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.invalidAmount(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InvalidAmountCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InvalidAmountCopyWith(LnUrlPayError_InvalidAmount value, $Res Function(LnUrlPayError_InvalidAmount) _then) = _$LnUrlPayError_InvalidAmountCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InvalidAmountCopyWithImpl<$Res>
    implements $LnUrlPayError_InvalidAmountCopyWith<$Res> {
  _$LnUrlPayError_InvalidAmountCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InvalidAmount _self;
  final $Res Function(LnUrlPayError_InvalidAmount) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InvalidAmount(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InvalidInvoice extends LnUrlPayError {
  const LnUrlPayError_InvalidInvoice({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InvalidInvoiceCopyWith<LnUrlPayError_InvalidInvoice> get copyWith => _$LnUrlPayError_InvalidInvoiceCopyWithImpl<LnUrlPayError_InvalidInvoice>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InvalidInvoice&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.invalidInvoice(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InvalidInvoiceCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InvalidInvoiceCopyWith(LnUrlPayError_InvalidInvoice value, $Res Function(LnUrlPayError_InvalidInvoice) _then) = _$LnUrlPayError_InvalidInvoiceCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InvalidInvoiceCopyWithImpl<$Res>
    implements $LnUrlPayError_InvalidInvoiceCopyWith<$Res> {
  _$LnUrlPayError_InvalidInvoiceCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InvalidInvoice _self;
  final $Res Function(LnUrlPayError_InvalidInvoice) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InvalidInvoice(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InvalidNetwork extends LnUrlPayError {
  const LnUrlPayError_InvalidNetwork({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InvalidNetworkCopyWith<LnUrlPayError_InvalidNetwork> get copyWith => _$LnUrlPayError_InvalidNetworkCopyWithImpl<LnUrlPayError_InvalidNetwork>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InvalidNetwork&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.invalidNetwork(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InvalidNetworkCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InvalidNetworkCopyWith(LnUrlPayError_InvalidNetwork value, $Res Function(LnUrlPayError_InvalidNetwork) _then) = _$LnUrlPayError_InvalidNetworkCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InvalidNetworkCopyWithImpl<$Res>
    implements $LnUrlPayError_InvalidNetworkCopyWith<$Res> {
  _$LnUrlPayError_InvalidNetworkCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InvalidNetwork _self;
  final $Res Function(LnUrlPayError_InvalidNetwork) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InvalidNetwork(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InvalidUri extends LnUrlPayError {
  const LnUrlPayError_InvalidUri({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InvalidUriCopyWith<LnUrlPayError_InvalidUri> get copyWith => _$LnUrlPayError_InvalidUriCopyWithImpl<LnUrlPayError_InvalidUri>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InvalidUri&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.invalidUri(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InvalidUriCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InvalidUriCopyWith(LnUrlPayError_InvalidUri value, $Res Function(LnUrlPayError_InvalidUri) _then) = _$LnUrlPayError_InvalidUriCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InvalidUriCopyWithImpl<$Res>
    implements $LnUrlPayError_InvalidUriCopyWith<$Res> {
  _$LnUrlPayError_InvalidUriCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InvalidUri _self;
  final $Res Function(LnUrlPayError_InvalidUri) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InvalidUri(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_InvoiceExpired extends LnUrlPayError {
  const LnUrlPayError_InvoiceExpired({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_InvoiceExpiredCopyWith<LnUrlPayError_InvoiceExpired> get copyWith => _$LnUrlPayError_InvoiceExpiredCopyWithImpl<LnUrlPayError_InvoiceExpired>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_InvoiceExpired&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.invoiceExpired(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_InvoiceExpiredCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_InvoiceExpiredCopyWith(LnUrlPayError_InvoiceExpired value, $Res Function(LnUrlPayError_InvoiceExpired) _then) = _$LnUrlPayError_InvoiceExpiredCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_InvoiceExpiredCopyWithImpl<$Res>
    implements $LnUrlPayError_InvoiceExpiredCopyWith<$Res> {
  _$LnUrlPayError_InvoiceExpiredCopyWithImpl(this._self, this._then);

  final LnUrlPayError_InvoiceExpired _self;
  final $Res Function(LnUrlPayError_InvoiceExpired) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_InvoiceExpired(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_PaymentFailed extends LnUrlPayError {
  const LnUrlPayError_PaymentFailed({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_PaymentFailedCopyWith<LnUrlPayError_PaymentFailed> get copyWith => _$LnUrlPayError_PaymentFailedCopyWithImpl<LnUrlPayError_PaymentFailed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_PaymentFailed&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.paymentFailed(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_PaymentFailedCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_PaymentFailedCopyWith(LnUrlPayError_PaymentFailed value, $Res Function(LnUrlPayError_PaymentFailed) _then) = _$LnUrlPayError_PaymentFailedCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_PaymentFailedCopyWithImpl<$Res>
    implements $LnUrlPayError_PaymentFailedCopyWith<$Res> {
  _$LnUrlPayError_PaymentFailedCopyWithImpl(this._self, this._then);

  final LnUrlPayError_PaymentFailed _self;
  final $Res Function(LnUrlPayError_PaymentFailed) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_PaymentFailed(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_PaymentTimeout extends LnUrlPayError {
  const LnUrlPayError_PaymentTimeout({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_PaymentTimeoutCopyWith<LnUrlPayError_PaymentTimeout> get copyWith => _$LnUrlPayError_PaymentTimeoutCopyWithImpl<LnUrlPayError_PaymentTimeout>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_PaymentTimeout&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.paymentTimeout(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_PaymentTimeoutCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_PaymentTimeoutCopyWith(LnUrlPayError_PaymentTimeout value, $Res Function(LnUrlPayError_PaymentTimeout) _then) = _$LnUrlPayError_PaymentTimeoutCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_PaymentTimeoutCopyWithImpl<$Res>
    implements $LnUrlPayError_PaymentTimeoutCopyWith<$Res> {
  _$LnUrlPayError_PaymentTimeoutCopyWithImpl(this._self, this._then);

  final LnUrlPayError_PaymentTimeout _self;
  final $Res Function(LnUrlPayError_PaymentTimeout) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_PaymentTimeout(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_RouteNotFound extends LnUrlPayError {
  const LnUrlPayError_RouteNotFound({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_RouteNotFoundCopyWith<LnUrlPayError_RouteNotFound> get copyWith => _$LnUrlPayError_RouteNotFoundCopyWithImpl<LnUrlPayError_RouteNotFound>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_RouteNotFound&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.routeNotFound(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_RouteNotFoundCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_RouteNotFoundCopyWith(LnUrlPayError_RouteNotFound value, $Res Function(LnUrlPayError_RouteNotFound) _then) = _$LnUrlPayError_RouteNotFoundCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_RouteNotFoundCopyWithImpl<$Res>
    implements $LnUrlPayError_RouteNotFoundCopyWith<$Res> {
  _$LnUrlPayError_RouteNotFoundCopyWithImpl(this._self, this._then);

  final LnUrlPayError_RouteNotFound _self;
  final $Res Function(LnUrlPayError_RouteNotFound) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_RouteNotFound(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_RouteTooExpensive extends LnUrlPayError {
  const LnUrlPayError_RouteTooExpensive({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_RouteTooExpensiveCopyWith<LnUrlPayError_RouteTooExpensive> get copyWith => _$LnUrlPayError_RouteTooExpensiveCopyWithImpl<LnUrlPayError_RouteTooExpensive>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_RouteTooExpensive&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.routeTooExpensive(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_RouteTooExpensiveCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_RouteTooExpensiveCopyWith(LnUrlPayError_RouteTooExpensive value, $Res Function(LnUrlPayError_RouteTooExpensive) _then) = _$LnUrlPayError_RouteTooExpensiveCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_RouteTooExpensiveCopyWithImpl<$Res>
    implements $LnUrlPayError_RouteTooExpensiveCopyWith<$Res> {
  _$LnUrlPayError_RouteTooExpensiveCopyWithImpl(this._self, this._then);

  final LnUrlPayError_RouteTooExpensive _self;
  final $Res Function(LnUrlPayError_RouteTooExpensive) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_RouteTooExpensive(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlPayError_ServiceConnectivity extends LnUrlPayError {
  const LnUrlPayError_ServiceConnectivity({required this.err}): super._();
  

 final  String err;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlPayError_ServiceConnectivityCopyWith<LnUrlPayError_ServiceConnectivity> get copyWith => _$LnUrlPayError_ServiceConnectivityCopyWithImpl<LnUrlPayError_ServiceConnectivity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlPayError_ServiceConnectivity&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlPayError.serviceConnectivity(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlPayError_ServiceConnectivityCopyWith<$Res> implements $LnUrlPayErrorCopyWith<$Res> {
  factory $LnUrlPayError_ServiceConnectivityCopyWith(LnUrlPayError_ServiceConnectivity value, $Res Function(LnUrlPayError_ServiceConnectivity) _then) = _$LnUrlPayError_ServiceConnectivityCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlPayError_ServiceConnectivityCopyWithImpl<$Res>
    implements $LnUrlPayError_ServiceConnectivityCopyWith<$Res> {
  _$LnUrlPayError_ServiceConnectivityCopyWithImpl(this._self, this._then);

  final LnUrlPayError_ServiceConnectivity _self;
  final $Res Function(LnUrlPayError_ServiceConnectivity) _then;

/// Create a copy of LnUrlPayError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlPayError_ServiceConnectivity(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$LnUrlWithdrawError {

 String get err;
/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawErrorCopyWith<LnUrlWithdrawError> get copyWith => _$LnUrlWithdrawErrorCopyWithImpl<LnUrlWithdrawError>(this as LnUrlWithdrawError, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawErrorCopyWith<$Res>  {
  factory $LnUrlWithdrawErrorCopyWith(LnUrlWithdrawError value, $Res Function(LnUrlWithdrawError) _then) = _$LnUrlWithdrawErrorCopyWithImpl;
@useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawErrorCopyWithImpl<$Res>
    implements $LnUrlWithdrawErrorCopyWith<$Res> {
  _$LnUrlWithdrawErrorCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError _self;
  final $Res Function(LnUrlWithdrawError) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? err = null,}) {
  return _then(_self.copyWith(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// @nodoc


class LnUrlWithdrawError_Generic extends LnUrlWithdrawError {
  const LnUrlWithdrawError_Generic({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_GenericCopyWith<LnUrlWithdrawError_Generic> get copyWith => _$LnUrlWithdrawError_GenericCopyWithImpl<LnUrlWithdrawError_Generic>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_Generic&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.generic(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_GenericCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_GenericCopyWith(LnUrlWithdrawError_Generic value, $Res Function(LnUrlWithdrawError_Generic) _then) = _$LnUrlWithdrawError_GenericCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_GenericCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_GenericCopyWith<$Res> {
  _$LnUrlWithdrawError_GenericCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_Generic _self;
  final $Res Function(LnUrlWithdrawError_Generic) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_Generic(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlWithdrawError_InvalidAmount extends LnUrlWithdrawError {
  const LnUrlWithdrawError_InvalidAmount({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_InvalidAmountCopyWith<LnUrlWithdrawError_InvalidAmount> get copyWith => _$LnUrlWithdrawError_InvalidAmountCopyWithImpl<LnUrlWithdrawError_InvalidAmount>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_InvalidAmount&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.invalidAmount(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_InvalidAmountCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_InvalidAmountCopyWith(LnUrlWithdrawError_InvalidAmount value, $Res Function(LnUrlWithdrawError_InvalidAmount) _then) = _$LnUrlWithdrawError_InvalidAmountCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_InvalidAmountCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_InvalidAmountCopyWith<$Res> {
  _$LnUrlWithdrawError_InvalidAmountCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_InvalidAmount _self;
  final $Res Function(LnUrlWithdrawError_InvalidAmount) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_InvalidAmount(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlWithdrawError_InvalidInvoice extends LnUrlWithdrawError {
  const LnUrlWithdrawError_InvalidInvoice({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_InvalidInvoiceCopyWith<LnUrlWithdrawError_InvalidInvoice> get copyWith => _$LnUrlWithdrawError_InvalidInvoiceCopyWithImpl<LnUrlWithdrawError_InvalidInvoice>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_InvalidInvoice&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.invalidInvoice(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_InvalidInvoiceCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_InvalidInvoiceCopyWith(LnUrlWithdrawError_InvalidInvoice value, $Res Function(LnUrlWithdrawError_InvalidInvoice) _then) = _$LnUrlWithdrawError_InvalidInvoiceCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_InvalidInvoiceCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_InvalidInvoiceCopyWith<$Res> {
  _$LnUrlWithdrawError_InvalidInvoiceCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_InvalidInvoice _self;
  final $Res Function(LnUrlWithdrawError_InvalidInvoice) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_InvalidInvoice(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlWithdrawError_InvalidUri extends LnUrlWithdrawError {
  const LnUrlWithdrawError_InvalidUri({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_InvalidUriCopyWith<LnUrlWithdrawError_InvalidUri> get copyWith => _$LnUrlWithdrawError_InvalidUriCopyWithImpl<LnUrlWithdrawError_InvalidUri>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_InvalidUri&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.invalidUri(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_InvalidUriCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_InvalidUriCopyWith(LnUrlWithdrawError_InvalidUri value, $Res Function(LnUrlWithdrawError_InvalidUri) _then) = _$LnUrlWithdrawError_InvalidUriCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_InvalidUriCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_InvalidUriCopyWith<$Res> {
  _$LnUrlWithdrawError_InvalidUriCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_InvalidUri _self;
  final $Res Function(LnUrlWithdrawError_InvalidUri) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_InvalidUri(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlWithdrawError_InvoiceNoRoutingHints extends LnUrlWithdrawError {
  const LnUrlWithdrawError_InvoiceNoRoutingHints({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWith<LnUrlWithdrawError_InvoiceNoRoutingHints> get copyWith => _$LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWithImpl<LnUrlWithdrawError_InvoiceNoRoutingHints>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_InvoiceNoRoutingHints&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.invoiceNoRoutingHints(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWith(LnUrlWithdrawError_InvoiceNoRoutingHints value, $Res Function(LnUrlWithdrawError_InvoiceNoRoutingHints) _then) = _$LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWith<$Res> {
  _$LnUrlWithdrawError_InvoiceNoRoutingHintsCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_InvoiceNoRoutingHints _self;
  final $Res Function(LnUrlWithdrawError_InvoiceNoRoutingHints) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_InvoiceNoRoutingHints(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LnUrlWithdrawError_ServiceConnectivity extends LnUrlWithdrawError {
  const LnUrlWithdrawError_ServiceConnectivity({required this.err}): super._();
  

@override final  String err;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawError_ServiceConnectivityCopyWith<LnUrlWithdrawError_ServiceConnectivity> get copyWith => _$LnUrlWithdrawError_ServiceConnectivityCopyWithImpl<LnUrlWithdrawError_ServiceConnectivity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawError_ServiceConnectivity&&(identical(other.err, err) || other.err == err));
}


@override
int get hashCode => Object.hash(runtimeType,err);

@override
String toString() {
  return 'LnUrlWithdrawError.serviceConnectivity(err: $err)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawError_ServiceConnectivityCopyWith<$Res> implements $LnUrlWithdrawErrorCopyWith<$Res> {
  factory $LnUrlWithdrawError_ServiceConnectivityCopyWith(LnUrlWithdrawError_ServiceConnectivity value, $Res Function(LnUrlWithdrawError_ServiceConnectivity) _then) = _$LnUrlWithdrawError_ServiceConnectivityCopyWithImpl;
@override @useResult
$Res call({
 String err
});




}
/// @nodoc
class _$LnUrlWithdrawError_ServiceConnectivityCopyWithImpl<$Res>
    implements $LnUrlWithdrawError_ServiceConnectivityCopyWith<$Res> {
  _$LnUrlWithdrawError_ServiceConnectivityCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawError_ServiceConnectivity _self;
  final $Res Function(LnUrlWithdrawError_ServiceConnectivity) _then;

/// Create a copy of LnUrlWithdrawError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? err = null,}) {
  return _then(LnUrlWithdrawError_ServiceConnectivity(
err: null == err ? _self.err : err // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$LnUrlWithdrawResult {

 Object get data;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawResult&&const DeepCollectionEquality().equals(other.data, data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'LnUrlWithdrawResult(data: $data)';
}


}

/// @nodoc
class $LnUrlWithdrawResultCopyWith<$Res>  {
$LnUrlWithdrawResultCopyWith(LnUrlWithdrawResult _, $Res Function(LnUrlWithdrawResult) __);
}


/// @nodoc


class LnUrlWithdrawResult_Ok extends LnUrlWithdrawResult {
  const LnUrlWithdrawResult_Ok({required this.data}): super._();
  

@override final  LnUrlWithdrawSuccessData data;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawResult_OkCopyWith<LnUrlWithdrawResult_Ok> get copyWith => _$LnUrlWithdrawResult_OkCopyWithImpl<LnUrlWithdrawResult_Ok>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawResult_Ok&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'LnUrlWithdrawResult.ok(data: $data)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawResult_OkCopyWith<$Res> implements $LnUrlWithdrawResultCopyWith<$Res> {
  factory $LnUrlWithdrawResult_OkCopyWith(LnUrlWithdrawResult_Ok value, $Res Function(LnUrlWithdrawResult_Ok) _then) = _$LnUrlWithdrawResult_OkCopyWithImpl;
@useResult
$Res call({
 LnUrlWithdrawSuccessData data
});




}
/// @nodoc
class _$LnUrlWithdrawResult_OkCopyWithImpl<$Res>
    implements $LnUrlWithdrawResult_OkCopyWith<$Res> {
  _$LnUrlWithdrawResult_OkCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawResult_Ok _self;
  final $Res Function(LnUrlWithdrawResult_Ok) _then;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(LnUrlWithdrawResult_Ok(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LnUrlWithdrawSuccessData,
  ));
}


}

/// @nodoc


class LnUrlWithdrawResult_Timeout extends LnUrlWithdrawResult {
  const LnUrlWithdrawResult_Timeout({required this.data}): super._();
  

@override final  LnUrlWithdrawSuccessData data;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawResult_TimeoutCopyWith<LnUrlWithdrawResult_Timeout> get copyWith => _$LnUrlWithdrawResult_TimeoutCopyWithImpl<LnUrlWithdrawResult_Timeout>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawResult_Timeout&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'LnUrlWithdrawResult.timeout(data: $data)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawResult_TimeoutCopyWith<$Res> implements $LnUrlWithdrawResultCopyWith<$Res> {
  factory $LnUrlWithdrawResult_TimeoutCopyWith(LnUrlWithdrawResult_Timeout value, $Res Function(LnUrlWithdrawResult_Timeout) _then) = _$LnUrlWithdrawResult_TimeoutCopyWithImpl;
@useResult
$Res call({
 LnUrlWithdrawSuccessData data
});




}
/// @nodoc
class _$LnUrlWithdrawResult_TimeoutCopyWithImpl<$Res>
    implements $LnUrlWithdrawResult_TimeoutCopyWith<$Res> {
  _$LnUrlWithdrawResult_TimeoutCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawResult_Timeout _self;
  final $Res Function(LnUrlWithdrawResult_Timeout) _then;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(LnUrlWithdrawResult_Timeout(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LnUrlWithdrawSuccessData,
  ));
}


}

/// @nodoc


class LnUrlWithdrawResult_ErrorStatus extends LnUrlWithdrawResult {
  const LnUrlWithdrawResult_ErrorStatus({required this.data}): super._();
  

@override final  LnUrlErrorData data;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LnUrlWithdrawResult_ErrorStatusCopyWith<LnUrlWithdrawResult_ErrorStatus> get copyWith => _$LnUrlWithdrawResult_ErrorStatusCopyWithImpl<LnUrlWithdrawResult_ErrorStatus>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LnUrlWithdrawResult_ErrorStatus&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'LnUrlWithdrawResult.errorStatus(data: $data)';
}


}

/// @nodoc
abstract mixin class $LnUrlWithdrawResult_ErrorStatusCopyWith<$Res> implements $LnUrlWithdrawResultCopyWith<$Res> {
  factory $LnUrlWithdrawResult_ErrorStatusCopyWith(LnUrlWithdrawResult_ErrorStatus value, $Res Function(LnUrlWithdrawResult_ErrorStatus) _then) = _$LnUrlWithdrawResult_ErrorStatusCopyWithImpl;
@useResult
$Res call({
 LnUrlErrorData data
});




}
/// @nodoc
class _$LnUrlWithdrawResult_ErrorStatusCopyWithImpl<$Res>
    implements $LnUrlWithdrawResult_ErrorStatusCopyWith<$Res> {
  _$LnUrlWithdrawResult_ErrorStatusCopyWithImpl(this._self, this._then);

  final LnUrlWithdrawResult_ErrorStatus _self;
  final $Res Function(LnUrlWithdrawResult_ErrorStatus) _then;

/// Create a copy of LnUrlWithdrawResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(LnUrlWithdrawResult_ErrorStatus(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LnUrlErrorData,
  ));
}


}

// dart format on
