// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'bindings.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'model.freezed.dart';

/// An argument when calling [crate::sdk::LiquidSdk::accept_payment_proposed_fees].
class AcceptPaymentProposedFeesRequest {
  final FetchPaymentProposedFeesResponse response;

  const AcceptPaymentProposedFeesRequest({required this.response});

  @override
  int get hashCode => response.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AcceptPaymentProposedFeesRequest &&
          runtimeType == other.runtimeType &&
          response == other.response;
}

/// An asset balance to denote the balance for each asset.
class AssetBalance {
  final String assetId;
  final BigInt balanceSat;
  final String? name;
  final String? ticker;
  final double? balance;

  const AssetBalance({required this.assetId, required this.balanceSat, this.name, this.ticker, this.balance});

  @override
  int get hashCode =>
      assetId.hashCode ^ balanceSat.hashCode ^ name.hashCode ^ ticker.hashCode ^ balance.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetBalance &&
          runtimeType == other.runtimeType &&
          assetId == other.assetId &&
          balanceSat == other.balanceSat &&
          name == other.name &&
          ticker == other.ticker &&
          balance == other.balance;
}

/// Represents the Liquid payment asset info. The asset info is derived from
/// the available [AssetMetadata] that is set in the [Config].
class AssetInfo {
  /// The name of the asset
  final String name;

  /// The ticker of the asset
  final String ticker;

  /// The amount calculated from the satoshi amount of the transaction, having its
  /// decimal shifted to the left by the [precision](AssetMetadata::precision)
  final double amount;

  /// The optional fees when paid using the asset, having its
  /// decimal shifted to the left by the [precision](AssetMetadata::precision)
  final double? fees;

  const AssetInfo({required this.name, required this.ticker, required this.amount, this.fees});

  @override
  int get hashCode => name.hashCode ^ ticker.hashCode ^ amount.hashCode ^ fees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          ticker == other.ticker &&
          amount == other.amount &&
          fees == other.fees;
}

/// Configuration for asset metadata. Each asset metadata item represents an entry in the
/// [Liquid Asset Registry](https://docs.liquid.net/docs/blockstream-liquid-asset-registry).
/// An example Liquid Asset in the registry would be [Tether USD](https://assets.blockstream.info/ce091c998b83c78bb71a632313ba3760f1763d9cfcffae02258ffa9865a37bd2.json>).
class AssetMetadata {
  /// The asset id of the registered asset
  final String assetId;

  /// The name of the asset
  final String name;

  /// The ticker of the asset
  final String ticker;

  /// The precision used to display the asset amount.
  /// For example, precision of 2 shifts the decimal 2 places left from the satoshi amount.
  final int precision;

  /// The optional ID of the fiat currency used to represent the asset
  final String? fiatId;

  const AssetMetadata({
    required this.assetId,
    required this.name,
    required this.ticker,
    required this.precision,
    this.fiatId,
  });

  @override
  int get hashCode =>
      assetId.hashCode ^ name.hashCode ^ ticker.hashCode ^ precision.hashCode ^ fiatId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetMetadata &&
          runtimeType == other.runtimeType &&
          assetId == other.assetId &&
          name == other.name &&
          ticker == other.ticker &&
          precision == other.precision &&
          fiatId == other.fiatId;
}

/// An argument when calling [crate::sdk::LiquidSdk::backup].
class BackupRequest {
  /// Path to the backup.
  ///
  /// If not set, it defaults to `backup.sql` for mainnet, `backup-testnet.sql` for testnet,
  /// and `backup-regtest.sql` for regtest.
  ///
  /// The file will be saved in [ConnectRequest]'s `data_dir`.
  final String? backupPath;

  const BackupRequest({this.backupPath});

  @override
  int get hashCode => backupPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupRequest && runtimeType == other.runtimeType && backupPath == other.backupPath;
}

@freezed
sealed class BlockchainExplorer with _$BlockchainExplorer {
  const BlockchainExplorer._();

  const factory BlockchainExplorer.electrum({required String url}) = BlockchainExplorer_Electrum;
  const factory BlockchainExplorer.esplora({
    required String url,

    /// Whether or not to use the "waterfalls" extension
    required bool useWaterfalls,
  }) = BlockchainExplorer_Esplora;
}

class BlockchainInfo {
  final int liquidTip;
  final int bitcoinTip;

  const BlockchainInfo({required this.liquidTip, required this.bitcoinTip});

  @override
  int get hashCode => liquidTip.hashCode ^ bitcoinTip.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockchainInfo &&
          runtimeType == other.runtimeType &&
          liquidTip == other.liquidTip &&
          bitcoinTip == other.bitcoinTip;
}

/// An argument of [PrepareBuyBitcoinRequest] when calling [crate::sdk::LiquidSdk::prepare_buy_bitcoin].
enum BuyBitcoinProvider { moonpay }

/// An argument when calling [crate::sdk::LiquidSdk::buy_bitcoin].
class BuyBitcoinRequest {
  final PrepareBuyBitcoinResponse prepareResponse;

  /// The optional URL to redirect to after completing the buy.
  ///
  /// For Moonpay, see <https://dev.moonpay.com/docs/on-ramp-configure-user-journey-params>
  final String? redirectUrl;

  const BuyBitcoinRequest({required this.prepareResponse, this.redirectUrl});

  @override
  int get hashCode => prepareResponse.hashCode ^ redirectUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          redirectUrl == other.redirectUrl;
}

/// An argument when calling [crate::sdk::LiquidSdk::check_message].
class CheckMessageRequest {
  /// The message that was signed.
  final String message;

  /// The public key of the node that signed the message.
  final String pubkey;

  /// The zbase encoded signature to verify.
  final String signature;

  const CheckMessageRequest({required this.message, required this.pubkey, required this.signature});

  @override
  int get hashCode => message.hashCode ^ pubkey.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageRequest &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          pubkey == other.pubkey &&
          signature == other.signature;
}

/// Returned when calling [crate::sdk::LiquidSdk::check_message].
class CheckMessageResponse {
  /// Boolean value indicating whether the signature covers the message and
  /// was signed by the given pubkey.
  final bool isValid;

  const CheckMessageResponse({required this.isValid});

  @override
  int get hashCode => isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageResponse && runtimeType == other.runtimeType && isValid == other.isValid;
}

/// Configuration for the Liquid SDK
class Config {
  final BlockchainExplorer liquidExplorer;
  final BlockchainExplorer bitcoinExplorer;

  /// Directory in which the DB and log files are stored.
  ///
  /// Prefix can be a relative or absolute path to this directory.
  final String workingDir;
  final LiquidNetwork network;

  /// Send payment timeout. See [LiquidSdk::send_payment](crate::sdk::LiquidSdk::send_payment)
  final BigInt paymentTimeoutSec;

  /// The url of the real-time sync service. Defaults to [BREEZ_SYNC_SERVICE_URL]
  /// Setting this field to `None` will disable the service
  final String? syncServiceUrl;

  /// Maximum amount in satoshi to accept zero-conf payments with
  /// Defaults to [DEFAULT_ZERO_CONF_MAX_SAT]
  final BigInt? zeroConfMaxAmountSat;

  /// The Breez API key used for making requests to the sync service
  final String? breezApiKey;

  /// A set of external input parsers that are used by [LiquidSdk::parse](crate::sdk::LiquidSdk::parse) when the input
  /// is not recognized. See [ExternalInputParser] for more details on how to configure
  /// external parsing.
  final List<ExternalInputParser>? externalInputParsers;

  /// The SDK includes some default external input parsers
  /// ([DEFAULT_EXTERNAL_INPUT_PARSERS](crate::sdk::DEFAULT_EXTERNAL_INPUT_PARSERS)).
  /// Set this to false in order to prevent their use.
  final bool useDefaultExternalInputParsers;

  /// For payments where the onchain fees can only be estimated on creation, this can be used
  /// in order to automatically allow slightly more expensive fees. If the actual fee ends up
  /// being above the sum of the initial estimate and this leeway, the payment will require
  /// user fee acceptance. See [WaitingFeeAcceptance](PaymentState::WaitingFeeAcceptance).
  ///
  /// Defaults to [DEFAULT_ONCHAIN_FEE_RATE_LEEWAY_SAT].
  final BigInt? onchainFeeRateLeewaySat;

  /// A set of asset metadata used by [LiquidSdk::parse](crate::sdk::LiquidSdk::parse) when the input is a
  /// [LiquidAddressData] and the [asset_id](LiquidAddressData::asset_id) differs from the Liquid Bitcoin asset.
  /// See [AssetMetadata] for more details on how define asset metadata.
  /// By default the asset metadata for Liquid Bitcoin and Tether USD are included.
  final List<AssetMetadata>? assetMetadata;

  /// The SideSwap API key used for making requests to the SideSwap payjoin service
  final String? sideswapApiKey;

  /// Set this to false to disable the use of Magic Routing Hints (MRH) to send payments. Enabled by default.
  final bool useMagicRoutingHints;

  const Config({
    required this.liquidExplorer,
    required this.bitcoinExplorer,
    required this.workingDir,
    required this.network,
    required this.paymentTimeoutSec,
    this.syncServiceUrl,
    this.zeroConfMaxAmountSat,
    this.breezApiKey,
    this.externalInputParsers,
    required this.useDefaultExternalInputParsers,
    this.onchainFeeRateLeewaySat,
    this.assetMetadata,
    this.sideswapApiKey,
    required this.useMagicRoutingHints,
  });

  @override
  int get hashCode =>
      liquidExplorer.hashCode ^
      bitcoinExplorer.hashCode ^
      workingDir.hashCode ^
      network.hashCode ^
      paymentTimeoutSec.hashCode ^
      syncServiceUrl.hashCode ^
      zeroConfMaxAmountSat.hashCode ^
      breezApiKey.hashCode ^
      externalInputParsers.hashCode ^
      useDefaultExternalInputParsers.hashCode ^
      onchainFeeRateLeewaySat.hashCode ^
      assetMetadata.hashCode ^
      sideswapApiKey.hashCode ^
      useMagicRoutingHints.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          liquidExplorer == other.liquidExplorer &&
          bitcoinExplorer == other.bitcoinExplorer &&
          workingDir == other.workingDir &&
          network == other.network &&
          paymentTimeoutSec == other.paymentTimeoutSec &&
          syncServiceUrl == other.syncServiceUrl &&
          zeroConfMaxAmountSat == other.zeroConfMaxAmountSat &&
          breezApiKey == other.breezApiKey &&
          externalInputParsers == other.externalInputParsers &&
          useDefaultExternalInputParsers == other.useDefaultExternalInputParsers &&
          onchainFeeRateLeewaySat == other.onchainFeeRateLeewaySat &&
          assetMetadata == other.assetMetadata &&
          sideswapApiKey == other.sideswapApiKey &&
          useMagicRoutingHints == other.useMagicRoutingHints;
}

/// An argument when calling [crate::sdk::LiquidSdk::connect].
/// The resquest takes either a `mnemonic` and `passphrase`, or a `seed`.
class ConnectRequest {
  /// The SDK [Config]
  final Config config;

  /// The optional Liquid wallet mnemonic
  final String? mnemonic;

  /// The optional passphrase for the mnemonic
  final String? passphrase;

  /// The optional Liquid wallet seed
  final Uint8List? seed;

  const ConnectRequest({required this.config, this.mnemonic, this.passphrase, this.seed});

  @override
  int get hashCode => config.hashCode ^ mnemonic.hashCode ^ passphrase.hashCode ^ seed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          mnemonic == other.mnemonic &&
          passphrase == other.passphrase &&
          seed == other.seed;
}

/// An argument when calling [crate::sdk::LiquidSdk::create_bolt12_invoice].
class CreateBolt12InvoiceRequest {
  /// The BOLT12 offer
  final String offer;

  /// The invoice request created from the offer
  final String invoiceRequest;

  const CreateBolt12InvoiceRequest({required this.offer, required this.invoiceRequest});

  @override
  int get hashCode => offer.hashCode ^ invoiceRequest.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateBolt12InvoiceRequest &&
          runtimeType == other.runtimeType &&
          offer == other.offer &&
          invoiceRequest == other.invoiceRequest;
}

/// Returned when calling [crate::sdk::LiquidSdk::create_bolt12_invoice].
class CreateBolt12InvoiceResponse {
  /// The BOLT12 invoice
  final String invoice;

  const CreateBolt12InvoiceResponse({required this.invoice});

  @override
  int get hashCode => invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateBolt12InvoiceResponse && runtimeType == other.runtimeType && invoice == other.invoice;
}

/// An argument when calling [crate::sdk::LiquidSdk::fetch_payment_proposed_fees].
class FetchPaymentProposedFeesRequest {
  final String swapId;

  const FetchPaymentProposedFeesRequest({required this.swapId});

  @override
  int get hashCode => swapId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchPaymentProposedFeesRequest && runtimeType == other.runtimeType && swapId == other.swapId;
}

/// Returned when calling [crate::sdk::LiquidSdk::fetch_payment_proposed_fees].
class FetchPaymentProposedFeesResponse {
  final String swapId;
  final BigInt feesSat;

  /// Amount sent by the swap payer
  final BigInt payerAmountSat;

  /// Amount that will be received if these fees are accepted
  final BigInt receiverAmountSat;

  const FetchPaymentProposedFeesResponse({
    required this.swapId,
    required this.feesSat,
    required this.payerAmountSat,
    required this.receiverAmountSat,
  });

  @override
  int get hashCode =>
      swapId.hashCode ^ feesSat.hashCode ^ payerAmountSat.hashCode ^ receiverAmountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchPaymentProposedFeesResponse &&
          runtimeType == other.runtimeType &&
          swapId == other.swapId &&
          feesSat == other.feesSat &&
          payerAmountSat == other.payerAmountSat &&
          receiverAmountSat == other.receiverAmountSat;
}

/// Returned when calling [crate::sdk::LiquidSdk::get_info].
class GetInfoResponse {
  /// The wallet information, such as the balance, fingerprint and public key
  final WalletInfo walletInfo;

  /// The latest synced blockchain information, such as the Liquid/Bitcoin tips
  final BlockchainInfo blockchainInfo;

  const GetInfoResponse({required this.walletInfo, required this.blockchainInfo});

  @override
  int get hashCode => walletInfo.hashCode ^ blockchainInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoResponse &&
          runtimeType == other.runtimeType &&
          walletInfo == other.walletInfo &&
          blockchainInfo == other.blockchainInfo;
}

@freezed
sealed class GetPaymentRequest with _$GetPaymentRequest {
  const GetPaymentRequest._();

  /// The payment hash of a Lightning payment
  const factory GetPaymentRequest.paymentHash({required String paymentHash}) = GetPaymentRequest_PaymentHash;

  /// A swap id or its SHA256 hash
  const factory GetPaymentRequest.swapId({required String swapId}) = GetPaymentRequest_SwapId;
}

/// Returned when calling [crate::sdk::LiquidSdk::fetch_lightning_limits].
class LightningPaymentLimitsResponse {
  /// Amount limits for a Send Payment to be valid
  final Limits send;

  /// Amount limits for a Receive Payment to be valid
  final Limits receive;

  const LightningPaymentLimitsResponse({required this.send, required this.receive});

  @override
  int get hashCode => send.hashCode ^ receive.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightningPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          send == other.send &&
          receive == other.receive;
}

/// The minimum and maximum in satoshis of a Lightning or onchain payment.
class Limits {
  final BigInt minSat;
  final BigInt maxSat;
  final BigInt maxZeroConfSat;

  const Limits({required this.minSat, required this.maxSat, required this.maxZeroConfSat});

  @override
  int get hashCode => minSat.hashCode ^ maxSat.hashCode ^ maxZeroConfSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Limits &&
          runtimeType == other.runtimeType &&
          minSat == other.minSat &&
          maxSat == other.maxSat &&
          maxZeroConfSat == other.maxZeroConfSat;
}

/// Network chosen for this Liquid SDK instance. Note that it represents both the Liquid and the
/// Bitcoin network used.
enum LiquidNetwork {
  /// Mainnet Bitcoin and Liquid chains
  mainnet,

  /// Testnet Bitcoin and Liquid chains
  testnet,

  /// Regtest Bitcoin and Liquid chains
  regtest,
}

@freezed
sealed class ListPaymentDetails with _$ListPaymentDetails {
  const ListPaymentDetails._();

  /// A Liquid payment
  const factory ListPaymentDetails.liquid({
    /// Optional asset id
    String? assetId,

    /// Optional BIP21 URI or address
    String? destination,
  }) = ListPaymentDetails_Liquid;

  /// A Bitcoin payment
  const factory ListPaymentDetails.bitcoin({
    /// Optional address
    String? address,
  }) = ListPaymentDetails_Bitcoin;
}

/// An argument when calling [crate::sdk::LiquidSdk::list_payments].
class ListPaymentsRequest {
  final List<PaymentType>? filters;
  final List<PaymentState>? states;

  /// Epoch time, in seconds
  final PlatformInt64? fromTimestamp;

  /// Epoch time, in seconds
  final PlatformInt64? toTimestamp;
  final int? offset;
  final int? limit;
  final ListPaymentDetails? details;
  final bool? sortAscending;

  const ListPaymentsRequest({
    this.filters,
    this.states,
    this.fromTimestamp,
    this.toTimestamp,
    this.offset,
    this.limit,
    this.details,
    this.sortAscending,
  });

  @override
  int get hashCode =>
      filters.hashCode ^
      states.hashCode ^
      fromTimestamp.hashCode ^
      toTimestamp.hashCode ^
      offset.hashCode ^
      limit.hashCode ^
      details.hashCode ^
      sortAscending.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          filters == other.filters &&
          states == other.states &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          offset == other.offset &&
          limit == other.limit &&
          details == other.details &&
          sortAscending == other.sortAscending;
}

/// Represents the payment LNURL info
class LnUrlInfo {
  final String? lnAddress;
  final String? lnurlPayComment;
  final String? lnurlPayDomain;
  final String? lnurlPayMetadata;
  final SuccessActionProcessed? lnurlPaySuccessAction;
  final SuccessAction? lnurlPayUnprocessedSuccessAction;
  final String? lnurlWithdrawEndpoint;

  const LnUrlInfo({
    this.lnAddress,
    this.lnurlPayComment,
    this.lnurlPayDomain,
    this.lnurlPayMetadata,
    this.lnurlPaySuccessAction,
    this.lnurlPayUnprocessedSuccessAction,
    this.lnurlWithdrawEndpoint,
  });

  @override
  int get hashCode =>
      lnAddress.hashCode ^
      lnurlPayComment.hashCode ^
      lnurlPayDomain.hashCode ^
      lnurlPayMetadata.hashCode ^
      lnurlPaySuccessAction.hashCode ^
      lnurlPayUnprocessedSuccessAction.hashCode ^
      lnurlWithdrawEndpoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlInfo &&
          runtimeType == other.runtimeType &&
          lnAddress == other.lnAddress &&
          lnurlPayComment == other.lnurlPayComment &&
          lnurlPayDomain == other.lnurlPayDomain &&
          lnurlPayMetadata == other.lnurlPayMetadata &&
          lnurlPaySuccessAction == other.lnurlPaySuccessAction &&
          lnurlPayUnprocessedSuccessAction == other.lnurlPayUnprocessedSuccessAction &&
          lnurlWithdrawEndpoint == other.lnurlWithdrawEndpoint;
}

/// An argument when calling [crate::sdk::LiquidSdk::lnurl_pay].
class LnUrlPayRequest {
  /// The response from calling [crate::sdk::LiquidSdk::prepare_lnurl_pay]
  final PrepareLnUrlPayResponse prepareResponse;

  const LnUrlPayRequest({required this.prepareResponse});

  @override
  int get hashCode => prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse;
}

@freezed
sealed class LnUrlPayResult with _$LnUrlPayResult {
  const LnUrlPayResult._();

  const factory LnUrlPayResult.endpointSuccess({required LnUrlPaySuccessData data}) =
      LnUrlPayResult_EndpointSuccess;
  const factory LnUrlPayResult.endpointError({required LnUrlErrorData data}) = LnUrlPayResult_EndpointError;
  const factory LnUrlPayResult.payError({required LnUrlPayErrorData data}) = LnUrlPayResult_PayError;
}

class LnUrlPaySuccessData {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnUrlPaySuccessData({required this.payment, this.successAction});

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPaySuccessData &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

/// Internal SDK log entry used in the Uniffi and Dart bindings
class LogEntry {
  final String line;
  final String level;

  const LogEntry({required this.line, required this.level});

  @override
  int get hashCode => line.hashCode ^ level.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry && runtimeType == other.runtimeType && line == other.line && level == other.level;
}

/// Returned when calling [crate::sdk::LiquidSdk::fetch_onchain_limits].
class OnchainPaymentLimitsResponse {
  /// Amount limits for a Send Onchain Payment to be valid
  final Limits send;

  /// Amount limits for a Receive Onchain Payment to be valid
  final Limits receive;

  const OnchainPaymentLimitsResponse({required this.send, required this.receive});

  @override
  int get hashCode => send.hashCode ^ receive.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnchainPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          send == other.send &&
          receive == other.receive;
}

@freezed
sealed class PayAmount with _$PayAmount {
  const PayAmount._();

  /// The amount in satoshi that will be received
  const factory PayAmount.bitcoin({required BigInt receiverAmountSat}) = PayAmount_Bitcoin;

  /// The amount of an asset that will be received
  const factory PayAmount.asset({
    required String assetId,
    required double receiverAmount,
    bool? estimateAssetFees,

    /// Specifies whether or not to always use the wallet's L-BTC to execute the payment.
    /// If true, it will try swapping the asset via the [Side Swap Service](crate::side_swap::api::SideSwapService)
    bool? payWithBitcoin,
  }) = PayAmount_Asset;

  /// Indicates that all available Bitcoin funds should be sent
  const factory PayAmount.drain() = PayAmount_Drain;
}

/// An argument when calling [crate::sdk::LiquidSdk::pay_onchain].
class PayOnchainRequest {
  final String address;
  final PreparePayOnchainResponse prepareResponse;

  const PayOnchainRequest({required this.address, required this.prepareResponse});

  @override
  int get hashCode => address.hashCode ^ prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainRequest &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          prepareResponse == other.prepareResponse;
}

/// Represents an SDK payment.
///
/// By default, this is an onchain tx. It may represent a swap, if swap metadata is available.
class Payment {
  /// The destination associated with the payment, if it was created via our SDK.
  /// Can be either a Liquid/Bitcoin address, a Liquid BIP21 URI or an invoice
  final String? destination;
  final String? txId;

  /// Data to use in the `blinded` param when unblinding the transaction in an explorer.
  /// See: <https://docs.liquid.net/docs/unblinding-transactions>
  final String? unblindingData;

  /// Composite timestamp that can be used for sorting or displaying the payment.
  ///
  /// If this payment has an associated swap, it is the swap creation time. Otherwise, the point
  /// in time when the underlying tx was included in a block. If there is no associated swap
  /// available and the underlying tx is not yet confirmed, the value is `now()`.
  final int timestamp;

  /// The payment amount, which corresponds to the onchain tx amount.
  ///
  /// In case of an outbound payment (Send), this is the payer amount. Otherwise it's the receiver amount.
  final BigInt amountSat;

  /// Represents the fees paid by this wallet for this payment.
  ///
  /// ### Swaps
  /// If there is an associated Send Swap, these fees represent the total fees paid by this wallet
  /// (the sender). It is the difference between the amount that was sent and the amount received.
  ///
  /// If there is an associated Receive Swap, these fees represent the total fees paid by this wallet
  /// (the receiver). It is also the difference between the amount that was sent and the amount received.
  ///
  /// ### Pure onchain txs
  /// If no swap is associated with this payment:
  /// - for Send payments, this is the onchain tx fee
  /// - for Receive payments, this is zero
  final BigInt feesSat;

  /// Service fees paid to the swapper service. This is only set for swaps (i.e. doesn't apply to
  /// direct Liquid payments).
  final BigInt? swapperFeesSat;

  /// If it is a `Send` or `Receive` payment
  final PaymentType paymentType;

  /// Composite status representing the overall status of the payment.
  ///
  /// If the tx has no associated swap, this reflects the onchain tx status (confirmed or not).
  ///
  /// If the tx has an associated swap, this is determined by the swap status (pending or complete).
  final PaymentState status;

  /// The details of a payment, depending on its [destination](Payment::destination) and
  /// [type](Payment::payment_type)
  final PaymentDetails details;

  const Payment({
    this.destination,
    this.txId,
    this.unblindingData,
    required this.timestamp,
    required this.amountSat,
    required this.feesSat,
    this.swapperFeesSat,
    required this.paymentType,
    required this.status,
    required this.details,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      txId.hashCode ^
      unblindingData.hashCode ^
      timestamp.hashCode ^
      amountSat.hashCode ^
      feesSat.hashCode ^
      swapperFeesSat.hashCode ^
      paymentType.hashCode ^
      status.hashCode ^
      details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          txId == other.txId &&
          unblindingData == other.unblindingData &&
          timestamp == other.timestamp &&
          amountSat == other.amountSat &&
          feesSat == other.feesSat &&
          swapperFeesSat == other.swapperFeesSat &&
          paymentType == other.paymentType &&
          status == other.status &&
          details == other.details;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  /// Swapping to or from Lightning
  const factory PaymentDetails.lightning({
    required String swapId,

    /// Represents the invoice description
    required String description,

    /// The height of the block at which the swap will no longer be valid
    required int liquidExpirationBlockheight,

    /// The preimage of the paid invoice (proof of payment).
    String? preimage,

    /// Represents the Bolt11/Bolt12 invoice associated with a payment
    /// In the case of a Send payment, this is the invoice paid by the swapper
    /// In the case of a Receive payment, this is the invoice paid by the user
    String? invoice,
    String? bolt12Offer,

    /// The payment hash of the invoice
    String? paymentHash,

    /// The invoice destination/payee pubkey
    String? destinationPubkey,

    /// The payment LNURL info
    LnUrlInfo? lnurlInfo,

    /// The BIP353 address used to resolve this payment
    String? bip353Address,

    /// The payer note
    String? payerNote,

    /// For a Receive payment, this is the claim tx id in case it has already been broadcast
    String? claimTxId,

    /// For a Send swap which was refunded, this is the refund tx id
    String? refundTxId,

    /// For a Send swap which was refunded, this is the refund amount
    BigInt? refundTxAmountSat,
  }) = PaymentDetails_Lightning;

  /// Direct onchain payment to a Liquid address
  const factory PaymentDetails.liquid({
    /// Represents either a Liquid BIP21 URI or pure address
    required String destination,

    /// Represents the BIP21 `message` field
    required String description,

    /// The asset id
    required String assetId,

    /// The asset info derived from the [AssetMetadata]
    AssetInfo? assetInfo,

    /// The payment LNURL info
    LnUrlInfo? lnurlInfo,

    /// The BIP353 address used to resolve this payment
    String? bip353Address,

    /// The payer note
    String? payerNote,
  }) = PaymentDetails_Liquid;

  /// Swapping to or from the Bitcoin chain
  const factory PaymentDetails.bitcoin({
    required String swapId,

    /// The Bitcoin address that receives funds.
    required String bitcoinAddress,

    /// Represents the invoice description
    required String description,

    /// For an amountless receive swap, this indicates if fees were automatically accepted.
    /// Fees are auto accepted when the swapper proposes fees that are within the initial
    /// estimate, plus the `onchain_fee_rate_leeway_sat_per_vbyte` set in the [Config], if any.
    required bool autoAcceptedFees,

    /// The height of the Liquid block at which the swap will no longer be valid
    /// It should always be populated in case of an outgoing chain swap
    int? liquidExpirationBlockheight,

    /// The height of the Bitcoin block at which the swap will no longer be valid
    /// It should always be populated in case of an incoming chain swap
    int? bitcoinExpirationBlockheight,

    /// The lockup tx id that initiates the swap
    String? lockupTxId,

    /// The claim tx id that claims the server lockup tx
    String? claimTxId,

    /// For a Send swap which was refunded, this is the refund tx id
    String? refundTxId,

    /// For a Send swap which was refunded, this is the refund amount
    BigInt? refundTxAmountSat,
  }) = PaymentDetails_Bitcoin;
}

/// The send/receive methods supported by the SDK
enum PaymentMethod { lightning, bolt11Invoice, bolt12Offer, bitcoinAddress, liquidAddress }

/// The payment state of an individual payment.
enum PaymentState {
  created,

  /// ## Receive Swaps
  ///
  /// Covers the cases when
  /// - the lockup tx is seen in the mempool or
  /// - our claim tx is broadcast
  ///
  /// When the claim tx is broadcast, `claim_tx_id` is set in the swap.
  ///
  /// ## Send Swaps
  ///
  /// This is the status when our lockup tx was broadcast
  ///
  /// ## Chain Swaps
  ///
  /// This is the status when the user lockup tx was broadcast
  ///
  /// ## No swap data available
  ///
  /// If no associated swap is found, this indicates the underlying tx is not confirmed yet.
  pending,

  /// ## Receive Swaps
  ///
  /// Covers the case when the claim tx is confirmed.
  ///
  /// ## Send and Chain Swaps
  ///
  /// This is the status when the claim tx is broadcast and we see it in the mempool.
  ///
  /// ## No swap data available
  ///
  /// If no associated swap is found, this indicates the underlying tx is confirmed.
  complete,

  /// ## Receive Swaps
  ///
  /// This is the status when the swap failed for any reason and the Receive could not complete.
  ///
  /// ## Send and Chain Swaps
  ///
  /// This is the status when a swap refund was initiated and the refund tx is confirmed.
  failed,

  /// ## Send and Outgoing Chain Swaps
  ///
  /// This covers the case when the swap state is still Created and the swap fails to reach the
  /// Pending state in time. The TimedOut state indicates the lockup tx should never be broadcast.
  timedOut,

  /// ## Incoming Chain Swaps
  ///
  /// This covers the case when the swap failed for any reason and there is a user lockup tx.
  /// The swap in this case has to be manually refunded with a provided Bitcoin address
  refundable,

  /// ## Send and Chain Swaps
  ///
  /// This is the status when a refund was initiated and/or our refund tx was broadcast
  ///
  /// When the refund tx is broadcast, `refund_tx_id` is set in the swap.
  refundPending,

  /// ## Chain Swaps
  ///
  /// This is the state when the user needs to accept new fees before the payment can proceed.
  ///
  /// Use [LiquidSdk::fetch_payment_proposed_fees](crate::sdk::LiquidSdk::fetch_payment_proposed_fees)
  /// to find out the current fees and
  /// [LiquidSdk::accept_payment_proposed_fees](crate::sdk::LiquidSdk::accept_payment_proposed_fees)
  /// to accept them, allowing the payment to proceed.
  ///
  /// Otherwise, this payment can be immediately refunded using
  /// [prepare_refund](crate::sdk::LiquidSdk::prepare_refund)/[refund](crate::sdk::LiquidSdk::refund).
  waitingFeeAcceptance,
}

enum PaymentType { receive, send }

/// An argument when calling [crate::sdk::LiquidSdk::prepare_buy_bitcoin].
class PrepareBuyBitcoinRequest {
  final BuyBitcoinProvider provider;
  final BigInt amountSat;

  const PrepareBuyBitcoinRequest({required this.provider, required this.amountSat});

  @override
  int get hashCode => provider.hashCode ^ amountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareBuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          amountSat == other.amountSat;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_buy_bitcoin].
class PrepareBuyBitcoinResponse {
  final BuyBitcoinProvider provider;
  final BigInt amountSat;
  final BigInt feesSat;

  const PrepareBuyBitcoinResponse({required this.provider, required this.amountSat, required this.feesSat});

  @override
  int get hashCode => provider.hashCode ^ amountSat.hashCode ^ feesSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareBuyBitcoinResponse &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          amountSat == other.amountSat &&
          feesSat == other.feesSat;
}

/// An argument when calling [crate::sdk::LiquidSdk::prepare_lnurl_pay].
class PrepareLnUrlPayRequest {
  /// The [LnUrlPayRequestData] returned by [parse]
  final LnUrlPayRequestData data;

  /// The amount to send
  final PayAmount amount;

  /// A BIP353 address, in case one was used in order to fetch the LNURL Pay request data.
  /// Returned by [parse].
  final String? bip353Address;

  /// An optional comment LUD-12 to be stored with the payment. The comment is included in the
  /// invoice request sent to the LNURL endpoint.
  final String? comment;

  /// Validates that, if there is a URL success action, the URL domain matches
  /// the LNURL callback domain. Defaults to `true`
  final bool? validateSuccessActionUrl;

  const PrepareLnUrlPayRequest({
    required this.data,
    required this.amount,
    this.bip353Address,
    this.comment,
    this.validateSuccessActionUrl,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      amount.hashCode ^
      bip353Address.hashCode ^
      comment.hashCode ^
      validateSuccessActionUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnUrlPayRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          amount == other.amount &&
          bip353Address == other.bip353Address &&
          comment == other.comment &&
          validateSuccessActionUrl == other.validateSuccessActionUrl;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_lnurl_pay].
class PrepareLnUrlPayResponse {
  /// The destination of the payment
  final SendDestination destination;

  /// The fees in satoshis to send the payment
  final BigInt feesSat;

  /// The [LnUrlPayRequestData] returned by [parse]
  final LnUrlPayRequestData data;

  /// The amount to send
  final PayAmount amount;

  /// An optional comment LUD-12 to be stored with the payment. The comment is included in the
  /// invoice request sent to the LNURL endpoint.
  final String? comment;

  /// The unprocessed LUD-09 success action. This will be processed and decrypted if
  /// needed after calling [crate::sdk::LiquidSdk::lnurl_pay]
  final SuccessAction? successAction;

  const PrepareLnUrlPayResponse({
    required this.destination,
    required this.feesSat,
    required this.data,
    required this.amount,
    this.comment,
    this.successAction,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      feesSat.hashCode ^
      data.hashCode ^
      amount.hashCode ^
      comment.hashCode ^
      successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnUrlPayResponse &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          feesSat == other.feesSat &&
          data == other.data &&
          amount == other.amount &&
          comment == other.comment &&
          successAction == other.successAction;
}

/// An argument when calling [crate::sdk::LiquidSdk::prepare_pay_onchain].
class PreparePayOnchainRequest {
  /// The amount to send
  final PayAmount amount;

  /// The optional fee rate of the Bitcoin claim transaction in sat/vB. Defaults to the swapper estimated claim fee.
  final int? feeRateSatPerVbyte;

  const PreparePayOnchainRequest({required this.amount, this.feeRateSatPerVbyte});

  @override
  int get hashCode => amount.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PreparePayOnchainRequest &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_pay_onchain].
class PreparePayOnchainResponse {
  final BigInt receiverAmountSat;
  final BigInt claimFeesSat;
  final BigInt totalFeesSat;

  const PreparePayOnchainResponse({
    required this.receiverAmountSat,
    required this.claimFeesSat,
    required this.totalFeesSat,
  });

  @override
  int get hashCode => receiverAmountSat.hashCode ^ claimFeesSat.hashCode ^ totalFeesSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PreparePayOnchainResponse &&
          runtimeType == other.runtimeType &&
          receiverAmountSat == other.receiverAmountSat &&
          claimFeesSat == other.claimFeesSat &&
          totalFeesSat == other.totalFeesSat;
}

/// An argument when calling [crate::sdk::LiquidSdk::prepare_receive_payment].
class PrepareReceiveRequest {
  final PaymentMethod paymentMethod;

  /// The amount to be paid in either Bitcoin or another asset
  final ReceiveAmount? amount;

  const PrepareReceiveRequest({required this.paymentMethod, this.amount});

  @override
  int get hashCode => paymentMethod.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareReceiveRequest &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod &&
          amount == other.amount;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_receive_payment].
class PrepareReceiveResponse {
  final PaymentMethod paymentMethod;

  /// Generally represents the total fees that would be paid to send or receive this payment.
  ///
  /// In case of Zero-Amount Receive Chain swaps, the swapper service fee (`swapper_feerate` times
  /// the amount) is paid in addition to `fees_sat`. The swapper service feerate is already known
  /// in the beginning, but the exact swapper service fee will only be known when the
  /// `payer_amount_sat` is known.
  ///
  /// In all other types of swaps, the swapper service fee is included in `fees_sat`.
  final BigInt feesSat;

  /// The amount to be paid in either Bitcoin or another asset
  final ReceiveAmount? amount;

  /// The minimum amount the payer can send for this swap to succeed.
  ///
  /// When the method is [PaymentMethod::LiquidAddress], this is empty.
  final BigInt? minPayerAmountSat;

  /// The maximum amount the payer can send for this swap to succeed.
  ///
  /// When the method is [PaymentMethod::LiquidAddress], this is empty.
  final BigInt? maxPayerAmountSat;

  /// The percentage of the sent amount that will count towards the service fee.
  ///
  /// When the method is [PaymentMethod::LiquidAddress], this is empty.
  final double? swapperFeerate;

  const PrepareReceiveResponse({
    required this.paymentMethod,
    required this.feesSat,
    this.amount,
    this.minPayerAmountSat,
    this.maxPayerAmountSat,
    this.swapperFeerate,
  });

  @override
  int get hashCode =>
      paymentMethod.hashCode ^
      feesSat.hashCode ^
      amount.hashCode ^
      minPayerAmountSat.hashCode ^
      maxPayerAmountSat.hashCode ^
      swapperFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareReceiveResponse &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod &&
          feesSat == other.feesSat &&
          amount == other.amount &&
          minPayerAmountSat == other.minPayerAmountSat &&
          maxPayerAmountSat == other.maxPayerAmountSat &&
          swapperFeerate == other.swapperFeerate;
}

/// An argument when calling [crate::sdk::LiquidSdk::prepare_refund].
class PrepareRefundRequest {
  /// The address where the swap funds are locked up
  final String swapAddress;

  /// The address to refund the swap funds to
  final String refundAddress;

  /// The fee rate in sat/vB for the refund transaction
  final int feeRateSatPerVbyte;

  const PrepareRefundRequest({
    required this.swapAddress,
    required this.refundAddress,
    required this.feeRateSatPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ refundAddress.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          refundAddress == other.refundAddress &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_refund].
class PrepareRefundResponse {
  final int txVsize;
  final BigInt txFeeSat;

  /// The txid of the last broadcasted refund tx, if any
  final String? lastRefundTxId;

  const PrepareRefundResponse({required this.txVsize, required this.txFeeSat, this.lastRefundTxId});

  @override
  int get hashCode => txVsize.hashCode ^ txFeeSat.hashCode ^ lastRefundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundResponse &&
          runtimeType == other.runtimeType &&
          txVsize == other.txVsize &&
          txFeeSat == other.txFeeSat &&
          lastRefundTxId == other.lastRefundTxId;
}

/// An argument when calling [crate::sdk::LiquidSdk::prepare_send_payment].
class PrepareSendRequest {
  /// The destination we intend to pay to.
  /// Supports BIP21 URIs, BOLT11 invoices, BOLT12 offers and Liquid addresses
  final String destination;

  /// Should only be set when paying directly onchain or to a BIP21 URI
  /// where no amount is specified, or when the caller wishes to drain
  final PayAmount? amount;

  const PrepareSendRequest({required this.destination, this.amount});

  @override
  int get hashCode => destination.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendRequest &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          amount == other.amount;
}

/// Returned when calling [crate::sdk::LiquidSdk::prepare_send_payment].
class PrepareSendResponse {
  final SendDestination destination;

  /// The optional amount to be sent in either Bitcoin or another asset
  final PayAmount? amount;

  /// The optional estimated fee in satoshi. Is set when there is Bitcoin available
  /// to pay fees. When not set, there are asset fees available to pay fees.
  final BigInt? feesSat;

  /// The optional estimated fee in the asset. Is set when [PayAmount::Asset::estimate_asset_fees]
  /// is set to `true`, the Payjoin service accepts this asset to pay fees and there
  /// are funds available in this asset to pay fees.
  final double? estimatedAssetFees;

  /// The amount of funds required (in satoshi) to execute a SideSwap payment, excluding fees.
  /// Only present when [PayAmount::Asset::pay_with_bitcoin] is set to `true`.
  final BigInt? exchangeAmountSat;

  const PrepareSendResponse({
    required this.destination,
    this.amount,
    this.feesSat,
    this.estimatedAssetFees,
    this.exchangeAmountSat,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      amount.hashCode ^
      feesSat.hashCode ^
      estimatedAssetFees.hashCode ^
      exchangeAmountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendResponse &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          amount == other.amount &&
          feesSat == other.feesSat &&
          estimatedAssetFees == other.estimatedAssetFees &&
          exchangeAmountSat == other.exchangeAmountSat;
}

@freezed
sealed class ReceiveAmount with _$ReceiveAmount {
  const ReceiveAmount._();

  /// The amount in satoshi that should be paid
  const factory ReceiveAmount.bitcoin({required BigInt payerAmountSat}) = ReceiveAmount_Bitcoin;

  /// The amount of an asset that should be paid
  const factory ReceiveAmount.asset({required String assetId, double? payerAmount}) = ReceiveAmount_Asset;
}

/// An argument when calling [crate::sdk::LiquidSdk::receive_payment].
class ReceivePaymentRequest {
  final PrepareReceiveResponse prepareResponse;

  /// The description for this payment request
  final String? description;

  /// If set to true, then the hash of the description will be used
  final bool? useDescriptionHash;

  /// An optional payer note, typically included in a LNURL-Pay request
  final String? payerNote;

  const ReceivePaymentRequest({
    required this.prepareResponse,
    this.description,
    this.useDescriptionHash,
    this.payerNote,
  });

  @override
  int get hashCode =>
      prepareResponse.hashCode ^ description.hashCode ^ useDescriptionHash.hashCode ^ payerNote.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          description == other.description &&
          useDescriptionHash == other.useDescriptionHash &&
          payerNote == other.payerNote;
}

/// Returned when calling [crate::sdk::LiquidSdk::receive_payment].
class ReceivePaymentResponse {
  /// Either a BIP21 URI (Liquid or Bitcoin), a Liquid address
  /// or an invoice, depending on the [PrepareReceiveResponse] parameters
  final String destination;

  const ReceivePaymentResponse({required this.destination});

  @override
  int get hashCode => destination.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse && runtimeType == other.runtimeType && destination == other.destination;
}

/// Returned when calling [crate::sdk::LiquidSdk::recommended_fees].
class RecommendedFees {
  final BigInt fastestFee;
  final BigInt halfHourFee;
  final BigInt hourFee;
  final BigInt economyFee;
  final BigInt minimumFee;

  const RecommendedFees({
    required this.fastestFee,
    required this.halfHourFee,
    required this.hourFee,
    required this.economyFee,
    required this.minimumFee,
  });

  @override
  int get hashCode =>
      fastestFee.hashCode ^
      halfHourFee.hashCode ^
      hourFee.hashCode ^
      economyFee.hashCode ^
      minimumFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecommendedFees &&
          runtimeType == other.runtimeType &&
          fastestFee == other.fastestFee &&
          halfHourFee == other.halfHourFee &&
          hourFee == other.hourFee &&
          economyFee == other.economyFee &&
          minimumFee == other.minimumFee;
}

/// An argument when calling [crate::sdk::LiquidSdk::refund].
class RefundRequest {
  /// The address where the swap funds are locked up
  final String swapAddress;

  /// The address to refund the swap funds to
  final String refundAddress;

  /// The fee rate in sat/vB for the refund transaction
  final int feeRateSatPerVbyte;

  const RefundRequest({
    required this.swapAddress,
    required this.refundAddress,
    required this.feeRateSatPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ refundAddress.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          refundAddress == other.refundAddress &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

/// Returned when calling [crate::sdk::LiquidSdk::refund].
class RefundResponse {
  final String refundTxId;

  const RefundResponse({required this.refundTxId});

  @override
  int get hashCode => refundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundResponse && runtimeType == other.runtimeType && refundTxId == other.refundTxId;
}

/// Returned when calling [crate::sdk::LiquidSdk::list_refundables].
class RefundableSwap {
  final String swapAddress;
  final int timestamp;

  /// Amount that is refundable, from all UTXOs
  final BigInt amountSat;

  /// The txid of the last broadcasted refund tx, if any
  final String? lastRefundTxId;

  const RefundableSwap({
    required this.swapAddress,
    required this.timestamp,
    required this.amountSat,
    this.lastRefundTxId,
  });

  @override
  int get hashCode =>
      swapAddress.hashCode ^ timestamp.hashCode ^ amountSat.hashCode ^ lastRefundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundableSwap &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          timestamp == other.timestamp &&
          amountSat == other.amountSat &&
          lastRefundTxId == other.lastRefundTxId;
}

/// An argument when calling [crate::sdk::LiquidSdk::restore].
class RestoreRequest {
  final String? backupPath;

  const RestoreRequest({this.backupPath});

  @override
  int get hashCode => backupPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RestoreRequest && runtimeType == other.runtimeType && backupPath == other.backupPath;
}

@freezed
sealed class SdkEvent with _$SdkEvent {
  const SdkEvent._();

  const factory SdkEvent.paymentFailed({required Payment details}) = SdkEvent_PaymentFailed;
  const factory SdkEvent.paymentPending({required Payment details}) = SdkEvent_PaymentPending;
  const factory SdkEvent.paymentRefundable({required Payment details}) = SdkEvent_PaymentRefundable;
  const factory SdkEvent.paymentRefunded({required Payment details}) = SdkEvent_PaymentRefunded;
  const factory SdkEvent.paymentRefundPending({required Payment details}) = SdkEvent_PaymentRefundPending;
  const factory SdkEvent.paymentSucceeded({required Payment details}) = SdkEvent_PaymentSucceeded;
  const factory SdkEvent.paymentWaitingConfirmation({required Payment details}) =
      SdkEvent_PaymentWaitingConfirmation;
  const factory SdkEvent.paymentWaitingFeeAcceptance({required Payment details}) =
      SdkEvent_PaymentWaitingFeeAcceptance;

  /// Synced with mempool and onchain data
  const factory SdkEvent.synced() = SdkEvent_Synced;

  /// Synced with real-time data sync
  const factory SdkEvent.dataSynced({
    /// Indicates new data was pulled from other instances.
    required bool didPullNewRecords,
  }) = SdkEvent_DataSynced;
}

@freezed
sealed class SendDestination with _$SendDestination {
  const SendDestination._();

  const factory SendDestination.liquidAddress({
    required LiquidAddressData addressData,

    /// A BIP353 address, in case one was used to resolve this Liquid address
    String? bip353Address,
  }) = SendDestination_LiquidAddress;
  const factory SendDestination.bolt11({
    required LNInvoice invoice,

    /// A BIP353 address, in case one was used to resolve this BOLT11
    String? bip353Address,
  }) = SendDestination_Bolt11;
  const factory SendDestination.bolt12({
    required LNOffer offer,
    required BigInt receiverAmountSat,

    /// A BIP353 address, in case one was used to resolve this BOLT12
    String? bip353Address,
  }) = SendDestination_Bolt12;
}

/// An argument when calling [crate::sdk::LiquidSdk::send_payment].
class SendPaymentRequest {
  final PrepareSendResponse prepareResponse;

  /// If set to true, the payment will be sent using the SideSwap payjoin service
  final bool? useAssetFees;

  /// An optional payer note, which is to be included in a BOLT12 invoice request
  final String? payerNote;

  const SendPaymentRequest({required this.prepareResponse, this.useAssetFees, this.payerNote});

  @override
  int get hashCode => prepareResponse.hashCode ^ useAssetFees.hashCode ^ payerNote.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          useAssetFees == other.useAssetFees &&
          payerNote == other.payerNote;
}

/// Returned when calling [crate::sdk::LiquidSdk::send_payment].
class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

/// An argument when calling [crate::sdk::LiquidSdk::sign_message].
class SignMessageRequest {
  final String message;

  const SignMessageRequest({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageRequest && runtimeType == other.runtimeType && message == other.message;
}

/// Returned when calling [crate::sdk::LiquidSdk::sign_message].
class SignMessageResponse {
  final String signature;

  const SignMessageResponse({required this.signature});

  @override
  int get hashCode => signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageResponse && runtimeType == other.runtimeType && signature == other.signature;
}

class WalletInfo {
  /// Usable balance. This is the confirmed onchain balance minus `pending_send_sat`.
  final BigInt balanceSat;

  /// Amount that is being used for ongoing Send swaps
  final BigInt pendingSendSat;

  /// Incoming amount that is pending from ongoing Receive swaps
  final BigInt pendingReceiveSat;

  /// The wallet's fingerprint. It is used to build the working directory in [Config::get_wallet_dir].
  final String fingerprint;

  /// The wallet's pubkey. Used to verify signed messages.
  final String pubkey;

  /// Asset balances of non Liquid Bitcoin assets
  final List<AssetBalance> assetBalances;

  const WalletInfo({
    required this.balanceSat,
    required this.pendingSendSat,
    required this.pendingReceiveSat,
    required this.fingerprint,
    required this.pubkey,
    required this.assetBalances,
  });

  @override
  int get hashCode =>
      balanceSat.hashCode ^
      pendingSendSat.hashCode ^
      pendingReceiveSat.hashCode ^
      fingerprint.hashCode ^
      pubkey.hashCode ^
      assetBalances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletInfo &&
          runtimeType == other.runtimeType &&
          balanceSat == other.balanceSat &&
          pendingSendSat == other.pendingSendSat &&
          pendingReceiveSat == other.pendingReceiveSat &&
          fingerprint == other.fingerprint &&
          pubkey == other.pubkey &&
          assetBalances == other.assetBalances;
}
