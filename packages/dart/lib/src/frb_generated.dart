// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'bindings.dart';
import 'bindings/duplicates.dart';
import 'dart:async';
import 'dart:convert';
import 'error.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'model.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({RustLibApi? api, BaseHandler? handler, ExternalLibrary? externalLibrary}) async {
    await instance.initImpl(api: api, handler: handler, externalLibrary: externalLibrary);
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 464449310;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'breez_sdk_liquid',
    ioDirectory: '../../lib/core/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateBindingsBindingLiquidSdkAcceptPaymentProposedFees({
    required BindingLiquidSdk that,
    required AcceptPaymentProposedFeesRequest req,
  });

  Stream<SdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req});

  Future<String> crateBindingsBindingLiquidSdkBuyBitcoin({
    required BindingLiquidSdk that,
    required BuyBitcoinRequest req,
  });

  CheckMessageResponse crateBindingsBindingLiquidSdkCheckMessage({
    required BindingLiquidSdk that,
    required CheckMessageRequest req,
  });

  Future<CreateBolt12InvoiceResponse> crateBindingsBindingLiquidSdkCreateBolt12Invoice({
    required BindingLiquidSdk that,
    required CreateBolt12InvoiceRequest req,
  });

  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that});

  Future<List<Rate>> crateBindingsBindingLiquidSdkFetchFiatRates({required BindingLiquidSdk that});

  Future<LightningPaymentLimitsResponse> crateBindingsBindingLiquidSdkFetchLightningLimits({
    required BindingLiquidSdk that,
  });

  Future<OnchainPaymentLimitsResponse> crateBindingsBindingLiquidSdkFetchOnchainLimits({
    required BindingLiquidSdk that,
  });

  Future<FetchPaymentProposedFeesResponse> crateBindingsBindingLiquidSdkFetchPaymentProposedFees({
    required BindingLiquidSdk that,
    required FetchPaymentProposedFeesRequest req,
  });

  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that});

  Future<Payment?> crateBindingsBindingLiquidSdkGetPayment({
    required BindingLiquidSdk that,
    required GetPaymentRequest req,
  });

  Future<List<FiatCurrency>> crateBindingsBindingLiquidSdkListFiatCurrencies({
    required BindingLiquidSdk that,
  });

  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({
    required BindingLiquidSdk that,
    required ListPaymentsRequest req,
  });

  Future<List<RefundableSwap>> crateBindingsBindingLiquidSdkListRefundables({required BindingLiquidSdk that});

  Future<LnUrlCallbackStatus> crateBindingsBindingLiquidSdkLnurlAuth({
    required BindingLiquidSdk that,
    required LnUrlAuthRequestData reqData,
  });

  Future<LnUrlPayResult> crateBindingsBindingLiquidSdkLnurlPay({
    required BindingLiquidSdk that,
    required LnUrlPayRequest req,
  });

  Future<LnUrlWithdrawResult> crateBindingsBindingLiquidSdkLnurlWithdraw({
    required BindingLiquidSdk that,
    required LnUrlWithdrawRequest req,
  });

  Future<InputType> crateBindingsBindingLiquidSdkParse({
    required BindingLiquidSdk that,
    required String input,
  });

  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkPayOnchain({
    required BindingLiquidSdk that,
    required PayOnchainRequest req,
  });

  Future<PrepareBuyBitcoinResponse> crateBindingsBindingLiquidSdkPrepareBuyBitcoin({
    required BindingLiquidSdk that,
    required PrepareBuyBitcoinRequest req,
  });

  Future<PrepareLnUrlPayResponse> crateBindingsBindingLiquidSdkPrepareLnurlPay({
    required BindingLiquidSdk that,
    required PrepareLnUrlPayRequest req,
  });

  Future<PreparePayOnchainResponse> crateBindingsBindingLiquidSdkPreparePayOnchain({
    required BindingLiquidSdk that,
    required PreparePayOnchainRequest req,
  });

  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment({
    required BindingLiquidSdk that,
    required PrepareReceiveRequest req,
  });

  Future<PrepareRefundResponse> crateBindingsBindingLiquidSdkPrepareRefund({
    required BindingLiquidSdk that,
    required PrepareRefundRequest req,
  });

  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment({
    required BindingLiquidSdk that,
    required PrepareSendRequest req,
  });

  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment({
    required BindingLiquidSdk that,
    required ReceivePaymentRequest req,
  });

  Future<RecommendedFees> crateBindingsBindingLiquidSdkRecommendedFees({required BindingLiquidSdk that});

  Future<RefundResponse> crateBindingsBindingLiquidSdkRefund({
    required BindingLiquidSdk that,
    required RefundRequest req,
  });

  Future<void> crateBindingsBindingLiquidSdkRegisterWebhook({
    required BindingLiquidSdk that,
    required String webhookUrl,
  });

  Future<void> crateBindingsBindingLiquidSdkRescanOnchainSwaps({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req});

  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment({
    required BindingLiquidSdk that,
    required SendPaymentRequest req,
  });

  SignMessageResponse crateBindingsBindingLiquidSdkSignMessage({
    required BindingLiquidSdk that,
    required SignMessageRequest req,
  });

  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that});

  Future<void> crateBindingsBindingLiquidSdkUnregisterWebhook({required BindingLiquidSdk that});

  Future<void> crateBindingsBindingEventListenerOnEvent({
    required BindingEventListener that,
    required SdkEvent e,
  });

  Stream<LogEntry> crateBindingsBreezLogStream();

  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req});

  Config crateBindingsDefaultConfig({required LiquidNetwork network, String? breezApiKey});

  LNInvoice crateBindingsParseInvoice({required String input});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BindingLiquidSdkPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateBindingsBindingLiquidSdkAcceptPaymentProposedFees({
    required BindingLiquidSdk that,
    required AcceptPaymentProposedFeesRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_accept_payment_proposed_fees_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_accept_payment_proposed_fees(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_payment_error),
        constMeta: kCrateBindingsBindingLiquidSdkAcceptPaymentProposedFeesConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkAcceptPaymentProposedFeesConstMeta => const TaskConstMeta(
    debugName: "BindingLiquidSdk_accept_payment_proposed_fees",
    argNames: ["that", "req"],
  );

  @override
  Stream<SdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that}) {
    final listener = RustStreamSink<SdkEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            var arg0 =
                cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                  that,
                );
            var arg1 = cst_encode_StreamSink_sdk_event_Dco(listener);
            return wire.wire__crate__bindings__BindingLiquidSdk_add_event_listener(port_, arg0, arg1);
          },
          codec: DcoCodec(decodeSuccessData: dco_decode_String, decodeErrorData: dco_decode_sdk_error),
          constMeta: kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta,
          argValues: [that, listener],
          apiImpl: this,
        ),
      ),
    );
    return listener.stream;
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_add_event_listener", argNames: ["that", "listener"]);

  @override
  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_backup_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_backup(arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkBackupConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkBackupConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_backup", argNames: ["that", "req"]);

  @override
  Future<String> crateBindingsBindingLiquidSdkBuyBitcoin({
    required BindingLiquidSdk that,
    required BuyBitcoinRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_buy_bitcoin_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_buy_bitcoin(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_String, decodeErrorData: dco_decode_payment_error),
        constMeta: kCrateBindingsBindingLiquidSdkBuyBitcoinConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkBuyBitcoinConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_buy_bitcoin", argNames: ["that", "req"]);

  @override
  CheckMessageResponse crateBindingsBindingLiquidSdkCheckMessage({
    required BindingLiquidSdk that,
    required CheckMessageRequest req,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_check_message_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_check_message(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_check_message_response,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkCheckMessageConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkCheckMessageConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_check_message", argNames: ["that", "req"]);

  @override
  Future<CreateBolt12InvoiceResponse> crateBindingsBindingLiquidSdkCreateBolt12Invoice({
    required BindingLiquidSdk that,
    required CreateBolt12InvoiceRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_create_bolt_12_invoice_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_create_bolt12_invoice(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_create_bolt_12_invoice_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkCreateBolt12InvoiceConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkCreateBolt12InvoiceConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_create_bolt12_invoice", argNames: ["that", "req"]);

  @override
  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_disconnect(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkDisconnectConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkDisconnectConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_disconnect", argNames: ["that"]);

  @override
  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_empty_wallet_cache(arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_empty_wallet_cache", argNames: ["that"]);

  @override
  Future<List<Rate>> crateBindingsBindingLiquidSdkFetchFiatRates({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_fetch_fiat_rates(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_list_rate, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkFetchFiatRatesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkFetchFiatRatesConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_fetch_fiat_rates", argNames: ["that"]);

  @override
  Future<LightningPaymentLimitsResponse> crateBindingsBindingLiquidSdkFetchLightningLimits({
    required BindingLiquidSdk that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_fetch_lightning_limits(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_lightning_payment_limits_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkFetchLightningLimitsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkFetchLightningLimitsConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_fetch_lightning_limits", argNames: ["that"]);

  @override
  Future<OnchainPaymentLimitsResponse> crateBindingsBindingLiquidSdkFetchOnchainLimits({
    required BindingLiquidSdk that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_fetch_onchain_limits(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_onchain_payment_limits_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkFetchOnchainLimitsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkFetchOnchainLimitsConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_fetch_onchain_limits", argNames: ["that"]);

  @override
  Future<FetchPaymentProposedFeesResponse> crateBindingsBindingLiquidSdkFetchPaymentProposedFees({
    required BindingLiquidSdk that,
    required FetchPaymentProposedFeesRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_fetch_payment_proposed_fees_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_fetch_payment_proposed_fees(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_fetch_payment_proposed_fees_response,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkFetchPaymentProposedFeesConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkFetchPaymentProposedFeesConstMeta => const TaskConstMeta(
    debugName: "BindingLiquidSdk_fetch_payment_proposed_fees",
    argNames: ["that", "req"],
  );

  @override
  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_get_info(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_get_info_response,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkGetInfoConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkGetInfoConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_get_info", argNames: ["that"]);

  @override
  Future<Payment?> crateBindingsBindingLiquidSdkGetPayment({
    required BindingLiquidSdk that,
    required GetPaymentRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_get_payment_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_get_payment(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_payment,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkGetPaymentConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkGetPaymentConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_get_payment", argNames: ["that", "req"]);

  @override
  Future<List<FiatCurrency>> crateBindingsBindingLiquidSdkListFiatCurrencies({
    required BindingLiquidSdk that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_list_fiat_currencies(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_fiat_currency,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkListFiatCurrenciesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkListFiatCurrenciesConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_list_fiat_currencies", argNames: ["that"]);

  @override
  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({
    required BindingLiquidSdk that,
    required ListPaymentsRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_list_payments_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_list_payments(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_payment,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkListPaymentsConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkListPaymentsConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_list_payments", argNames: ["that", "req"]);

  @override
  Future<List<RefundableSwap>> crateBindingsBindingLiquidSdkListRefundables({
    required BindingLiquidSdk that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_list_refundables(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_refundable_swap,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkListRefundablesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkListRefundablesConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_list_refundables", argNames: ["that"]);

  @override
  Future<LnUrlCallbackStatus> crateBindingsBindingLiquidSdkLnurlAuth({
    required BindingLiquidSdk that,
    required LnUrlAuthRequestData reqData,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_ln_url_auth_request_data(reqData);
          return wire.wire__crate__bindings__BindingLiquidSdk_lnurl_auth(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_callback_status,
          decodeErrorData: dco_decode_ln_url_auth_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkLnurlAuthConstMeta,
        argValues: [that, reqData],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkLnurlAuthConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_lnurl_auth", argNames: ["that", "reqData"]);

  @override
  Future<LnUrlPayResult> crateBindingsBindingLiquidSdkLnurlPay({
    required BindingLiquidSdk that,
    required LnUrlPayRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_ln_url_pay_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_lnurl_pay(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_pay_result,
          decodeErrorData: dco_decode_ln_url_pay_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkLnurlPayConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkLnurlPayConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_lnurl_pay", argNames: ["that", "req"]);

  @override
  Future<LnUrlWithdrawResult> crateBindingsBindingLiquidSdkLnurlWithdraw({
    required BindingLiquidSdk that,
    required LnUrlWithdrawRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_ln_url_withdraw_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_lnurl_withdraw(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_withdraw_result,
          decodeErrorData: dco_decode_ln_url_withdraw_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkLnurlWithdrawConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkLnurlWithdrawConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_lnurl_withdraw", argNames: ["that", "req"]);

  @override
  Future<InputType> crateBindingsBindingLiquidSdkParse({
    required BindingLiquidSdk that,
    required String input,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_String(input);
          return wire.wire__crate__bindings__BindingLiquidSdk_parse(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_input_type, decodeErrorData: dco_decode_payment_error),
        constMeta: kCrateBindingsBindingLiquidSdkParseConstMeta,
        argValues: [that, input],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkParseConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_parse", argNames: ["that", "input"]);

  @override
  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkPayOnchain({
    required BindingLiquidSdk that,
    required PayOnchainRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_pay_onchain_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_pay_onchain(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_send_payment_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPayOnchainConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPayOnchainConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_pay_onchain", argNames: ["that", "req"]);

  @override
  Future<PrepareBuyBitcoinResponse> crateBindingsBindingLiquidSdkPrepareBuyBitcoin({
    required BindingLiquidSdk that,
    required PrepareBuyBitcoinRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_buy_bitcoin_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_buy_bitcoin(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_buy_bitcoin_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPrepareBuyBitcoinConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareBuyBitcoinConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_buy_bitcoin", argNames: ["that", "req"]);

  @override
  Future<PrepareLnUrlPayResponse> crateBindingsBindingLiquidSdkPrepareLnurlPay({
    required BindingLiquidSdk that,
    required PrepareLnUrlPayRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_ln_url_pay_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_lnurl_pay(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_ln_url_pay_response,
          decodeErrorData: dco_decode_ln_url_pay_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPrepareLnurlPayConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareLnurlPayConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_lnurl_pay", argNames: ["that", "req"]);

  @override
  Future<PreparePayOnchainResponse> crateBindingsBindingLiquidSdkPreparePayOnchain({
    required BindingLiquidSdk that,
    required PreparePayOnchainRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_pay_onchain_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_pay_onchain(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_pay_onchain_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPreparePayOnchainConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPreparePayOnchainConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_pay_onchain", argNames: ["that", "req"]);

  @override
  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment({
    required BindingLiquidSdk that,
    required PrepareReceiveRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_receive_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_receive_payment(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_receive_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_receive_payment", argNames: ["that", "req"]);

  @override
  Future<PrepareRefundResponse> crateBindingsBindingLiquidSdkPrepareRefund({
    required BindingLiquidSdk that,
    required PrepareRefundRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_refund_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_refund(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_refund_response,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPrepareRefundConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareRefundConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_refund", argNames: ["that", "req"]);

  @override
  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment({
    required BindingLiquidSdk that,
    required PrepareSendRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_prepare_send_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_prepare_send_payment(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_send_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_prepare_send_payment", argNames: ["that", "req"]);

  @override
  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment({
    required BindingLiquidSdk that,
    required ReceivePaymentRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_receive_payment_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_receive_payment(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_receive_payment_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_receive_payment", argNames: ["that", "req"]);

  @override
  Future<RecommendedFees> crateBindingsBindingLiquidSdkRecommendedFees({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_recommended_fees(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_recommended_fees,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkRecommendedFeesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRecommendedFeesConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_recommended_fees", argNames: ["that"]);

  @override
  Future<RefundResponse> crateBindingsBindingLiquidSdkRefund({
    required BindingLiquidSdk that,
    required RefundRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_refund_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_refund(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_refund_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkRefundConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRefundConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_refund", argNames: ["that", "req"]);

  @override
  Future<void> crateBindingsBindingLiquidSdkRegisterWebhook({
    required BindingLiquidSdk that,
    required String webhookUrl,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_String(webhookUrl);
          return wire.wire__crate__bindings__BindingLiquidSdk_register_webhook(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkRegisterWebhookConstMeta,
        argValues: [that, webhookUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRegisterWebhookConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_register_webhook", argNames: ["that", "webhookUrl"]);

  @override
  Future<void> crateBindingsBindingLiquidSdkRescanOnchainSwaps({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_rescan_onchain_swaps(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkRescanOnchainSwapsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRescanOnchainSwapsConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_rescan_onchain_swaps", argNames: ["that"]);

  @override
  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_restore_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_restore(arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkRestoreConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRestoreConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_restore", argNames: ["that", "req"]);

  @override
  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment({
    required BindingLiquidSdk that,
    required SendPaymentRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_send_payment_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_send_payment(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_send_payment_response,
          decodeErrorData: dco_decode_payment_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkSendPaymentConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSendPaymentConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_send_payment", argNames: ["that", "req"]);

  @override
  SignMessageResponse crateBindingsBindingLiquidSdkSignMessage({
    required BindingLiquidSdk that,
    required SignMessageRequest req,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          var arg1 = cst_encode_box_autoadd_sign_message_request(req);
          return wire.wire__crate__bindings__BindingLiquidSdk_sign_message(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_sign_message_response,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsBindingLiquidSdkSignMessageConstMeta,
        argValues: [that, req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSignMessageConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_sign_message", argNames: ["that", "req"]);

  @override
  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_sync(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkSyncConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSyncConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_sync(dart_style=sync)", argNames: ["that"]);

  @override
  Future<void> crateBindingsBindingLiquidSdkUnregisterWebhook({required BindingLiquidSdk that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 =
              cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that,
              );
          return wire.wire__crate__bindings__BindingLiquidSdk_unregister_webhook(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsBindingLiquidSdkUnregisterWebhookConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkUnregisterWebhookConstMeta =>
      const TaskConstMeta(debugName: "BindingLiquidSdk_unregister_webhook", argNames: ["that"]);

  @override
  Future<void> crateBindingsBindingEventListenerOnEvent({
    required BindingEventListener that,
    required SdkEvent e,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_binding_event_listener(that);
          var arg1 = cst_encode_box_autoadd_sdk_event(e);
          return wire.wire__crate__bindings__binding_event_listener_on_event(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: null),
        constMeta: kCrateBindingsBindingEventListenerOnEventConstMeta,
        argValues: [that, e],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsBindingEventListenerOnEventConstMeta =>
      const TaskConstMeta(debugName: "binding_event_listener_on_event", argNames: ["that", "e"]);

  @override
  Stream<LogEntry> crateBindingsBreezLogStream() {
    final s = RustStreamSink<LogEntry>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            var arg0 = cst_encode_StreamSink_log_entry_Dco(s);
            return wire.wire__crate__bindings__breez_log_stream(port_, arg0);
          },
          codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
          constMeta: kCrateBindingsBreezLogStreamConstMeta,
          argValues: [s],
          apiImpl: this,
        ),
      ),
    );
    return s.stream;
  }

  TaskConstMeta get kCrateBindingsBreezLogStreamConstMeta =>
      const TaskConstMeta(debugName: "breez_log_stream", argNames: ["s"]);

  @override
  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_connect_request(req);
          return wire.wire__crate__bindings__connect(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData:
              dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk,
          decodeErrorData: dco_decode_sdk_error,
        ),
        constMeta: kCrateBindingsConnectConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsConnectConstMeta =>
      const TaskConstMeta(debugName: "connect", argNames: ["req"]);

  @override
  Config crateBindingsDefaultConfig({required LiquidNetwork network, String? breezApiKey}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_liquid_network(network);
          var arg1 = cst_encode_opt_String(breezApiKey);
          return wire.wire__crate__bindings__default_config(arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_config, decodeErrorData: dco_decode_sdk_error),
        constMeta: kCrateBindingsDefaultConfigConstMeta,
        argValues: [network, breezApiKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsDefaultConfigConstMeta =>
      const TaskConstMeta(debugName: "default_config", argNames: ["network", "breezApiKey"]);

  @override
  LNInvoice crateBindingsParseInvoice({required String input}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(input);
          return wire.wire__crate__bindings__parse_invoice(arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_ln_invoice, decodeErrorData: dco_decode_payment_error),
        constMeta: kCrateBindingsParseInvoiceConstMeta,
        argValues: [input],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingsParseInvoiceConstMeta =>
      const TaskConstMeta(debugName: "parse_invoice", argNames: ["input"]);

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  BindingLiquidSdk
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<SdkEvent> dco_decode_StreamSink_sdk_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AcceptPaymentProposedFeesRequest dco_decode_accept_payment_proposed_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return AcceptPaymentProposedFeesRequest(
      response: dco_decode_fetch_payment_proposed_fees_response(arr[0]),
    );
  }

  @protected
  AesSuccessActionData dco_decode_aes_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AesSuccessActionData(
      description: dco_decode_String(arr[0]),
      ciphertext: dco_decode_String(arr[1]),
      iv: dco_decode_String(arr[2]),
    );
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AesSuccessActionDataDecrypted(
      description: dco_decode_String(arr[0]),
      plaintext: dco_decode_String(arr[1]),
    );
  }

  @protected
  AesSuccessActionDataResult dco_decode_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AesSuccessActionDataResult_Decrypted(
          data: dco_decode_box_autoadd_aes_success_action_data_decrypted(raw[1]),
        );
      case 1:
        return AesSuccessActionDataResult_ErrorStatus(reason: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Amount dco_decode_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Amount_Bitcoin(amountMsat: dco_decode_u_64(raw[1]));
      case 1:
        return Amount_Currency(
          iso4217Code: dco_decode_String(raw[1]),
          fractionalAmount: dco_decode_u_64(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AssetBalance dco_decode_asset_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AssetBalance(
      assetId: dco_decode_String(arr[0]),
      balanceSat: dco_decode_u_64(arr[1]),
      name: dco_decode_opt_String(arr[2]),
      ticker: dco_decode_opt_String(arr[3]),
      balance: dco_decode_opt_box_autoadd_f_64(arr[4]),
    );
  }

  @protected
  AssetInfo dco_decode_asset_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AssetInfo(
      name: dco_decode_String(arr[0]),
      ticker: dco_decode_String(arr[1]),
      amount: dco_decode_f_64(arr[2]),
      fees: dco_decode_opt_box_autoadd_f_64(arr[3]),
    );
  }

  @protected
  AssetMetadata dco_decode_asset_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AssetMetadata(
      assetId: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      ticker: dco_decode_String(arr[2]),
      precision: dco_decode_u_8(arr[3]),
      fiatId: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  BackupRequest dco_decode_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BackupRequest(backupPath: dco_decode_opt_String(arr[0]));
  }

  @protected
  BindingEventListener dco_decode_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BindingEventListener(stream: dco_decode_StreamSink_sdk_event_Dco(arr[0]));
  }

  @protected
  BitcoinAddressData dco_decode_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BitcoinAddressData(
      address: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      amountSat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      message: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  BlockchainExplorer dco_decode_blockchain_explorer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BlockchainExplorer_Electrum(url: dco_decode_String(raw[1]));
      case 1:
        return BlockchainExplorer_Esplora(
          url: dco_decode_String(raw[1]),
          useWaterfalls: dco_decode_bool(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BlockchainInfo dco_decode_blockchain_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockchainInfo(liquidTip: dco_decode_u_32(arr[0]), bitcoinTip: dco_decode_u_32(arr[1]));
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AcceptPaymentProposedFeesRequest dco_decode_box_autoadd_accept_payment_proposed_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_accept_payment_proposed_fees_request(raw);
  }

  @protected
  AesSuccessActionData dco_decode_box_autoadd_aes_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data(raw);
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_box_autoadd_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_decrypted(raw);
  }

  @protected
  AesSuccessActionDataResult dco_decode_box_autoadd_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_result(raw);
  }

  @protected
  Amount dco_decode_box_autoadd_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_amount(raw);
  }

  @protected
  AssetInfo dco_decode_box_autoadd_asset_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_asset_info(raw);
  }

  @protected
  BackupRequest dco_decode_box_autoadd_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_backup_request(raw);
  }

  @protected
  BindingEventListener dco_decode_box_autoadd_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_binding_event_listener(raw);
  }

  @protected
  BitcoinAddressData dco_decode_box_autoadd_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bitcoin_address_data(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BuyBitcoinRequest dco_decode_box_autoadd_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_buy_bitcoin_request(raw);
  }

  @protected
  CheckMessageRequest dco_decode_box_autoadd_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_check_message_request(raw);
  }

  @protected
  ConnectRequest dco_decode_box_autoadd_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connect_request(raw);
  }

  @protected
  CreateBolt12InvoiceRequest dco_decode_box_autoadd_create_bolt_12_invoice_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_create_bolt_12_invoice_request(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FetchPaymentProposedFeesRequest dco_decode_box_autoadd_fetch_payment_proposed_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fetch_payment_proposed_fees_request(raw);
  }

  @protected
  GetPaymentRequest dco_decode_box_autoadd_get_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_get_payment_request(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  LiquidAddressData dco_decode_box_autoadd_liquid_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquid_address_data(raw);
  }

  @protected
  ListPaymentDetails dco_decode_box_autoadd_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_list_payment_details(raw);
  }

  @protected
  ListPaymentsRequest dco_decode_box_autoadd_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_list_payments_request(raw);
  }

  @protected
  LNInvoice dco_decode_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_invoice(raw);
  }

  @protected
  LNOffer dco_decode_box_autoadd_ln_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_offer(raw);
  }

  @protected
  LnUrlAuthRequestData dco_decode_box_autoadd_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_auth_request_data(raw);
  }

  @protected
  LnUrlErrorData dco_decode_box_autoadd_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_error_data(raw);
  }

  @protected
  LnUrlInfo dco_decode_box_autoadd_ln_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_info(raw);
  }

  @protected
  LnUrlPayErrorData dco_decode_box_autoadd_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_error_data(raw);
  }

  @protected
  LnUrlPayRequest dco_decode_box_autoadd_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request(raw);
  }

  @protected
  LnUrlPayRequestData dco_decode_box_autoadd_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request_data(raw);
  }

  @protected
  LnUrlPaySuccessData dco_decode_box_autoadd_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_success_data(raw);
  }

  @protected
  LnUrlWithdrawRequest dco_decode_box_autoadd_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request(raw);
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_box_autoadd_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request_data(raw);
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_box_autoadd_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_success_data(raw);
  }

  @protected
  MessageSuccessActionData dco_decode_box_autoadd_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_message_success_action_data(raw);
  }

  @protected
  PayAmount dco_decode_box_autoadd_pay_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pay_amount(raw);
  }

  @protected
  PayOnchainRequest dco_decode_box_autoadd_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pay_onchain_request(raw);
  }

  @protected
  Payment dco_decode_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment(raw);
  }

  @protected
  PrepareBuyBitcoinRequest dco_decode_box_autoadd_prepare_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_buy_bitcoin_request(raw);
  }

  @protected
  PrepareLnUrlPayRequest dco_decode_box_autoadd_prepare_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_ln_url_pay_request(raw);
  }

  @protected
  PreparePayOnchainRequest dco_decode_box_autoadd_prepare_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_pay_onchain_request(raw);
  }

  @protected
  PrepareReceiveRequest dco_decode_box_autoadd_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_receive_request(raw);
  }

  @protected
  PrepareRefundRequest dco_decode_box_autoadd_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_refund_request(raw);
  }

  @protected
  PrepareSendRequest dco_decode_box_autoadd_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_send_request(raw);
  }

  @protected
  ReceiveAmount dco_decode_box_autoadd_receive_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_amount(raw);
  }

  @protected
  ReceivePaymentRequest dco_decode_box_autoadd_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_payment_request(raw);
  }

  @protected
  RefundRequest dco_decode_box_autoadd_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_refund_request(raw);
  }

  @protected
  RestoreRequest dco_decode_box_autoadd_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_restore_request(raw);
  }

  @protected
  SdkEvent dco_decode_box_autoadd_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sdk_event(raw);
  }

  @protected
  SendPaymentRequest dco_decode_box_autoadd_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_payment_request(raw);
  }

  @protected
  SignMessageRequest dco_decode_box_autoadd_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_message_request(raw);
  }

  @protected
  SuccessAction dco_decode_box_autoadd_success_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_success_action(raw);
  }

  @protected
  SuccessActionProcessed dco_decode_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_success_action_processed(raw);
  }

  @protected
  Symbol dco_decode_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_symbol(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UrlSuccessActionData dco_decode_box_autoadd_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_url_success_action_data(raw);
  }

  @protected
  BuyBitcoinProvider dco_decode_buy_bitcoin_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuyBitcoinProvider.values[raw as int];
  }

  @protected
  BuyBitcoinRequest dco_decode_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BuyBitcoinRequest(
      prepareResponse: dco_decode_prepare_buy_bitcoin_response(arr[0]),
      redirectUrl: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  CheckMessageRequest dco_decode_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CheckMessageRequest(
      message: dco_decode_String(arr[0]),
      pubkey: dco_decode_String(arr[1]),
      signature: dco_decode_String(arr[2]),
    );
  }

  @protected
  CheckMessageResponse dco_decode_check_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CheckMessageResponse(isValid: dco_decode_bool(arr[0]));
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14) throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return Config(
      liquidExplorer: dco_decode_blockchain_explorer(arr[0]),
      bitcoinExplorer: dco_decode_blockchain_explorer(arr[1]),
      workingDir: dco_decode_String(arr[2]),
      network: dco_decode_liquid_network(arr[3]),
      paymentTimeoutSec: dco_decode_u_64(arr[4]),
      syncServiceUrl: dco_decode_opt_String(arr[5]),
      zeroConfMaxAmountSat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      breezApiKey: dco_decode_opt_String(arr[7]),
      externalInputParsers: dco_decode_opt_list_external_input_parser(arr[8]),
      useDefaultExternalInputParsers: dco_decode_bool(arr[9]),
      onchainFeeRateLeewaySat: dco_decode_opt_box_autoadd_u_64(arr[10]),
      assetMetadata: dco_decode_opt_list_asset_metadata(arr[11]),
      sideswapApiKey: dco_decode_opt_String(arr[12]),
      useMagicRoutingHints: dco_decode_bool(arr[13]),
    );
  }

  @protected
  ConnectRequest dco_decode_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ConnectRequest(
      config: dco_decode_config(arr[0]),
      mnemonic: dco_decode_opt_String(arr[1]),
      passphrase: dco_decode_opt_String(arr[2]),
      seed: dco_decode_opt_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  CreateBolt12InvoiceRequest dco_decode_create_bolt_12_invoice_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CreateBolt12InvoiceRequest(
      offer: dco_decode_String(arr[0]),
      invoiceRequest: dco_decode_String(arr[1]),
    );
  }

  @protected
  CreateBolt12InvoiceResponse dco_decode_create_bolt_12_invoice_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CreateBolt12InvoiceResponse(invoice: dco_decode_String(arr[0]));
  }

  @protected
  CurrencyInfo dco_decode_currency_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return CurrencyInfo(
      name: dco_decode_String(arr[0]),
      fractionSize: dco_decode_u_32(arr[1]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[2]),
      symbol: dco_decode_opt_box_autoadd_symbol(arr[3]),
      uniqSymbol: dco_decode_opt_box_autoadd_symbol(arr[4]),
      localizedName: dco_decode_list_localized_name(arr[5]),
      localeOverrides: dco_decode_list_locale_overrides(arr[6]),
    );
  }

  @protected
  ExternalInputParser dco_decode_external_input_parser(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ExternalInputParser(
      providerId: dco_decode_String(arr[0]),
      inputRegex: dco_decode_String(arr[1]),
      parserUrl: dco_decode_String(arr[2]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FetchPaymentProposedFeesRequest dco_decode_fetch_payment_proposed_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FetchPaymentProposedFeesRequest(swapId: dco_decode_String(arr[0]));
  }

  @protected
  FetchPaymentProposedFeesResponse dco_decode_fetch_payment_proposed_fees_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FetchPaymentProposedFeesResponse(
      swapId: dco_decode_String(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
      payerAmountSat: dco_decode_u_64(arr[2]),
      receiverAmountSat: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  FiatCurrency dco_decode_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FiatCurrency(id: dco_decode_String(arr[0]), info: dco_decode_currency_info(arr[1]));
  }

  @protected
  GetInfoResponse dco_decode_get_info_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GetInfoResponse(
      walletInfo: dco_decode_wallet_info(arr[0]),
      blockchainInfo: dco_decode_blockchain_info(arr[1]),
    );
  }

  @protected
  GetPaymentRequest dco_decode_get_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GetPaymentRequest_PaymentHash(paymentHash: dco_decode_String(raw[1]));
      case 1:
        return GetPaymentRequest_SwapId(swapId: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  InputType dco_decode_input_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return InputType_BitcoinAddress(address: dco_decode_box_autoadd_bitcoin_address_data(raw[1]));
      case 1:
        return InputType_LiquidAddress(address: dco_decode_box_autoadd_liquid_address_data(raw[1]));
      case 2:
        return InputType_Bolt11(invoice: dco_decode_box_autoadd_ln_invoice(raw[1]));
      case 3:
        return InputType_Bolt12Offer(
          offer: dco_decode_box_autoadd_ln_offer(raw[1]),
          bip353Address: dco_decode_opt_String(raw[2]),
        );
      case 4:
        return InputType_NodeId(nodeId: dco_decode_String(raw[1]));
      case 5:
        return InputType_Url(url: dco_decode_String(raw[1]));
      case 6:
        return InputType_LnUrlPay(
          data: dco_decode_box_autoadd_ln_url_pay_request_data(raw[1]),
          bip353Address: dco_decode_opt_String(raw[2]),
        );
      case 7:
        return InputType_LnUrlWithdraw(data: dco_decode_box_autoadd_ln_url_withdraw_request_data(raw[1]));
      case 8:
        return InputType_LnUrlAuth(data: dco_decode_box_autoadd_ln_url_auth_request_data(raw[1]));
      case 9:
        return InputType_LnUrlError(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LightningPaymentLimitsResponse dco_decode_lightning_payment_limits_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LightningPaymentLimitsResponse(
      send: dco_decode_limits(arr[0]),
      receive: dco_decode_limits(arr[1]),
    );
  }

  @protected
  Limits dco_decode_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Limits(
      minSat: dco_decode_u_64(arr[0]),
      maxSat: dco_decode_u_64(arr[1]),
      maxZeroConfSat: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  LiquidAddressData dco_decode_liquid_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return LiquidAddressData(
      address: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      assetId: dco_decode_opt_String(arr[2]),
      amount: dco_decode_opt_box_autoadd_f_64(arr[3]),
      amountSat: dco_decode_opt_box_autoadd_u_64(arr[4]),
      label: dco_decode_opt_String(arr[5]),
      message: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  LiquidNetwork dco_decode_liquid_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LiquidNetwork.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AssetBalance> dco_decode_list_asset_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_asset_balance).toList();
  }

  @protected
  List<AssetMetadata> dco_decode_list_asset_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_asset_metadata).toList();
  }

  @protected
  List<ExternalInputParser> dco_decode_list_external_input_parser(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_external_input_parser).toList();
  }

  @protected
  List<FiatCurrency> dco_decode_list_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_fiat_currency).toList();
  }

  @protected
  List<LnOfferBlindedPath> dco_decode_list_ln_offer_blinded_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ln_offer_blinded_path).toList();
  }

  @protected
  List<LocaleOverrides> dco_decode_list_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_locale_overrides).toList();
  }

  @protected
  List<LocalizedName> dco_decode_list_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_name).toList();
  }

  @protected
  List<Payment> dco_decode_list_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment).toList();
  }

  @protected
  ListPaymentDetails dco_decode_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ListPaymentDetails_Liquid(
          assetId: dco_decode_opt_String(raw[1]),
          destination: dco_decode_opt_String(raw[2]),
        );
      case 1:
        return ListPaymentDetails_Bitcoin(address: dco_decode_opt_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<PaymentState> dco_decode_list_payment_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_state).toList();
  }

  @protected
  List<PaymentType> dco_decode_list_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_type).toList();
  }

  @protected
  ListPaymentsRequest dco_decode_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ListPaymentsRequest(
      filters: dco_decode_opt_list_payment_type(arr[0]),
      states: dco_decode_opt_list_payment_state(arr[1]),
      fromTimestamp: dco_decode_opt_box_autoadd_i_64(arr[2]),
      toTimestamp: dco_decode_opt_box_autoadd_i_64(arr[3]),
      offset: dco_decode_opt_box_autoadd_u_32(arr[4]),
      limit: dco_decode_opt_box_autoadd_u_32(arr[5]),
      details: dco_decode_opt_box_autoadd_list_payment_details(arr[6]),
      sortAscending: dco_decode_opt_box_autoadd_bool(arr[7]),
    );
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<Rate> dco_decode_list_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rate).toList();
  }

  @protected
  List<RefundableSwap> dco_decode_list_refundable_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_refundable_swap).toList();
  }

  @protected
  List<RouteHint> dco_decode_list_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint).toList();
  }

  @protected
  List<RouteHintHop> dco_decode_list_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint_hop).toList();
  }

  @protected
  LNInvoice dco_decode_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LNInvoice(
      bolt11: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      payeePubkey: dco_decode_String(arr[2]),
      paymentHash: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      descriptionHash: dco_decode_opt_String(arr[5]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      expiry: dco_decode_u_64(arr[8]),
      routingHints: dco_decode_list_route_hint(arr[9]),
      paymentSecret: dco_decode_list_prim_u_8_strict(arr[10]),
      minFinalCltvExpiryDelta: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  LNOffer dco_decode_ln_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return LNOffer(
      offer: dco_decode_String(arr[0]),
      chains: dco_decode_list_String(arr[1]),
      minAmount: dco_decode_opt_box_autoadd_amount(arr[2]),
      description: dco_decode_opt_String(arr[3]),
      absoluteExpiry: dco_decode_opt_box_autoadd_u_64(arr[4]),
      issuer: dco_decode_opt_String(arr[5]),
      signingPubkey: dco_decode_opt_String(arr[6]),
      paths: dco_decode_list_ln_offer_blinded_path(arr[7]),
    );
  }

  @protected
  LnOfferBlindedPath dco_decode_ln_offer_blinded_path(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnOfferBlindedPath(blindedHops: dco_decode_list_String(arr[0]));
  }

  @protected
  LnUrlAuthError dco_decode_ln_url_auth_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlAuthError_Generic(err: dco_decode_String(raw[1]));
      case 1:
        return LnUrlAuthError_InvalidUri(err: dco_decode_String(raw[1]));
      case 2:
        return LnUrlAuthError_ServiceConnectivity(err: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlAuthRequestData dco_decode_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlAuthRequestData(
      k1: dco_decode_String(arr[0]),
      action: dco_decode_opt_String(arr[1]),
      domain: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  LnUrlCallbackStatus dco_decode_ln_url_callback_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        return LnUrlCallbackStatus_ErrorStatus(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlErrorData dco_decode_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlErrorData(reason: dco_decode_String(arr[0]));
  }

  @protected
  LnUrlInfo dco_decode_ln_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return LnUrlInfo(
      lnAddress: dco_decode_opt_String(arr[0]),
      lnurlPayComment: dco_decode_opt_String(arr[1]),
      lnurlPayDomain: dco_decode_opt_String(arr[2]),
      lnurlPayMetadata: dco_decode_opt_String(arr[3]),
      lnurlPaySuccessAction: dco_decode_opt_box_autoadd_success_action_processed(arr[4]),
      lnurlPayUnprocessedSuccessAction: dco_decode_opt_box_autoadd_success_action(arr[5]),
      lnurlWithdrawEndpoint: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  LnUrlPayError dco_decode_ln_url_pay_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlPayError_AlreadyPaid();
      case 1:
        return LnUrlPayError_Generic(err: dco_decode_String(raw[1]));
      case 2:
        return LnUrlPayError_InsufficientBalance(err: dco_decode_String(raw[1]));
      case 3:
        return LnUrlPayError_InvalidAmount(err: dco_decode_String(raw[1]));
      case 4:
        return LnUrlPayError_InvalidInvoice(err: dco_decode_String(raw[1]));
      case 5:
        return LnUrlPayError_InvalidNetwork(err: dco_decode_String(raw[1]));
      case 6:
        return LnUrlPayError_InvalidUri(err: dco_decode_String(raw[1]));
      case 7:
        return LnUrlPayError_InvoiceExpired(err: dco_decode_String(raw[1]));
      case 8:
        return LnUrlPayError_PaymentFailed(err: dco_decode_String(raw[1]));
      case 9:
        return LnUrlPayError_PaymentTimeout(err: dco_decode_String(raw[1]));
      case 10:
        return LnUrlPayError_RouteNotFound(err: dco_decode_String(raw[1]));
      case 11:
        return LnUrlPayError_RouteTooExpensive(err: dco_decode_String(raw[1]));
      case 12:
        return LnUrlPayError_ServiceConnectivity(err: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlPayErrorData dco_decode_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPayErrorData(paymentHash: dco_decode_String(arr[0]), reason: dco_decode_String(arr[1]));
  }

  @protected
  LnUrlPayRequest dco_decode_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlPayRequest(prepareResponse: dco_decode_prepare_ln_url_pay_response(arr[0]));
  }

  @protected
  LnUrlPayRequestData dco_decode_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9) throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return LnUrlPayRequestData(
      callback: dco_decode_String(arr[0]),
      minSendable: dco_decode_u_64(arr[1]),
      maxSendable: dco_decode_u_64(arr[2]),
      metadataStr: dco_decode_String(arr[3]),
      commentAllowed: dco_decode_u_16(arr[4]),
      domain: dco_decode_String(arr[5]),
      allowsNostr: dco_decode_bool(arr[6]),
      nostrPubkey: dco_decode_opt_String(arr[7]),
      lnAddress: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  LnUrlPayResult dco_decode_ln_url_pay_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlPayResult_EndpointSuccess(data: dco_decode_box_autoadd_ln_url_pay_success_data(raw[1]));
      case 1:
        return LnUrlPayResult_EndpointError(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      case 2:
        return LnUrlPayResult_PayError(data: dco_decode_box_autoadd_ln_url_pay_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlPaySuccessData dco_decode_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPaySuccessData(
      payment: dco_decode_payment(arr[0]),
      successAction: dco_decode_opt_box_autoadd_success_action_processed(arr[1]),
    );
  }

  @protected
  LnUrlWithdrawError dco_decode_ln_url_withdraw_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawError_Generic(err: dco_decode_String(raw[1]));
      case 1:
        return LnUrlWithdrawError_InvalidAmount(err: dco_decode_String(raw[1]));
      case 2:
        return LnUrlWithdrawError_InvalidInvoice(err: dco_decode_String(raw[1]));
      case 3:
        return LnUrlWithdrawError_InvalidUri(err: dco_decode_String(raw[1]));
      case 4:
        return LnUrlWithdrawError_InvoiceNoRoutingHints(err: dco_decode_String(raw[1]));
      case 5:
        return LnUrlWithdrawError_ServiceConnectivity(err: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawRequest dco_decode_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LnUrlWithdrawRequest(
      data: dco_decode_ln_url_withdraw_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LnUrlWithdrawRequestData(
      callback: dco_decode_String(arr[0]),
      k1: dco_decode_String(arr[1]),
      defaultDescription: dco_decode_String(arr[2]),
      minWithdrawable: dco_decode_u_64(arr[3]),
      maxWithdrawable: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  LnUrlWithdrawResult dco_decode_ln_url_withdraw_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawResult_Ok(data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]));
      case 1:
        return LnUrlWithdrawResult_Timeout(data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]));
      case 2:
        return LnUrlWithdrawResult_ErrorStatus(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlWithdrawSuccessData(invoice: dco_decode_ln_invoice(arr[0]));
  }

  @protected
  LocaleOverrides dco_decode_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LocaleOverrides(
      locale: dco_decode_String(arr[0]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[1]),
      symbol: dco_decode_symbol(arr[2]),
    );
  }

  @protected
  LocalizedName dco_decode_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedName(locale: dco_decode_String(arr[0]), name: dco_decode_String(arr[1]));
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LogEntry(line: dco_decode_String(arr[0]), level: dco_decode_String(arr[1]));
  }

  @protected
  MessageSuccessActionData dco_decode_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MessageSuccessActionData(message: dco_decode_String(arr[0]));
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  OnchainPaymentLimitsResponse dco_decode_onchain_payment_limits_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OnchainPaymentLimitsResponse(send: dco_decode_limits(arr[0]), receive: dco_decode_limits(arr[1]));
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Amount? dco_decode_opt_box_autoadd_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_amount(raw);
  }

  @protected
  AssetInfo? dco_decode_opt_box_autoadd_asset_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_asset_info(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  ListPaymentDetails? dco_decode_opt_box_autoadd_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_list_payment_details(raw);
  }

  @protected
  LnUrlInfo? dco_decode_opt_box_autoadd_ln_url_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ln_url_info(raw);
  }

  @protected
  PayAmount? dco_decode_opt_box_autoadd_pay_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_pay_amount(raw);
  }

  @protected
  Payment? dco_decode_opt_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment(raw);
  }

  @protected
  ReceiveAmount? dco_decode_opt_box_autoadd_receive_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_receive_amount(raw);
  }

  @protected
  SuccessAction? dco_decode_opt_box_autoadd_success_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_success_action(raw);
  }

  @protected
  SuccessActionProcessed? dco_decode_opt_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_success_action_processed(raw);
  }

  @protected
  Symbol? dco_decode_opt_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_symbol(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<AssetMetadata>? dco_decode_opt_list_asset_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_asset_metadata(raw);
  }

  @protected
  List<ExternalInputParser>? dco_decode_opt_list_external_input_parser(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_external_input_parser(raw);
  }

  @protected
  List<PaymentState>? dco_decode_opt_list_payment_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_payment_state(raw);
  }

  @protected
  List<PaymentType>? dco_decode_opt_list_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_payment_type(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PayAmount dco_decode_pay_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PayAmount_Bitcoin(receiverAmountSat: dco_decode_u_64(raw[1]));
      case 1:
        return PayAmount_Asset(
          toAsset: dco_decode_String(raw[1]),
          receiverAmount: dco_decode_f_64(raw[2]),
          estimateAssetFees: dco_decode_opt_box_autoadd_bool(raw[3]),
          fromAsset: dco_decode_opt_String(raw[4]),
        );
      case 2:
        return PayAmount_Drain();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PayOnchainRequest dco_decode_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PayOnchainRequest(
      address: dco_decode_String(arr[0]),
      prepareResponse: dco_decode_prepare_pay_onchain_response(arr[1]),
    );
  }

  @protected
  Payment dco_decode_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Payment(
      destination: dco_decode_opt_String(arr[0]),
      txId: dco_decode_opt_String(arr[1]),
      unblindingData: dco_decode_opt_String(arr[2]),
      timestamp: dco_decode_u_32(arr[3]),
      amountSat: dco_decode_u_64(arr[4]),
      feesSat: dco_decode_u_64(arr[5]),
      swapperFeesSat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      paymentType: dco_decode_payment_type(arr[7]),
      status: dco_decode_payment_state(arr[8]),
      details: dco_decode_payment_details(arr[9]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentDetails_Lightning(
          swapId: dco_decode_String(raw[1]),
          description: dco_decode_String(raw[2]),
          liquidExpirationBlockheight: dco_decode_u_32(raw[3]),
          preimage: dco_decode_opt_String(raw[4]),
          invoice: dco_decode_opt_String(raw[5]),
          bolt12Offer: dco_decode_opt_String(raw[6]),
          paymentHash: dco_decode_opt_String(raw[7]),
          destinationPubkey: dco_decode_opt_String(raw[8]),
          lnurlInfo: dco_decode_opt_box_autoadd_ln_url_info(raw[9]),
          bip353Address: dco_decode_opt_String(raw[10]),
          payerNote: dco_decode_opt_String(raw[11]),
          claimTxId: dco_decode_opt_String(raw[12]),
          refundTxId: dco_decode_opt_String(raw[13]),
          refundTxAmountSat: dco_decode_opt_box_autoadd_u_64(raw[14]),
        );
      case 1:
        return PaymentDetails_Liquid(
          destination: dco_decode_String(raw[1]),
          description: dco_decode_String(raw[2]),
          assetId: dco_decode_String(raw[3]),
          assetInfo: dco_decode_opt_box_autoadd_asset_info(raw[4]),
          lnurlInfo: dco_decode_opt_box_autoadd_ln_url_info(raw[5]),
          bip353Address: dco_decode_opt_String(raw[6]),
          payerNote: dco_decode_opt_String(raw[7]),
        );
      case 2:
        return PaymentDetails_Bitcoin(
          swapId: dco_decode_String(raw[1]),
          bitcoinAddress: dco_decode_String(raw[2]),
          description: dco_decode_String(raw[3]),
          autoAcceptedFees: dco_decode_bool(raw[4]),
          liquidExpirationBlockheight: dco_decode_u_32(raw[5]),
          bitcoinExpirationBlockheight: dco_decode_u_32(raw[6]),
          lockupTxId: dco_decode_opt_String(raw[7]),
          claimTxId: dco_decode_opt_String(raw[8]),
          refundTxId: dco_decode_opt_String(raw[9]),
          refundTxAmountSat: dco_decode_opt_box_autoadd_u_64(raw[10]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentError dco_decode_payment_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        return PaymentError_AmountOutOfRange(min: dco_decode_u_64(raw[1]), max: dco_decode_u_64(raw[2]));
      case 4:
        return PaymentError_AmountMissing(err: dco_decode_String(raw[1]));
      case 5:
        return PaymentError_AssetError(err: dco_decode_String(raw[1]));
      case 6:
        return PaymentError_InvalidNetwork(err: dco_decode_String(raw[1]));
      case 7:
        return PaymentError_Generic(err: dco_decode_String(raw[1]));
      case 8:
        return PaymentError_InvalidOrExpiredFees();
      case 9:
        return PaymentError_InsufficientFunds();
      case 10:
        return PaymentError_InvalidDescription(err: dco_decode_String(raw[1]));
      case 11:
        return PaymentError_InvalidInvoice(err: dco_decode_String(raw[1]));
      case 12:
        return PaymentError_InvalidPreimage();
      case 13:
        return PaymentError_PairsNotFound();
      case 14:
        return PaymentError_PaymentTimeout();
      case 15:
        return PaymentError_PersistError();
      case 16:
        return PaymentError_ReceiveError(err: dco_decode_String(raw[1]));
      case 17:
        return PaymentError_Refunded(err: dco_decode_String(raw[1]), refundTxId: dco_decode_String(raw[2]));
      case 18:
        return PaymentError_SelfTransferNotSupported();
      case 19:
        return PaymentError_SendError(err: dco_decode_String(raw[1]));
      case 20:
        return PaymentError_SignerError(err: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentMethod dco_decode_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentMethod.values[raw as int];
  }

  @protected
  PaymentState dco_decode_payment_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentState.values[raw as int];
  }

  @protected
  PaymentType dco_decode_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentType.values[raw as int];
  }

  @protected
  PrepareBuyBitcoinRequest dco_decode_prepare_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareBuyBitcoinRequest(
      provider: dco_decode_buy_bitcoin_provider(arr[0]),
      amountSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PrepareBuyBitcoinResponse dco_decode_prepare_buy_bitcoin_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareBuyBitcoinResponse(
      provider: dco_decode_buy_bitcoin_provider(arr[0]),
      amountSat: dco_decode_u_64(arr[1]),
      feesSat: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  PrepareLnUrlPayRequest dco_decode_prepare_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return PrepareLnUrlPayRequest(
      data: dco_decode_ln_url_pay_request_data(arr[0]),
      amount: dco_decode_pay_amount(arr[1]),
      bip353Address: dco_decode_opt_String(arr[2]),
      comment: dco_decode_opt_String(arr[3]),
      validateSuccessActionUrl: dco_decode_opt_box_autoadd_bool(arr[4]),
    );
  }

  @protected
  PrepareLnUrlPayResponse dco_decode_prepare_ln_url_pay_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PrepareLnUrlPayResponse(
      destination: dco_decode_send_destination(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
      data: dco_decode_ln_url_pay_request_data(arr[2]),
      amount: dco_decode_pay_amount(arr[3]),
      comment: dco_decode_opt_String(arr[4]),
      successAction: dco_decode_opt_box_autoadd_success_action(arr[5]),
    );
  }

  @protected
  PreparePayOnchainRequest dco_decode_prepare_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PreparePayOnchainRequest(
      amount: dco_decode_pay_amount(arr[0]),
      feeRateSatPerVbyte: dco_decode_opt_box_autoadd_u_32(arr[1]),
    );
  }

  @protected
  PreparePayOnchainResponse dco_decode_prepare_pay_onchain_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PreparePayOnchainResponse(
      receiverAmountSat: dco_decode_u_64(arr[0]),
      claimFeesSat: dco_decode_u_64(arr[1]),
      totalFeesSat: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  PrepareReceiveRequest dco_decode_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareReceiveRequest(
      paymentMethod: dco_decode_payment_method(arr[0]),
      amount: dco_decode_opt_box_autoadd_receive_amount(arr[1]),
    );
  }

  @protected
  PrepareReceiveResponse dco_decode_prepare_receive_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PrepareReceiveResponse(
      paymentMethod: dco_decode_payment_method(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
      amount: dco_decode_opt_box_autoadd_receive_amount(arr[2]),
      minPayerAmountSat: dco_decode_opt_box_autoadd_u_64(arr[3]),
      maxPayerAmountSat: dco_decode_opt_box_autoadd_u_64(arr[4]),
      swapperFeerate: dco_decode_opt_box_autoadd_f_64(arr[5]),
    );
  }

  @protected
  PrepareRefundRequest dco_decode_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareRefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      refundAddress: dco_decode_String(arr[1]),
      feeRateSatPerVbyte: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PrepareRefundResponse dco_decode_prepare_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareRefundResponse(
      txVsize: dco_decode_u_32(arr[0]),
      txFeeSat: dco_decode_u_64(arr[1]),
      lastRefundTxId: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  PrepareSendRequest dco_decode_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareSendRequest(
      destination: dco_decode_String(arr[0]),
      amount: dco_decode_opt_box_autoadd_pay_amount(arr[1]),
    );
  }

  @protected
  PrepareSendResponse dco_decode_prepare_send_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return PrepareSendResponse(
      destination: dco_decode_send_destination(arr[0]),
      amount: dco_decode_opt_box_autoadd_pay_amount(arr[1]),
      feesSat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      estimatedAssetFees: dco_decode_opt_box_autoadd_f_64(arr[3]),
      exchangeAmountSat: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  Rate dco_decode_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Rate(coin: dco_decode_String(arr[0]), value: dco_decode_f_64(arr[1]));
  }

  @protected
  ReceiveAmount dco_decode_receive_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ReceiveAmount_Bitcoin(payerAmountSat: dco_decode_u_64(raw[1]));
      case 1:
        return ReceiveAmount_Asset(
          assetId: dco_decode_String(raw[1]),
          payerAmount: dco_decode_opt_box_autoadd_f_64(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ReceivePaymentRequest dco_decode_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ReceivePaymentRequest(
      prepareResponse: dco_decode_prepare_receive_response(arr[0]),
      description: dco_decode_opt_String(arr[1]),
      useDescriptionHash: dco_decode_opt_box_autoadd_bool(arr[2]),
      payerNote: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ReceivePaymentResponse dco_decode_receive_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ReceivePaymentResponse(
      destination: dco_decode_String(arr[0]),
      liquidExpirationBlockheight: dco_decode_opt_box_autoadd_u_32(arr[1]),
      bitcoinExpirationBlockheight: dco_decode_opt_box_autoadd_u_32(arr[2]),
    );
  }

  @protected
  RecommendedFees dco_decode_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RecommendedFees(
      fastestFee: dco_decode_u_64(arr[0]),
      halfHourFee: dco_decode_u_64(arr[1]),
      hourFee: dco_decode_u_64(arr[2]),
      economyFee: dco_decode_u_64(arr[3]),
      minimumFee: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  RefundRequest dco_decode_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      refundAddress: dco_decode_String(arr[1]),
      feeRateSatPerVbyte: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  RefundResponse dco_decode_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RefundResponse(refundTxId: dco_decode_String(arr[0]));
  }

  @protected
  RefundableSwap dco_decode_refundable_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RefundableSwap(
      swapAddress: dco_decode_String(arr[0]),
      timestamp: dco_decode_u_32(arr[1]),
      amountSat: dco_decode_u_64(arr[2]),
      lastRefundTxId: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  RestoreRequest dco_decode_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RestoreRequest(backupPath: dco_decode_opt_String(arr[0]));
  }

  @protected
  RouteHint dco_decode_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RouteHint(hops: dco_decode_list_route_hint_hop(arr[0]));
  }

  @protected
  RouteHintHop dco_decode_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RouteHintHop(
      srcNodeId: dco_decode_String(arr[0]),
      shortChannelId: dco_decode_String(arr[1]),
      feesBaseMsat: dco_decode_u_32(arr[2]),
      feesProportionalMillionths: dco_decode_u_32(arr[3]),
      cltvExpiryDelta: dco_decode_u_64(arr[4]),
      htlcMinimumMsat: dco_decode_opt_box_autoadd_u_64(arr[5]),
      htlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  SdkError dco_decode_sdk_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SdkError_AlreadyStarted();
      case 1:
        return SdkError_Generic(err: dco_decode_String(raw[1]));
      case 2:
        return SdkError_NotStarted();
      case 3:
        return SdkError_ServiceConnectivity(err: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SdkEvent dco_decode_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SdkEvent_PaymentFailed(details: dco_decode_box_autoadd_payment(raw[1]));
      case 1:
        return SdkEvent_PaymentPending(details: dco_decode_box_autoadd_payment(raw[1]));
      case 2:
        return SdkEvent_PaymentRefundable(details: dco_decode_box_autoadd_payment(raw[1]));
      case 3:
        return SdkEvent_PaymentRefunded(details: dco_decode_box_autoadd_payment(raw[1]));
      case 4:
        return SdkEvent_PaymentRefundPending(details: dco_decode_box_autoadd_payment(raw[1]));
      case 5:
        return SdkEvent_PaymentSucceeded(details: dco_decode_box_autoadd_payment(raw[1]));
      case 6:
        return SdkEvent_PaymentWaitingConfirmation(details: dco_decode_box_autoadd_payment(raw[1]));
      case 7:
        return SdkEvent_PaymentWaitingFeeAcceptance(details: dco_decode_box_autoadd_payment(raw[1]));
      case 8:
        return SdkEvent_Synced();
      case 9:
        return SdkEvent_DataSynced(didPullNewRecords: dco_decode_bool(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SendDestination dco_decode_send_destination(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SendDestination_LiquidAddress(
          addressData: dco_decode_box_autoadd_liquid_address_data(raw[1]),
          bip353Address: dco_decode_opt_String(raw[2]),
        );
      case 1:
        return SendDestination_Bolt11(
          invoice: dco_decode_box_autoadd_ln_invoice(raw[1]),
          bip353Address: dco_decode_opt_String(raw[2]),
        );
      case 2:
        return SendDestination_Bolt12(
          offer: dco_decode_box_autoadd_ln_offer(raw[1]),
          receiverAmountSat: dco_decode_u_64(raw[2]),
          bip353Address: dco_decode_opt_String(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SendPaymentRequest dco_decode_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SendPaymentRequest(
      prepareResponse: dco_decode_prepare_send_response(arr[0]),
      useAssetFees: dco_decode_opt_box_autoadd_bool(arr[1]),
      payerNote: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  SendPaymentResponse dco_decode_send_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendPaymentResponse(payment: dco_decode_payment(arr[0]));
  }

  @protected
  SignMessageRequest dco_decode_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageRequest(message: dco_decode_String(arr[0]));
  }

  @protected
  SignMessageResponse dco_decode_sign_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageResponse(signature: dco_decode_String(arr[0]));
  }

  @protected
  SuccessAction dco_decode_success_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SuccessAction_Aes(data: dco_decode_box_autoadd_aes_success_action_data(raw[1]));
      case 1:
        return SuccessAction_Message(data: dco_decode_box_autoadd_message_success_action_data(raw[1]));
      case 2:
        return SuccessAction_Url(data: dco_decode_box_autoadd_url_success_action_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SuccessActionProcessed dco_decode_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SuccessActionProcessed_Aes(
          result: dco_decode_box_autoadd_aes_success_action_data_result(raw[1]),
        );
      case 1:
        return SuccessActionProcessed_Message(
          data: dco_decode_box_autoadd_message_success_action_data(raw[1]),
        );
      case 2:
        return SuccessActionProcessed_Url(data: dco_decode_box_autoadd_url_success_action_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Symbol dco_decode_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Symbol(
      grapheme: dco_decode_opt_String(arr[0]),
      template: dco_decode_opt_String(arr[1]),
      rtl: dco_decode_opt_box_autoadd_bool(arr[2]),
      position: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UrlSuccessActionData dco_decode_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UrlSuccessActionData(
      description: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
      matchesCallbackDomain: dco_decode_bool(arr[2]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WalletInfo dco_decode_wallet_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return WalletInfo(
      balanceSat: dco_decode_u_64(arr[0]),
      pendingSendSat: dco_decode_u_64(arr[1]),
      pendingReceiveSat: dco_decode_u_64(arr[2]),
      fingerprint: dco_decode_String(arr[3]),
      pubkey: dco_decode_String(arr[4]),
      assetBalances: dco_decode_list_asset_balance(arr[5]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  BindingLiquidSdk
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  BindingLiquidSdk
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  BindingLiquidSdk sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<SdkEvent> sse_decode_StreamSink_sdk_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AcceptPaymentProposedFeesRequest sse_decode_accept_payment_proposed_fees_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_response = sse_decode_fetch_payment_proposed_fees_response(deserializer);
    return AcceptPaymentProposedFeesRequest(response: var_response);
  }

  @protected
  AesSuccessActionData sse_decode_aes_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_ciphertext = sse_decode_String(deserializer);
    var var_iv = sse_decode_String(deserializer);
    return AesSuccessActionData(description: var_description, ciphertext: var_ciphertext, iv: var_iv);
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_aes_success_action_data_decrypted(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_plaintext = sse_decode_String(deserializer);
    return AesSuccessActionDataDecrypted(description: var_description, plaintext: var_plaintext);
  }

  @protected
  AesSuccessActionDataResult sse_decode_aes_success_action_data_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_aes_success_action_data_decrypted(deserializer);
        return AesSuccessActionDataResult_Decrypted(data: var_data);
      case 1:
        var var_reason = sse_decode_String(deserializer);
        return AesSuccessActionDataResult_ErrorStatus(reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Amount sse_decode_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_amountMsat = sse_decode_u_64(deserializer);
        return Amount_Bitcoin(amountMsat: var_amountMsat);
      case 1:
        var var_iso4217Code = sse_decode_String(deserializer);
        var var_fractionalAmount = sse_decode_u_64(deserializer);
        return Amount_Currency(iso4217Code: var_iso4217Code, fractionalAmount: var_fractionalAmount);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AssetBalance sse_decode_asset_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_assetId = sse_decode_String(deserializer);
    var var_balanceSat = sse_decode_u_64(deserializer);
    var var_name = sse_decode_opt_String(deserializer);
    var var_ticker = sse_decode_opt_String(deserializer);
    var var_balance = sse_decode_opt_box_autoadd_f_64(deserializer);
    return AssetBalance(
      assetId: var_assetId,
      balanceSat: var_balanceSat,
      name: var_name,
      ticker: var_ticker,
      balance: var_balance,
    );
  }

  @protected
  AssetInfo sse_decode_asset_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_ticker = sse_decode_String(deserializer);
    var var_amount = sse_decode_f_64(deserializer);
    var var_fees = sse_decode_opt_box_autoadd_f_64(deserializer);
    return AssetInfo(name: var_name, ticker: var_ticker, amount: var_amount, fees: var_fees);
  }

  @protected
  AssetMetadata sse_decode_asset_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_assetId = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_ticker = sse_decode_String(deserializer);
    var var_precision = sse_decode_u_8(deserializer);
    var var_fiatId = sse_decode_opt_String(deserializer);
    return AssetMetadata(
      assetId: var_assetId,
      name: var_name,
      ticker: var_ticker,
      precision: var_precision,
      fiatId: var_fiatId,
    );
  }

  @protected
  BackupRequest sse_decode_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return BackupRequest(backupPath: var_backupPath);
  }

  @protected
  BindingEventListener sse_decode_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_stream = sse_decode_StreamSink_sdk_event_Dco(deserializer);
    return BindingEventListener(stream: var_stream);
  }

  @protected
  BitcoinAddressData sse_decode_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_amountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_message = sse_decode_opt_String(deserializer);
    return BitcoinAddressData(
      address: var_address,
      network: var_network,
      amountSat: var_amountSat,
      label: var_label,
      message: var_message,
    );
  }

  @protected
  BlockchainExplorer sse_decode_blockchain_explorer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_url = sse_decode_String(deserializer);
        return BlockchainExplorer_Electrum(url: var_url);
      case 1:
        var var_url = sse_decode_String(deserializer);
        var var_useWaterfalls = sse_decode_bool(deserializer);
        return BlockchainExplorer_Esplora(url: var_url, useWaterfalls: var_useWaterfalls);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BlockchainInfo sse_decode_blockchain_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_liquidTip = sse_decode_u_32(deserializer);
    var var_bitcoinTip = sse_decode_u_32(deserializer);
    return BlockchainInfo(liquidTip: var_liquidTip, bitcoinTip: var_bitcoinTip);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AcceptPaymentProposedFeesRequest sse_decode_box_autoadd_accept_payment_proposed_fees_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_accept_payment_proposed_fees_request(deserializer));
  }

  @protected
  AesSuccessActionData sse_decode_box_autoadd_aes_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data(deserializer));
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_box_autoadd_aes_success_action_data_decrypted(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_decrypted(deserializer));
  }

  @protected
  AesSuccessActionDataResult sse_decode_box_autoadd_aes_success_action_data_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_result(deserializer));
  }

  @protected
  Amount sse_decode_box_autoadd_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_amount(deserializer));
  }

  @protected
  AssetInfo sse_decode_box_autoadd_asset_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_asset_info(deserializer));
  }

  @protected
  BackupRequest sse_decode_box_autoadd_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_backup_request(deserializer));
  }

  @protected
  BindingEventListener sse_decode_box_autoadd_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_binding_event_listener(deserializer));
  }

  @protected
  BitcoinAddressData sse_decode_box_autoadd_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bitcoin_address_data(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  BuyBitcoinRequest sse_decode_box_autoadd_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_buy_bitcoin_request(deserializer));
  }

  @protected
  CheckMessageRequest sse_decode_box_autoadd_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_check_message_request(deserializer));
  }

  @protected
  ConnectRequest sse_decode_box_autoadd_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connect_request(deserializer));
  }

  @protected
  CreateBolt12InvoiceRequest sse_decode_box_autoadd_create_bolt_12_invoice_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_create_bolt_12_invoice_request(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  FetchPaymentProposedFeesRequest sse_decode_box_autoadd_fetch_payment_proposed_fees_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fetch_payment_proposed_fees_request(deserializer));
  }

  @protected
  GetPaymentRequest sse_decode_box_autoadd_get_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_get_payment_request(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  LiquidAddressData sse_decode_box_autoadd_liquid_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquid_address_data(deserializer));
  }

  @protected
  ListPaymentDetails sse_decode_box_autoadd_list_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_list_payment_details(deserializer));
  }

  @protected
  ListPaymentsRequest sse_decode_box_autoadd_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_list_payments_request(deserializer));
  }

  @protected
  LNInvoice sse_decode_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_invoice(deserializer));
  }

  @protected
  LNOffer sse_decode_box_autoadd_ln_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_offer(deserializer));
  }

  @protected
  LnUrlAuthRequestData sse_decode_box_autoadd_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_auth_request_data(deserializer));
  }

  @protected
  LnUrlErrorData sse_decode_box_autoadd_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_error_data(deserializer));
  }

  @protected
  LnUrlInfo sse_decode_box_autoadd_ln_url_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_info(deserializer));
  }

  @protected
  LnUrlPayErrorData sse_decode_box_autoadd_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_error_data(deserializer));
  }

  @protected
  LnUrlPayRequest sse_decode_box_autoadd_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request(deserializer));
  }

  @protected
  LnUrlPayRequestData sse_decode_box_autoadd_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request_data(deserializer));
  }

  @protected
  LnUrlPaySuccessData sse_decode_box_autoadd_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_success_data(deserializer));
  }

  @protected
  LnUrlWithdrawRequest sse_decode_box_autoadd_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request(deserializer));
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_box_autoadd_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request_data(deserializer));
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_box_autoadd_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_success_data(deserializer));
  }

  @protected
  MessageSuccessActionData sse_decode_box_autoadd_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_message_success_action_data(deserializer));
  }

  @protected
  PayAmount sse_decode_box_autoadd_pay_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pay_amount(deserializer));
  }

  @protected
  PayOnchainRequest sse_decode_box_autoadd_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pay_onchain_request(deserializer));
  }

  @protected
  Payment sse_decode_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment(deserializer));
  }

  @protected
  PrepareBuyBitcoinRequest sse_decode_box_autoadd_prepare_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_buy_bitcoin_request(deserializer));
  }

  @protected
  PrepareLnUrlPayRequest sse_decode_box_autoadd_prepare_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_ln_url_pay_request(deserializer));
  }

  @protected
  PreparePayOnchainRequest sse_decode_box_autoadd_prepare_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_pay_onchain_request(deserializer));
  }

  @protected
  PrepareReceiveRequest sse_decode_box_autoadd_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_receive_request(deserializer));
  }

  @protected
  PrepareRefundRequest sse_decode_box_autoadd_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_refund_request(deserializer));
  }

  @protected
  PrepareSendRequest sse_decode_box_autoadd_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_send_request(deserializer));
  }

  @protected
  ReceiveAmount sse_decode_box_autoadd_receive_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_amount(deserializer));
  }

  @protected
  ReceivePaymentRequest sse_decode_box_autoadd_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_payment_request(deserializer));
  }

  @protected
  RefundRequest sse_decode_box_autoadd_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_refund_request(deserializer));
  }

  @protected
  RestoreRequest sse_decode_box_autoadd_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_restore_request(deserializer));
  }

  @protected
  SdkEvent sse_decode_box_autoadd_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sdk_event(deserializer));
  }

  @protected
  SendPaymentRequest sse_decode_box_autoadd_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_payment_request(deserializer));
  }

  @protected
  SignMessageRequest sse_decode_box_autoadd_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_message_request(deserializer));
  }

  @protected
  SuccessAction sse_decode_box_autoadd_success_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_success_action(deserializer));
  }

  @protected
  SuccessActionProcessed sse_decode_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_success_action_processed(deserializer));
  }

  @protected
  Symbol sse_decode_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_symbol(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UrlSuccessActionData sse_decode_box_autoadd_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_url_success_action_data(deserializer));
  }

  @protected
  BuyBitcoinProvider sse_decode_buy_bitcoin_provider(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BuyBitcoinProvider.values[inner];
  }

  @protected
  BuyBitcoinRequest sse_decode_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prepareResponse = sse_decode_prepare_buy_bitcoin_response(deserializer);
    var var_redirectUrl = sse_decode_opt_String(deserializer);
    return BuyBitcoinRequest(prepareResponse: var_prepareResponse, redirectUrl: var_redirectUrl);
  }

  @protected
  CheckMessageRequest sse_decode_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_signature = sse_decode_String(deserializer);
    return CheckMessageRequest(message: var_message, pubkey: var_pubkey, signature: var_signature);
  }

  @protected
  CheckMessageResponse sse_decode_check_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isValid = sse_decode_bool(deserializer);
    return CheckMessageResponse(isValid: var_isValid);
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_liquidExplorer = sse_decode_blockchain_explorer(deserializer);
    var var_bitcoinExplorer = sse_decode_blockchain_explorer(deserializer);
    var var_workingDir = sse_decode_String(deserializer);
    var var_network = sse_decode_liquid_network(deserializer);
    var var_paymentTimeoutSec = sse_decode_u_64(deserializer);
    var var_syncServiceUrl = sse_decode_opt_String(deserializer);
    var var_zeroConfMaxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_breezApiKey = sse_decode_opt_String(deserializer);
    var var_externalInputParsers = sse_decode_opt_list_external_input_parser(deserializer);
    var var_useDefaultExternalInputParsers = sse_decode_bool(deserializer);
    var var_onchainFeeRateLeewaySat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_assetMetadata = sse_decode_opt_list_asset_metadata(deserializer);
    var var_sideswapApiKey = sse_decode_opt_String(deserializer);
    var var_useMagicRoutingHints = sse_decode_bool(deserializer);
    return Config(
      liquidExplorer: var_liquidExplorer,
      bitcoinExplorer: var_bitcoinExplorer,
      workingDir: var_workingDir,
      network: var_network,
      paymentTimeoutSec: var_paymentTimeoutSec,
      syncServiceUrl: var_syncServiceUrl,
      zeroConfMaxAmountSat: var_zeroConfMaxAmountSat,
      breezApiKey: var_breezApiKey,
      externalInputParsers: var_externalInputParsers,
      useDefaultExternalInputParsers: var_useDefaultExternalInputParsers,
      onchainFeeRateLeewaySat: var_onchainFeeRateLeewaySat,
      assetMetadata: var_assetMetadata,
      sideswapApiKey: var_sideswapApiKey,
      useMagicRoutingHints: var_useMagicRoutingHints,
    );
  }

  @protected
  ConnectRequest sse_decode_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_config = sse_decode_config(deserializer);
    var var_mnemonic = sse_decode_opt_String(deserializer);
    var var_passphrase = sse_decode_opt_String(deserializer);
    var var_seed = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return ConnectRequest(
      config: var_config,
      mnemonic: var_mnemonic,
      passphrase: var_passphrase,
      seed: var_seed,
    );
  }

  @protected
  CreateBolt12InvoiceRequest sse_decode_create_bolt_12_invoice_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_offer = sse_decode_String(deserializer);
    var var_invoiceRequest = sse_decode_String(deserializer);
    return CreateBolt12InvoiceRequest(offer: var_offer, invoiceRequest: var_invoiceRequest);
  }

  @protected
  CreateBolt12InvoiceResponse sse_decode_create_bolt_12_invoice_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_String(deserializer);
    return CreateBolt12InvoiceResponse(invoice: var_invoice);
  }

  @protected
  CurrencyInfo sse_decode_currency_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_fractionSize = sse_decode_u_32(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_uniqSymbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_localizedName = sse_decode_list_localized_name(deserializer);
    var var_localeOverrides = sse_decode_list_locale_overrides(deserializer);
    return CurrencyInfo(
      name: var_name,
      fractionSize: var_fractionSize,
      spacing: var_spacing,
      symbol: var_symbol,
      uniqSymbol: var_uniqSymbol,
      localizedName: var_localizedName,
      localeOverrides: var_localeOverrides,
    );
  }

  @protected
  ExternalInputParser sse_decode_external_input_parser(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_providerId = sse_decode_String(deserializer);
    var var_inputRegex = sse_decode_String(deserializer);
    var var_parserUrl = sse_decode_String(deserializer);
    return ExternalInputParser(
      providerId: var_providerId,
      inputRegex: var_inputRegex,
      parserUrl: var_parserUrl,
    );
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FetchPaymentProposedFeesRequest sse_decode_fetch_payment_proposed_fees_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapId = sse_decode_String(deserializer);
    return FetchPaymentProposedFeesRequest(swapId: var_swapId);
  }

  @protected
  FetchPaymentProposedFeesResponse sse_decode_fetch_payment_proposed_fees_response(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapId = sse_decode_String(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_payerAmountSat = sse_decode_u_64(deserializer);
    var var_receiverAmountSat = sse_decode_u_64(deserializer);
    return FetchPaymentProposedFeesResponse(
      swapId: var_swapId,
      feesSat: var_feesSat,
      payerAmountSat: var_payerAmountSat,
      receiverAmountSat: var_receiverAmountSat,
    );
  }

  @protected
  FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_info = sse_decode_currency_info(deserializer);
    return FiatCurrency(id: var_id, info: var_info);
  }

  @protected
  GetInfoResponse sse_decode_get_info_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletInfo = sse_decode_wallet_info(deserializer);
    var var_blockchainInfo = sse_decode_blockchain_info(deserializer);
    return GetInfoResponse(walletInfo: var_walletInfo, blockchainInfo: var_blockchainInfo);
  }

  @protected
  GetPaymentRequest sse_decode_get_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_paymentHash = sse_decode_String(deserializer);
        return GetPaymentRequest_PaymentHash(paymentHash: var_paymentHash);
      case 1:
        var var_swapId = sse_decode_String(deserializer);
        return GetPaymentRequest_SwapId(swapId: var_swapId);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  InputType sse_decode_input_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_address = sse_decode_box_autoadd_bitcoin_address_data(deserializer);
        return InputType_BitcoinAddress(address: var_address);
      case 1:
        var var_address = sse_decode_box_autoadd_liquid_address_data(deserializer);
        return InputType_LiquidAddress(address: var_address);
      case 2:
        var var_invoice = sse_decode_box_autoadd_ln_invoice(deserializer);
        return InputType_Bolt11(invoice: var_invoice);
      case 3:
        var var_offer = sse_decode_box_autoadd_ln_offer(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return InputType_Bolt12Offer(offer: var_offer, bip353Address: var_bip353Address);
      case 4:
        var var_nodeId = sse_decode_String(deserializer);
        return InputType_NodeId(nodeId: var_nodeId);
      case 5:
        var var_url = sse_decode_String(deserializer);
        return InputType_Url(url: var_url);
      case 6:
        var var_data = sse_decode_box_autoadd_ln_url_pay_request_data(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return InputType_LnUrlPay(data: var_data, bip353Address: var_bip353Address);
      case 7:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_request_data(deserializer);
        return InputType_LnUrlWithdraw(data: var_data);
      case 8:
        var var_data = sse_decode_box_autoadd_ln_url_auth_request_data(deserializer);
        return InputType_LnUrlAuth(data: var_data);
      case 9:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return InputType_LnUrlError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LightningPaymentLimitsResponse sse_decode_lightning_payment_limits_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_send = sse_decode_limits(deserializer);
    var var_receive = sse_decode_limits(deserializer);
    return LightningPaymentLimitsResponse(send: var_send, receive: var_receive);
  }

  @protected
  Limits sse_decode_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minSat = sse_decode_u_64(deserializer);
    var var_maxSat = sse_decode_u_64(deserializer);
    var var_maxZeroConfSat = sse_decode_u_64(deserializer);
    return Limits(minSat: var_minSat, maxSat: var_maxSat, maxZeroConfSat: var_maxZeroConfSat);
  }

  @protected
  LiquidAddressData sse_decode_liquid_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_assetId = sse_decode_opt_String(deserializer);
    var var_amount = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_amountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_message = sse_decode_opt_String(deserializer);
    return LiquidAddressData(
      address: var_address,
      network: var_network,
      assetId: var_assetId,
      amount: var_amount,
      amountSat: var_amountSat,
      label: var_label,
      message: var_message,
    );
  }

  @protected
  LiquidNetwork sse_decode_liquid_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LiquidNetwork.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AssetBalance> sse_decode_list_asset_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AssetBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_asset_balance(deserializer));
    }
    return ans_;
  }

  @protected
  List<AssetMetadata> sse_decode_list_asset_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AssetMetadata>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_asset_metadata(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExternalInputParser> sse_decode_list_external_input_parser(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExternalInputParser>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_external_input_parser(deserializer));
    }
    return ans_;
  }

  @protected
  List<FiatCurrency> sse_decode_list_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FiatCurrency>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_fiat_currency(deserializer));
    }
    return ans_;
  }

  @protected
  List<LnOfferBlindedPath> sse_decode_list_ln_offer_blinded_path(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LnOfferBlindedPath>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ln_offer_blinded_path(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocaleOverrides> sse_decode_list_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocaleOverrides>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_locale_overrides(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedName> sse_decode_list_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalizedName>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_name(deserializer));
    }
    return ans_;
  }

  @protected
  List<Payment> sse_decode_list_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Payment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment(deserializer));
    }
    return ans_;
  }

  @protected
  ListPaymentDetails sse_decode_list_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_assetId = sse_decode_opt_String(deserializer);
        var var_destination = sse_decode_opt_String(deserializer);
        return ListPaymentDetails_Liquid(assetId: var_assetId, destination: var_destination);
      case 1:
        var var_address = sse_decode_opt_String(deserializer);
        return ListPaymentDetails_Bitcoin(address: var_address);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<PaymentState> sse_decode_list_payment_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentState>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_state(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentType> sse_decode_list_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_type(deserializer));
    }
    return ans_;
  }

  @protected
  ListPaymentsRequest sse_decode_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filters = sse_decode_opt_list_payment_type(deserializer);
    var var_states = sse_decode_opt_list_payment_state(deserializer);
    var var_fromTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_toTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_offset = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_limit = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_details = sse_decode_opt_box_autoadd_list_payment_details(deserializer);
    var var_sortAscending = sse_decode_opt_box_autoadd_bool(deserializer);
    return ListPaymentsRequest(
      filters: var_filters,
      states: var_states,
      fromTimestamp: var_fromTimestamp,
      toTimestamp: var_toTimestamp,
      offset: var_offset,
      limit: var_limit,
      details: var_details,
      sortAscending: var_sortAscending,
    );
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<Rate> sse_decode_list_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Rate>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rate(deserializer));
    }
    return ans_;
  }

  @protected
  List<RefundableSwap> sse_decode_list_refundable_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RefundableSwap>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_refundable_swap(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHint> sse_decode_list_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHintHop> sse_decode_list_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHintHop>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint_hop(deserializer));
    }
    return ans_;
  }

  @protected
  LNInvoice sse_decode_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_payeePubkey = sse_decode_String(deserializer);
    var var_paymentHash = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionHash = sse_decode_opt_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_routingHints = sse_decode_list_route_hint(deserializer);
    var var_paymentSecret = sse_decode_list_prim_u_8_strict(deserializer);
    var var_minFinalCltvExpiryDelta = sse_decode_u_64(deserializer);
    return LNInvoice(
      bolt11: var_bolt11,
      network: var_network,
      payeePubkey: var_payeePubkey,
      paymentHash: var_paymentHash,
      description: var_description,
      descriptionHash: var_descriptionHash,
      amountMsat: var_amountMsat,
      timestamp: var_timestamp,
      expiry: var_expiry,
      routingHints: var_routingHints,
      paymentSecret: var_paymentSecret,
      minFinalCltvExpiryDelta: var_minFinalCltvExpiryDelta,
    );
  }

  @protected
  LNOffer sse_decode_ln_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_offer = sse_decode_String(deserializer);
    var var_chains = sse_decode_list_String(deserializer);
    var var_minAmount = sse_decode_opt_box_autoadd_amount(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_absoluteExpiry = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_issuer = sse_decode_opt_String(deserializer);
    var var_signingPubkey = sse_decode_opt_String(deserializer);
    var var_paths = sse_decode_list_ln_offer_blinded_path(deserializer);
    return LNOffer(
      offer: var_offer,
      chains: var_chains,
      minAmount: var_minAmount,
      description: var_description,
      absoluteExpiry: var_absoluteExpiry,
      issuer: var_issuer,
      signingPubkey: var_signingPubkey,
      paths: var_paths,
    );
  }

  @protected
  LnOfferBlindedPath sse_decode_ln_offer_blinded_path(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blindedHops = sse_decode_list_String(deserializer);
    return LnOfferBlindedPath(blindedHops: var_blindedHops);
  }

  @protected
  LnUrlAuthError sse_decode_ln_url_auth_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_err = sse_decode_String(deserializer);
        return LnUrlAuthError_Generic(err: var_err);
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LnUrlAuthError_InvalidUri(err: var_err);
      case 2:
        var var_err = sse_decode_String(deserializer);
        return LnUrlAuthError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlAuthRequestData sse_decode_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_k1 = sse_decode_String(deserializer);
    var var_action = sse_decode_opt_String(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return LnUrlAuthRequestData(k1: var_k1, action: var_action, domain: var_domain, url: var_url);
  }

  @protected
  LnUrlCallbackStatus sse_decode_ln_url_callback_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlCallbackStatus_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlErrorData sse_decode_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reason = sse_decode_String(deserializer);
    return LnUrlErrorData(reason: var_reason);
  }

  @protected
  LnUrlInfo sse_decode_ln_url_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lnAddress = sse_decode_opt_String(deserializer);
    var var_lnurlPayComment = sse_decode_opt_String(deserializer);
    var var_lnurlPayDomain = sse_decode_opt_String(deserializer);
    var var_lnurlPayMetadata = sse_decode_opt_String(deserializer);
    var var_lnurlPaySuccessAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    var var_lnurlPayUnprocessedSuccessAction = sse_decode_opt_box_autoadd_success_action(deserializer);
    var var_lnurlWithdrawEndpoint = sse_decode_opt_String(deserializer);
    return LnUrlInfo(
      lnAddress: var_lnAddress,
      lnurlPayComment: var_lnurlPayComment,
      lnurlPayDomain: var_lnurlPayDomain,
      lnurlPayMetadata: var_lnurlPayMetadata,
      lnurlPaySuccessAction: var_lnurlPaySuccessAction,
      lnurlPayUnprocessedSuccessAction: var_lnurlPayUnprocessedSuccessAction,
      lnurlWithdrawEndpoint: var_lnurlWithdrawEndpoint,
    );
  }

  @protected
  LnUrlPayError sse_decode_ln_url_pay_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LnUrlPayError_AlreadyPaid();
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_Generic(err: var_err);
      case 2:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InsufficientBalance(err: var_err);
      case 3:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidAmount(err: var_err);
      case 4:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidInvoice(err: var_err);
      case 5:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidNetwork(err: var_err);
      case 6:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidUri(err: var_err);
      case 7:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvoiceExpired(err: var_err);
      case 8:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_PaymentFailed(err: var_err);
      case 9:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_PaymentTimeout(err: var_err);
      case 10:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_RouteNotFound(err: var_err);
      case 11:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_RouteTooExpensive(err: var_err);
      case 12:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlPayErrorData sse_decode_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_reason = sse_decode_String(deserializer);
    return LnUrlPayErrorData(paymentHash: var_paymentHash, reason: var_reason);
  }

  @protected
  LnUrlPayRequest sse_decode_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prepareResponse = sse_decode_prepare_ln_url_pay_response(deserializer);
    return LnUrlPayRequest(prepareResponse: var_prepareResponse);
  }

  @protected
  LnUrlPayRequestData sse_decode_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_minSendable = sse_decode_u_64(deserializer);
    var var_maxSendable = sse_decode_u_64(deserializer);
    var var_metadataStr = sse_decode_String(deserializer);
    var var_commentAllowed = sse_decode_u_16(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_allowsNostr = sse_decode_bool(deserializer);
    var var_nostrPubkey = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    return LnUrlPayRequestData(
      callback: var_callback,
      minSendable: var_minSendable,
      maxSendable: var_maxSendable,
      metadataStr: var_metadataStr,
      commentAllowed: var_commentAllowed,
      domain: var_domain,
      allowsNostr: var_allowsNostr,
      nostrPubkey: var_nostrPubkey,
      lnAddress: var_lnAddress,
    );
  }

  @protected
  LnUrlPayResult sse_decode_ln_url_pay_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_pay_success_data(deserializer);
        return LnUrlPayResult_EndpointSuccess(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlPayResult_EndpointError(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_pay_error_data(deserializer);
        return LnUrlPayResult_PayError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlPaySuccessData sse_decode_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    var var_successAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    return LnUrlPaySuccessData(payment: var_payment, successAction: var_successAction);
  }

  @protected
  LnUrlWithdrawError sse_decode_ln_url_withdraw_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_Generic(err: var_err);
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidAmount(err: var_err);
      case 2:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidInvoice(err: var_err);
      case 3:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidUri(err: var_err);
      case 4:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvoiceNoRoutingHints(err: var_err);
      case 5:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawRequest sse_decode_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_withdraw_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return LnUrlWithdrawRequest(data: var_data, amountMsat: var_amountMsat, description: var_description);
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_k1 = sse_decode_String(deserializer);
    var var_defaultDescription = sse_decode_String(deserializer);
    var var_minWithdrawable = sse_decode_u_64(deserializer);
    var var_maxWithdrawable = sse_decode_u_64(deserializer);
    return LnUrlWithdrawRequestData(
      callback: var_callback,
      k1: var_k1,
      defaultDescription: var_defaultDescription,
      minWithdrawable: var_minWithdrawable,
      maxWithdrawable: var_maxWithdrawable,
    );
  }

  @protected
  LnUrlWithdrawResult sse_decode_ln_url_withdraw_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Ok(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Timeout(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlWithdrawResult_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_ln_invoice(deserializer);
    return LnUrlWithdrawSuccessData(invoice: var_invoice);
  }

  @protected
  LocaleOverrides sse_decode_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_symbol(deserializer);
    return LocaleOverrides(locale: var_locale, spacing: var_spacing, symbol: var_symbol);
  }

  @protected
  LocalizedName sse_decode_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return LocalizedName(locale: var_locale, name: var_name);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_line = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    return LogEntry(line: var_line, level: var_level);
  }

  @protected
  MessageSuccessActionData sse_decode_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return MessageSuccessActionData(message: var_message);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  OnchainPaymentLimitsResponse sse_decode_onchain_payment_limits_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_send = sse_decode_limits(deserializer);
    var var_receive = sse_decode_limits(deserializer);
    return OnchainPaymentLimitsResponse(send: var_send, receive: var_receive);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Amount? sse_decode_opt_box_autoadd_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_amount(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AssetInfo? sse_decode_opt_box_autoadd_asset_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_asset_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ListPaymentDetails? sse_decode_opt_box_autoadd_list_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_list_payment_details(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LnUrlInfo? sse_decode_opt_box_autoadd_ln_url_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ln_url_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PayAmount? sse_decode_opt_box_autoadd_pay_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_pay_amount(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Payment? sse_decode_opt_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ReceiveAmount? sse_decode_opt_box_autoadd_receive_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_receive_amount(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SuccessAction? sse_decode_opt_box_autoadd_success_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_success_action(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SuccessActionProcessed? sse_decode_opt_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_success_action_processed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Symbol? sse_decode_opt_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_symbol(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<AssetMetadata>? sse_decode_opt_list_asset_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_asset_metadata(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ExternalInputParser>? sse_decode_opt_list_external_input_parser(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_external_input_parser(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<PaymentState>? sse_decode_opt_list_payment_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_payment_state(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<PaymentType>? sse_decode_opt_list_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_payment_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PayAmount sse_decode_pay_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_receiverAmountSat = sse_decode_u_64(deserializer);
        return PayAmount_Bitcoin(receiverAmountSat: var_receiverAmountSat);
      case 1:
        var var_toAsset = sse_decode_String(deserializer);
        var var_receiverAmount = sse_decode_f_64(deserializer);
        var var_estimateAssetFees = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_fromAsset = sse_decode_opt_String(deserializer);
        return PayAmount_Asset(
          toAsset: var_toAsset,
          receiverAmount: var_receiverAmount,
          estimateAssetFees: var_estimateAssetFees,
          fromAsset: var_fromAsset,
        );
      case 2:
        return PayAmount_Drain();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PayOnchainRequest sse_decode_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_prepareResponse = sse_decode_prepare_pay_onchain_response(deserializer);
    return PayOnchainRequest(address: var_address, prepareResponse: var_prepareResponse);
  }

  @protected
  Payment sse_decode_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_destination = sse_decode_opt_String(deserializer);
    var var_txId = sse_decode_opt_String(deserializer);
    var var_unblindingData = sse_decode_opt_String(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_swapperFeesSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_paymentType = sse_decode_payment_type(deserializer);
    var var_status = sse_decode_payment_state(deserializer);
    var var_details = sse_decode_payment_details(deserializer);
    return Payment(
      destination: var_destination,
      txId: var_txId,
      unblindingData: var_unblindingData,
      timestamp: var_timestamp,
      amountSat: var_amountSat,
      feesSat: var_feesSat,
      swapperFeesSat: var_swapperFeesSat,
      paymentType: var_paymentType,
      status: var_status,
      details: var_details,
    );
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_swapId = sse_decode_String(deserializer);
        var var_description = sse_decode_String(deserializer);
        var var_liquidExpirationBlockheight = sse_decode_u_32(deserializer);
        var var_preimage = sse_decode_opt_String(deserializer);
        var var_invoice = sse_decode_opt_String(deserializer);
        var var_bolt12Offer = sse_decode_opt_String(deserializer);
        var var_paymentHash = sse_decode_opt_String(deserializer);
        var var_destinationPubkey = sse_decode_opt_String(deserializer);
        var var_lnurlInfo = sse_decode_opt_box_autoadd_ln_url_info(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        var var_payerNote = sse_decode_opt_String(deserializer);
        var var_claimTxId = sse_decode_opt_String(deserializer);
        var var_refundTxId = sse_decode_opt_String(deserializer);
        var var_refundTxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
        return PaymentDetails_Lightning(
          swapId: var_swapId,
          description: var_description,
          liquidExpirationBlockheight: var_liquidExpirationBlockheight,
          preimage: var_preimage,
          invoice: var_invoice,
          bolt12Offer: var_bolt12Offer,
          paymentHash: var_paymentHash,
          destinationPubkey: var_destinationPubkey,
          lnurlInfo: var_lnurlInfo,
          bip353Address: var_bip353Address,
          payerNote: var_payerNote,
          claimTxId: var_claimTxId,
          refundTxId: var_refundTxId,
          refundTxAmountSat: var_refundTxAmountSat,
        );
      case 1:
        var var_destination = sse_decode_String(deserializer);
        var var_description = sse_decode_String(deserializer);
        var var_assetId = sse_decode_String(deserializer);
        var var_assetInfo = sse_decode_opt_box_autoadd_asset_info(deserializer);
        var var_lnurlInfo = sse_decode_opt_box_autoadd_ln_url_info(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        var var_payerNote = sse_decode_opt_String(deserializer);
        return PaymentDetails_Liquid(
          destination: var_destination,
          description: var_description,
          assetId: var_assetId,
          assetInfo: var_assetInfo,
          lnurlInfo: var_lnurlInfo,
          bip353Address: var_bip353Address,
          payerNote: var_payerNote,
        );
      case 2:
        var var_swapId = sse_decode_String(deserializer);
        var var_bitcoinAddress = sse_decode_String(deserializer);
        var var_description = sse_decode_String(deserializer);
        var var_autoAcceptedFees = sse_decode_bool(deserializer);
        var var_liquidExpirationBlockheight = sse_decode_u_32(deserializer);
        var var_bitcoinExpirationBlockheight = sse_decode_u_32(deserializer);
        var var_lockupTxId = sse_decode_opt_String(deserializer);
        var var_claimTxId = sse_decode_opt_String(deserializer);
        var var_refundTxId = sse_decode_opt_String(deserializer);
        var var_refundTxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
        return PaymentDetails_Bitcoin(
          swapId: var_swapId,
          bitcoinAddress: var_bitcoinAddress,
          description: var_description,
          autoAcceptedFees: var_autoAcceptedFees,
          liquidExpirationBlockheight: var_liquidExpirationBlockheight,
          bitcoinExpirationBlockheight: var_bitcoinExpirationBlockheight,
          lockupTxId: var_lockupTxId,
          claimTxId: var_claimTxId,
          refundTxId: var_refundTxId,
          refundTxAmountSat: var_refundTxAmountSat,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentError sse_decode_payment_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        var var_min = sse_decode_u_64(deserializer);
        var var_max = sse_decode_u_64(deserializer);
        return PaymentError_AmountOutOfRange(min: var_min, max: var_max);
      case 4:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_AmountMissing(err: var_err);
      case 5:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_AssetError(err: var_err);
      case 6:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_InvalidNetwork(err: var_err);
      case 7:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_Generic(err: var_err);
      case 8:
        return PaymentError_InvalidOrExpiredFees();
      case 9:
        return PaymentError_InsufficientFunds();
      case 10:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_InvalidDescription(err: var_err);
      case 11:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_InvalidInvoice(err: var_err);
      case 12:
        return PaymentError_InvalidPreimage();
      case 13:
        return PaymentError_PairsNotFound();
      case 14:
        return PaymentError_PaymentTimeout();
      case 15:
        return PaymentError_PersistError();
      case 16:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_ReceiveError(err: var_err);
      case 17:
        var var_err = sse_decode_String(deserializer);
        var var_refundTxId = sse_decode_String(deserializer);
        return PaymentError_Refunded(err: var_err, refundTxId: var_refundTxId);
      case 18:
        return PaymentError_SelfTransferNotSupported();
      case 19:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SendError(err: var_err);
      case 20:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SignerError(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentMethod sse_decode_payment_method(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentMethod.values[inner];
  }

  @protected
  PaymentState sse_decode_payment_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentState.values[inner];
  }

  @protected
  PaymentType sse_decode_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentType.values[inner];
  }

  @protected
  PrepareBuyBitcoinRequest sse_decode_prepare_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_provider = sse_decode_buy_bitcoin_provider(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    return PrepareBuyBitcoinRequest(provider: var_provider, amountSat: var_amountSat);
  }

  @protected
  PrepareBuyBitcoinResponse sse_decode_prepare_buy_bitcoin_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_provider = sse_decode_buy_bitcoin_provider(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    return PrepareBuyBitcoinResponse(provider: var_provider, amountSat: var_amountSat, feesSat: var_feesSat);
  }

  @protected
  PrepareLnUrlPayRequest sse_decode_prepare_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_pay_request_data(deserializer);
    var var_amount = sse_decode_pay_amount(deserializer);
    var var_bip353Address = sse_decode_opt_String(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    var var_validateSuccessActionUrl = sse_decode_opt_box_autoadd_bool(deserializer);
    return PrepareLnUrlPayRequest(
      data: var_data,
      amount: var_amount,
      bip353Address: var_bip353Address,
      comment: var_comment,
      validateSuccessActionUrl: var_validateSuccessActionUrl,
    );
  }

  @protected
  PrepareLnUrlPayResponse sse_decode_prepare_ln_url_pay_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_destination = sse_decode_send_destination(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_data = sse_decode_ln_url_pay_request_data(deserializer);
    var var_amount = sse_decode_pay_amount(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    var var_successAction = sse_decode_opt_box_autoadd_success_action(deserializer);
    return PrepareLnUrlPayResponse(
      destination: var_destination,
      feesSat: var_feesSat,
      data: var_data,
      amount: var_amount,
      comment: var_comment,
      successAction: var_successAction,
    );
  }

  @protected
  PreparePayOnchainRequest sse_decode_prepare_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amount = sse_decode_pay_amount(deserializer);
    var var_feeRateSatPerVbyte = sse_decode_opt_box_autoadd_u_32(deserializer);
    return PreparePayOnchainRequest(amount: var_amount, feeRateSatPerVbyte: var_feeRateSatPerVbyte);
  }

  @protected
  PreparePayOnchainResponse sse_decode_prepare_pay_onchain_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_receiverAmountSat = sse_decode_u_64(deserializer);
    var var_claimFeesSat = sse_decode_u_64(deserializer);
    var var_totalFeesSat = sse_decode_u_64(deserializer);
    return PreparePayOnchainResponse(
      receiverAmountSat: var_receiverAmountSat,
      claimFeesSat: var_claimFeesSat,
      totalFeesSat: var_totalFeesSat,
    );
  }

  @protected
  PrepareReceiveRequest sse_decode_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentMethod = sse_decode_payment_method(deserializer);
    var var_amount = sse_decode_opt_box_autoadd_receive_amount(deserializer);
    return PrepareReceiveRequest(paymentMethod: var_paymentMethod, amount: var_amount);
  }

  @protected
  PrepareReceiveResponse sse_decode_prepare_receive_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentMethod = sse_decode_payment_method(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_amount = sse_decode_opt_box_autoadd_receive_amount(deserializer);
    var var_minPayerAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_maxPayerAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_swapperFeerate = sse_decode_opt_box_autoadd_f_64(deserializer);
    return PrepareReceiveResponse(
      paymentMethod: var_paymentMethod,
      feesSat: var_feesSat,
      amount: var_amount,
      minPayerAmountSat: var_minPayerAmountSat,
      maxPayerAmountSat: var_maxPayerAmountSat,
      swapperFeerate: var_swapperFeerate,
    );
  }

  @protected
  PrepareRefundRequest sse_decode_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_refundAddress = sse_decode_String(deserializer);
    var var_feeRateSatPerVbyte = sse_decode_u_32(deserializer);
    return PrepareRefundRequest(
      swapAddress: var_swapAddress,
      refundAddress: var_refundAddress,
      feeRateSatPerVbyte: var_feeRateSatPerVbyte,
    );
  }

  @protected
  PrepareRefundResponse sse_decode_prepare_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txVsize = sse_decode_u_32(deserializer);
    var var_txFeeSat = sse_decode_u_64(deserializer);
    var var_lastRefundTxId = sse_decode_opt_String(deserializer);
    return PrepareRefundResponse(
      txVsize: var_txVsize,
      txFeeSat: var_txFeeSat,
      lastRefundTxId: var_lastRefundTxId,
    );
  }

  @protected
  PrepareSendRequest sse_decode_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_destination = sse_decode_String(deserializer);
    var var_amount = sse_decode_opt_box_autoadd_pay_amount(deserializer);
    return PrepareSendRequest(destination: var_destination, amount: var_amount);
  }

  @protected
  PrepareSendResponse sse_decode_prepare_send_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_destination = sse_decode_send_destination(deserializer);
    var var_amount = sse_decode_opt_box_autoadd_pay_amount(deserializer);
    var var_feesSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_estimatedAssetFees = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_exchangeAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return PrepareSendResponse(
      destination: var_destination,
      amount: var_amount,
      feesSat: var_feesSat,
      estimatedAssetFees: var_estimatedAssetFees,
      exchangeAmountSat: var_exchangeAmountSat,
    );
  }

  @protected
  Rate sse_decode_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_coin = sse_decode_String(deserializer);
    var var_value = sse_decode_f_64(deserializer);
    return Rate(coin: var_coin, value: var_value);
  }

  @protected
  ReceiveAmount sse_decode_receive_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_payerAmountSat = sse_decode_u_64(deserializer);
        return ReceiveAmount_Bitcoin(payerAmountSat: var_payerAmountSat);
      case 1:
        var var_assetId = sse_decode_String(deserializer);
        var var_payerAmount = sse_decode_opt_box_autoadd_f_64(deserializer);
        return ReceiveAmount_Asset(assetId: var_assetId, payerAmount: var_payerAmount);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ReceivePaymentRequest sse_decode_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prepareResponse = sse_decode_prepare_receive_response(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_useDescriptionHash = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_payerNote = sse_decode_opt_String(deserializer);
    return ReceivePaymentRequest(
      prepareResponse: var_prepareResponse,
      description: var_description,
      useDescriptionHash: var_useDescriptionHash,
      payerNote: var_payerNote,
    );
  }

  @protected
  ReceivePaymentResponse sse_decode_receive_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_destination = sse_decode_String(deserializer);
    var var_liquidExpirationBlockheight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_bitcoinExpirationBlockheight = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ReceivePaymentResponse(
      destination: var_destination,
      liquidExpirationBlockheight: var_liquidExpirationBlockheight,
      bitcoinExpirationBlockheight: var_bitcoinExpirationBlockheight,
    );
  }

  @protected
  RecommendedFees sse_decode_recommended_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fastestFee = sse_decode_u_64(deserializer);
    var var_halfHourFee = sse_decode_u_64(deserializer);
    var var_hourFee = sse_decode_u_64(deserializer);
    var var_economyFee = sse_decode_u_64(deserializer);
    var var_minimumFee = sse_decode_u_64(deserializer);
    return RecommendedFees(
      fastestFee: var_fastestFee,
      halfHourFee: var_halfHourFee,
      hourFee: var_hourFee,
      economyFee: var_economyFee,
      minimumFee: var_minimumFee,
    );
  }

  @protected
  RefundRequest sse_decode_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_refundAddress = sse_decode_String(deserializer);
    var var_feeRateSatPerVbyte = sse_decode_u_32(deserializer);
    return RefundRequest(
      swapAddress: var_swapAddress,
      refundAddress: var_refundAddress,
      feeRateSatPerVbyte: var_feeRateSatPerVbyte,
    );
  }

  @protected
  RefundResponse sse_decode_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_refundTxId = sse_decode_String(deserializer);
    return RefundResponse(refundTxId: var_refundTxId);
  }

  @protected
  RefundableSwap sse_decode_refundable_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_lastRefundTxId = sse_decode_opt_String(deserializer);
    return RefundableSwap(
      swapAddress: var_swapAddress,
      timestamp: var_timestamp,
      amountSat: var_amountSat,
      lastRefundTxId: var_lastRefundTxId,
    );
  }

  @protected
  RestoreRequest sse_decode_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return RestoreRequest(backupPath: var_backupPath);
  }

  @protected
  RouteHint sse_decode_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hops = sse_decode_list_route_hint_hop(deserializer);
    return RouteHint(hops: var_hops);
  }

  @protected
  RouteHintHop sse_decode_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcNodeId = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_String(deserializer);
    var var_feesBaseMsat = sse_decode_u_32(deserializer);
    var var_feesProportionalMillionths = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_64(deserializer);
    var var_htlcMinimumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return RouteHintHop(
      srcNodeId: var_srcNodeId,
      shortChannelId: var_shortChannelId,
      feesBaseMsat: var_feesBaseMsat,
      feesProportionalMillionths: var_feesProportionalMillionths,
      cltvExpiryDelta: var_cltvExpiryDelta,
      htlcMinimumMsat: var_htlcMinimumMsat,
      htlcMaximumMsat: var_htlcMaximumMsat,
    );
  }

  @protected
  SdkError sse_decode_sdk_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return SdkError_AlreadyStarted();
      case 1:
        var var_err = sse_decode_String(deserializer);
        return SdkError_Generic(err: var_err);
      case 2:
        return SdkError_NotStarted();
      case 3:
        var var_err = sse_decode_String(deserializer);
        return SdkError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SdkEvent sse_decode_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentFailed(details: var_details);
      case 1:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentPending(details: var_details);
      case 2:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentRefundable(details: var_details);
      case 3:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentRefunded(details: var_details);
      case 4:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentRefundPending(details: var_details);
      case 5:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentSucceeded(details: var_details);
      case 6:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentWaitingConfirmation(details: var_details);
      case 7:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return SdkEvent_PaymentWaitingFeeAcceptance(details: var_details);
      case 8:
        return SdkEvent_Synced();
      case 9:
        var var_didPullNewRecords = sse_decode_bool(deserializer);
        return SdkEvent_DataSynced(didPullNewRecords: var_didPullNewRecords);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SendDestination sse_decode_send_destination(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_addressData = sse_decode_box_autoadd_liquid_address_data(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return SendDestination_LiquidAddress(addressData: var_addressData, bip353Address: var_bip353Address);
      case 1:
        var var_invoice = sse_decode_box_autoadd_ln_invoice(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return SendDestination_Bolt11(invoice: var_invoice, bip353Address: var_bip353Address);
      case 2:
        var var_offer = sse_decode_box_autoadd_ln_offer(deserializer);
        var var_receiverAmountSat = sse_decode_u_64(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return SendDestination_Bolt12(
          offer: var_offer,
          receiverAmountSat: var_receiverAmountSat,
          bip353Address: var_bip353Address,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SendPaymentRequest sse_decode_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prepareResponse = sse_decode_prepare_send_response(deserializer);
    var var_useAssetFees = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_payerNote = sse_decode_opt_String(deserializer);
    return SendPaymentRequest(
      prepareResponse: var_prepareResponse,
      useAssetFees: var_useAssetFees,
      payerNote: var_payerNote,
    );
  }

  @protected
  SendPaymentResponse sse_decode_send_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    return SendPaymentResponse(payment: var_payment);
  }

  @protected
  SignMessageRequest sse_decode_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return SignMessageRequest(message: var_message);
  }

  @protected
  SignMessageResponse sse_decode_sign_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signature = sse_decode_String(deserializer);
    return SignMessageResponse(signature: var_signature);
  }

  @protected
  SuccessAction sse_decode_success_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_aes_success_action_data(deserializer);
        return SuccessAction_Aes(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_message_success_action_data(deserializer);
        return SuccessAction_Message(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_url_success_action_data(deserializer);
        return SuccessAction_Url(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SuccessActionProcessed sse_decode_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_result = sse_decode_box_autoadd_aes_success_action_data_result(deserializer);
        return SuccessActionProcessed_Aes(result: var_result);
      case 1:
        var var_data = sse_decode_box_autoadd_message_success_action_data(deserializer);
        return SuccessActionProcessed_Message(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_url_success_action_data(deserializer);
        return SuccessActionProcessed_Url(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Symbol sse_decode_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_grapheme = sse_decode_opt_String(deserializer);
    var var_template = sse_decode_opt_String(deserializer);
    var var_rtl = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_position = sse_decode_opt_box_autoadd_u_32(deserializer);
    return Symbol(grapheme: var_grapheme, template: var_template, rtl: var_rtl, position: var_position);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UrlSuccessActionData sse_decode_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_matchesCallbackDomain = sse_decode_bool(deserializer);
    return UrlSuccessActionData(
      description: var_description,
      url: var_url,
      matchesCallbackDomain: var_matchesCallbackDomain,
    );
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WalletInfo sse_decode_wallet_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_balanceSat = sse_decode_u_64(deserializer);
    var var_pendingSendSat = sse_decode_u_64(deserializer);
    var var_pendingReceiveSat = sse_decode_u_64(deserializer);
    var var_fingerprint = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_assetBalances = sse_decode_list_asset_balance(deserializer);
    return WalletInfo(
      balanceSat: var_balanceSat,
      pendingSendSat: var_pendingSendSat,
      pendingReceiveSat: var_pendingReceiveSat,
      fingerprint: var_fingerprint,
      pubkey: var_pubkey,
      assetBalances: var_assetBalances,
    );
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk raw,
  ) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    // ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_buy_bitcoin_provider(BuyBitcoinProvider raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_liquid_network(LiquidNetwork raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_method(PaymentMethod raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_state(PaymentState raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type(PaymentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
    BindingLiquidSdk self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Dco(RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: DcoCodec(decodeSuccessData: dco_decode_log_entry, decodeErrorData: dco_decode_AnyhowException),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_sdk_event_Dco(RustStreamSink<SdkEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: DcoCodec(decodeSuccessData: dco_decode_sdk_event, decodeErrorData: dco_decode_AnyhowException),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_accept_payment_proposed_fees_request(
    AcceptPaymentProposedFeesRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fetch_payment_proposed_fees_response(self.response, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data(AesSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.ciphertext, serializer);
    sse_encode_String(self.iv, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_decrypted(
    AesSuccessActionDataDecrypted self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.plaintext, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_result(AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AesSuccessActionDataResult_Decrypted(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_decrypted(data, serializer);
      case AesSuccessActionDataResult_ErrorStatus(reason: final reason):
        sse_encode_i_32(1, serializer);
        sse_encode_String(reason, serializer);
    }
  }

  @protected
  void sse_encode_amount(Amount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Amount_Bitcoin(amountMsat: final amountMsat):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(amountMsat, serializer);
      case Amount_Currency(iso4217Code: final iso4217Code, fractionalAmount: final fractionalAmount):
        sse_encode_i_32(1, serializer);
        sse_encode_String(iso4217Code, serializer);
        sse_encode_u_64(fractionalAmount, serializer);
    }
  }

  @protected
  void sse_encode_asset_balance(AssetBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.assetId, serializer);
    sse_encode_u_64(self.balanceSat, serializer);
    sse_encode_opt_String(self.name, serializer);
    sse_encode_opt_String(self.ticker, serializer);
    sse_encode_opt_box_autoadd_f_64(self.balance, serializer);
  }

  @protected
  void sse_encode_asset_info(AssetInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.ticker, serializer);
    sse_encode_f_64(self.amount, serializer);
    sse_encode_opt_box_autoadd_f_64(self.fees, serializer);
  }

  @protected
  void sse_encode_asset_metadata(AssetMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.assetId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.ticker, serializer);
    sse_encode_u_8(self.precision, serializer);
    sse_encode_opt_String(self.fiatId, serializer);
  }

  @protected
  void sse_encode_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_StreamSink_sdk_event_Dco(self.stream, serializer);
  }

  @protected
  void sse_encode_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_opt_String(self.message, serializer);
  }

  @protected
  void sse_encode_blockchain_explorer(BlockchainExplorer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BlockchainExplorer_Electrum(url: final url):
        sse_encode_i_32(0, serializer);
        sse_encode_String(url, serializer);
      case BlockchainExplorer_Esplora(url: final url, useWaterfalls: final useWaterfalls):
        sse_encode_i_32(1, serializer);
        sse_encode_String(url, serializer);
        sse_encode_bool(useWaterfalls, serializer);
    }
  }

  @protected
  void sse_encode_blockchain_info(BlockchainInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.liquidTip, serializer);
    sse_encode_u_32(self.bitcoinTip, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_accept_payment_proposed_fees_request(
    AcceptPaymentProposedFeesRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_accept_payment_proposed_fees_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data(AesSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_decrypted(
    AesSuccessActionDataDecrypted self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_decrypted(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_result(
    AesSuccessActionDataResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_result(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_amount(Amount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_amount(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_asset_info(AssetInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_asset_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_backup_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_binding_event_listener(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_address_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_check_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connect_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_create_bolt_12_invoice_request(
    CreateBolt12InvoiceRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_create_bolt_12_invoice_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fetch_payment_proposed_fees_request(
    FetchPaymentProposedFeesRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fetch_payment_proposed_fees_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_get_payment_request(GetPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_get_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquid_address_data(LiquidAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquid_address_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_list_payment_details(ListPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_payments_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_offer(LNOffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_offer(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_auth_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_info(LnUrlInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request_data(
    LnUrlWithdrawRequestData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_success_data(
    LnUrlWithdrawSuccessData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_message_success_action_data(
    MessageSuccessActionData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_message_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pay_amount(PayAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pay_amount(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pay_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_buy_bitcoin_request(
    PrepareBuyBitcoinRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_buy_bitcoin_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_ln_url_pay_request(
    PrepareLnUrlPayRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_ln_url_pay_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_pay_onchain_request(
    PreparePayOnchainRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_pay_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_amount(ReceiveAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_amount(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_restore_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sdk_event(SdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sdk_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_success_action(SuccessAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_success_action(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_success_action_processed(
    SuccessActionProcessed self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_success_action_processed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_symbol(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_url_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_provider(BuyBitcoinProvider self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_buy_bitcoin_response(self.prepareResponse, serializer);
    sse_encode_opt_String(self.redirectUrl, serializer);
  }

  @protected
  void sse_encode_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_check_message_response(CheckMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isValid, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_blockchain_explorer(self.liquidExplorer, serializer);
    sse_encode_blockchain_explorer(self.bitcoinExplorer, serializer);
    sse_encode_String(self.workingDir, serializer);
    sse_encode_liquid_network(self.network, serializer);
    sse_encode_u_64(self.paymentTimeoutSec, serializer);
    sse_encode_opt_String(self.syncServiceUrl, serializer);
    sse_encode_opt_box_autoadd_u_64(self.zeroConfMaxAmountSat, serializer);
    sse_encode_opt_String(self.breezApiKey, serializer);
    sse_encode_opt_list_external_input_parser(self.externalInputParsers, serializer);
    sse_encode_bool(self.useDefaultExternalInputParsers, serializer);
    sse_encode_opt_box_autoadd_u_64(self.onchainFeeRateLeewaySat, serializer);
    sse_encode_opt_list_asset_metadata(self.assetMetadata, serializer);
    sse_encode_opt_String(self.sideswapApiKey, serializer);
    sse_encode_bool(self.useMagicRoutingHints, serializer);
  }

  @protected
  void sse_encode_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self.config, serializer);
    sse_encode_opt_String(self.mnemonic, serializer);
    sse_encode_opt_String(self.passphrase, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_create_bolt_12_invoice_request(CreateBolt12InvoiceRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.offer, serializer);
    sse_encode_String(self.invoiceRequest, serializer);
  }

  @protected
  void sse_encode_create_bolt_12_invoice_response(
    CreateBolt12InvoiceResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_currency_info(CurrencyInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.fractionSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_opt_box_autoadd_symbol(self.symbol, serializer);
    sse_encode_opt_box_autoadd_symbol(self.uniqSymbol, serializer);
    sse_encode_list_localized_name(self.localizedName, serializer);
    sse_encode_list_locale_overrides(self.localeOverrides, serializer);
  }

  @protected
  void sse_encode_external_input_parser(ExternalInputParser self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.providerId, serializer);
    sse_encode_String(self.inputRegex, serializer);
    sse_encode_String(self.parserUrl, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fetch_payment_proposed_fees_request(
    FetchPaymentProposedFeesRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapId, serializer);
  }

  @protected
  void sse_encode_fetch_payment_proposed_fees_response(
    FetchPaymentProposedFeesResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapId, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_u_64(self.payerAmountSat, serializer);
    sse_encode_u_64(self.receiverAmountSat, serializer);
  }

  @protected
  void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_currency_info(self.info, serializer);
  }

  @protected
  void sse_encode_get_info_response(GetInfoResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_info(self.walletInfo, serializer);
    sse_encode_blockchain_info(self.blockchainInfo, serializer);
  }

  @protected
  void sse_encode_get_payment_request(GetPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GetPaymentRequest_PaymentHash(paymentHash: final paymentHash):
        sse_encode_i_32(0, serializer);
        sse_encode_String(paymentHash, serializer);
      case GetPaymentRequest_SwapId(swapId: final swapId):
        sse_encode_i_32(1, serializer);
        sse_encode_String(swapId, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_input_type(InputType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case InputType_BitcoinAddress(address: final address):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_bitcoin_address_data(address, serializer);
      case InputType_LiquidAddress(address: final address):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_liquid_address_data(address, serializer);
      case InputType_Bolt11(invoice: final invoice):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_invoice(invoice, serializer);
      case InputType_Bolt12Offer(offer: final offer, bip353Address: final bip353Address):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_ln_offer(offer, serializer);
        sse_encode_opt_String(bip353Address, serializer);
      case InputType_NodeId(nodeId: final nodeId):
        sse_encode_i_32(4, serializer);
        sse_encode_String(nodeId, serializer);
      case InputType_Url(url: final url):
        sse_encode_i_32(5, serializer);
        sse_encode_String(url, serializer);
      case InputType_LnUrlPay(data: final data, bip353Address: final bip353Address):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_ln_url_pay_request_data(data, serializer);
        sse_encode_opt_String(bip353Address, serializer);
      case InputType_LnUrlWithdraw(data: final data):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_request_data(data, serializer);
      case InputType_LnUrlAuth(data: final data):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_ln_url_auth_request_data(data, serializer);
      case InputType_LnUrlError(data: final data):
        sse_encode_i_32(9, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_lightning_payment_limits_response(
    LightningPaymentLimitsResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_limits(self.send, serializer);
    sse_encode_limits(self.receive, serializer);
  }

  @protected
  void sse_encode_limits(Limits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minSat, serializer);
    sse_encode_u_64(self.maxSat, serializer);
    sse_encode_u_64(self.maxZeroConfSat, serializer);
  }

  @protected
  void sse_encode_liquid_address_data(LiquidAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_String(self.assetId, serializer);
    sse_encode_opt_box_autoadd_f_64(self.amount, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_opt_String(self.message, serializer);
  }

  @protected
  void sse_encode_liquid_network(LiquidNetwork self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_asset_balance(List<AssetBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_asset_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_asset_metadata(List<AssetMetadata> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_asset_metadata(item, serializer);
    }
  }

  @protected
  void sse_encode_list_external_input_parser(List<ExternalInputParser> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_external_input_parser(item, serializer);
    }
  }

  @protected
  void sse_encode_list_fiat_currency(List<FiatCurrency> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_fiat_currency(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ln_offer_blinded_path(List<LnOfferBlindedPath> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ln_offer_blinded_path(item, serializer);
    }
  }

  @protected
  void sse_encode_list_locale_overrides(List<LocaleOverrides> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_locale_overrides(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_name(List<LocalizedName> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_name(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment(List<Payment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_details(ListPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ListPaymentDetails_Liquid(assetId: final assetId, destination: final destination):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(assetId, serializer);
        sse_encode_opt_String(destination, serializer);
      case ListPaymentDetails_Bitcoin(address: final address):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_String(address, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_state(List<PaymentState> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_state(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_type(List<PaymentType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_payment_type(self.filters, serializer);
    sse_encode_opt_list_payment_state(self.states, serializer);
    sse_encode_opt_box_autoadd_i_64(self.fromTimestamp, serializer);
    sse_encode_opt_box_autoadd_i_64(self.toTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_32(self.offset, serializer);
    sse_encode_opt_box_autoadd_u_32(self.limit, serializer);
    sse_encode_opt_box_autoadd_list_payment_details(self.details, serializer);
    sse_encode_opt_box_autoadd_bool(self.sortAscending, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_rate(List<Rate> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rate(item, serializer);
    }
  }

  @protected
  void sse_encode_list_refundable_swap(List<RefundableSwap> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_refundable_swap(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint(List<RouteHint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint_hop(List<RouteHintHop> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint_hop(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.payeePubkey, serializer);
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_list_route_hint(self.routingHints, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentSecret, serializer);
    sse_encode_u_64(self.minFinalCltvExpiryDelta, serializer);
  }

  @protected
  void sse_encode_ln_offer(LNOffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.offer, serializer);
    sse_encode_list_String(self.chains, serializer);
    sse_encode_opt_box_autoadd_amount(self.minAmount, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_box_autoadd_u_64(self.absoluteExpiry, serializer);
    sse_encode_opt_String(self.issuer, serializer);
    sse_encode_opt_String(self.signingPubkey, serializer);
    sse_encode_list_ln_offer_blinded_path(self.paths, serializer);
  }

  @protected
  void sse_encode_ln_offer_blinded_path(LnOfferBlindedPath self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.blindedHops, serializer);
  }

  @protected
  void sse_encode_ln_url_auth_error(LnUrlAuthError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlAuthError_Generic(err: final err):
        sse_encode_i_32(0, serializer);
        sse_encode_String(err, serializer);
      case LnUrlAuthError_InvalidUri(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LnUrlAuthError_ServiceConnectivity(err: final err):
        sse_encode_i_32(2, serializer);
        sse_encode_String(err, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.k1, serializer);
    sse_encode_opt_String(self.action, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_ln_url_callback_status(LnUrlCallbackStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlCallbackStatus_Ok():
        sse_encode_i_32(0, serializer);
      case LnUrlCallbackStatus_ErrorStatus(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_info(LnUrlInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.lnAddress, serializer);
    sse_encode_opt_String(self.lnurlPayComment, serializer);
    sse_encode_opt_String(self.lnurlPayDomain, serializer);
    sse_encode_opt_String(self.lnurlPayMetadata, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.lnurlPaySuccessAction, serializer);
    sse_encode_opt_box_autoadd_success_action(self.lnurlPayUnprocessedSuccessAction, serializer);
    sse_encode_opt_String(self.lnurlWithdrawEndpoint, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_error(LnUrlPayError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlPayError_AlreadyPaid():
        sse_encode_i_32(0, serializer);
      case LnUrlPayError_Generic(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InsufficientBalance(err: final err):
        sse_encode_i_32(2, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidAmount(err: final err):
        sse_encode_i_32(3, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidInvoice(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidNetwork(err: final err):
        sse_encode_i_32(5, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidUri(err: final err):
        sse_encode_i_32(6, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvoiceExpired(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_PaymentFailed(err: final err):
        sse_encode_i_32(8, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_PaymentTimeout(err: final err):
        sse_encode_i_32(9, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_RouteNotFound(err: final err):
        sse_encode_i_32(10, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_RouteTooExpensive(err: final err):
        sse_encode_i_32(11, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_ServiceConnectivity(err: final err):
        sse_encode_i_32(12, serializer);
        sse_encode_String(err, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_ln_url_pay_response(self.prepareResponse, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_u_64(self.minSendable, serializer);
    sse_encode_u_64(self.maxSendable, serializer);
    sse_encode_String(self.metadataStr, serializer);
    sse_encode_u_16(self.commentAllowed, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_bool(self.allowsNostr, serializer);
    sse_encode_opt_String(self.nostrPubkey, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_result(LnUrlPayResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlPayResult_EndpointSuccess(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_pay_success_data(data, serializer);
      case LnUrlPayResult_EndpointError(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      case LnUrlPayResult_PayError(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_pay_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.successAction, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_error(LnUrlWithdrawError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawError_Generic(err: final err):
        sse_encode_i_32(0, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidAmount(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidInvoice(err: final err):
        sse_encode_i_32(2, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidUri(err: final err):
        sse_encode_i_32(3, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvoiceNoRoutingHints(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_ServiceConnectivity(err: final err):
        sse_encode_i_32(5, serializer);
        sse_encode_String(err, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request_data(LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_String(self.k1, serializer);
    sse_encode_String(self.defaultDescription, serializer);
    sse_encode_u_64(self.minWithdrawable, serializer);
    sse_encode_u_64(self.maxWithdrawable, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_result(LnUrlWithdrawResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawResult_Ok(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_Timeout(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_ErrorStatus(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_success_data(LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.invoice, serializer);
  }

  @protected
  void sse_encode_locale_overrides(LocaleOverrides self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_symbol(self.symbol, serializer);
  }

  @protected
  void sse_encode_localized_name(LocalizedName self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.level, serializer);
  }

  @protected
  void sse_encode_message_success_action_data(MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_onchain_payment_limits_response(
    OnchainPaymentLimitsResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_limits(self.send, serializer);
    sse_encode_limits(self.receive, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_amount(Amount? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_amount(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_asset_info(AssetInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_asset_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_list_payment_details(ListPaymentDetails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_list_payment_details(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ln_url_info(LnUrlInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ln_url_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_pay_amount(PayAmount? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_pay_amount(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment(Payment? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_receive_amount(ReceiveAmount? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_receive_amount(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_success_action(SuccessAction? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_success_action(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_success_action_processed(
    SuccessActionProcessed? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_success_action_processed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_symbol(Symbol? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_symbol(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_asset_metadata(List<AssetMetadata>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_asset_metadata(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_external_input_parser(List<ExternalInputParser>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_external_input_parser(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_payment_state(List<PaymentState>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_payment_state(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_payment_type(List<PaymentType>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_payment_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_pay_amount(PayAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PayAmount_Bitcoin(receiverAmountSat: final receiverAmountSat):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(receiverAmountSat, serializer);
      case PayAmount_Asset(
        toAsset: final toAsset,
        receiverAmount: final receiverAmount,
        estimateAssetFees: final estimateAssetFees,
        fromAsset: final fromAsset,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(toAsset, serializer);
        sse_encode_f_64(receiverAmount, serializer);
        sse_encode_opt_box_autoadd_bool(estimateAssetFees, serializer);
        sse_encode_opt_String(fromAsset, serializer);
      case PayAmount_Drain():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_prepare_pay_onchain_response(self.prepareResponse, serializer);
  }

  @protected
  void sse_encode_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.destination, serializer);
    sse_encode_opt_String(self.txId, serializer);
    sse_encode_opt_String(self.unblindingData, serializer);
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.swapperFeesSat, serializer);
    sse_encode_payment_type(self.paymentType, serializer);
    sse_encode_payment_state(self.status, serializer);
    sse_encode_payment_details(self.details, serializer);
  }

  @protected
  void sse_encode_payment_details(PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentDetails_Lightning(
        swapId: final swapId,
        description: final description,
        liquidExpirationBlockheight: final liquidExpirationBlockheight,
        preimage: final preimage,
        invoice: final invoice,
        bolt12Offer: final bolt12Offer,
        paymentHash: final paymentHash,
        destinationPubkey: final destinationPubkey,
        lnurlInfo: final lnurlInfo,
        bip353Address: final bip353Address,
        payerNote: final payerNote,
        claimTxId: final claimTxId,
        refundTxId: final refundTxId,
        refundTxAmountSat: final refundTxAmountSat,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(swapId, serializer);
        sse_encode_String(description, serializer);
        sse_encode_u_32(liquidExpirationBlockheight, serializer);
        sse_encode_opt_String(preimage, serializer);
        sse_encode_opt_String(invoice, serializer);
        sse_encode_opt_String(bolt12Offer, serializer);
        sse_encode_opt_String(paymentHash, serializer);
        sse_encode_opt_String(destinationPubkey, serializer);
        sse_encode_opt_box_autoadd_ln_url_info(lnurlInfo, serializer);
        sse_encode_opt_String(bip353Address, serializer);
        sse_encode_opt_String(payerNote, serializer);
        sse_encode_opt_String(claimTxId, serializer);
        sse_encode_opt_String(refundTxId, serializer);
        sse_encode_opt_box_autoadd_u_64(refundTxAmountSat, serializer);
      case PaymentDetails_Liquid(
        destination: final destination,
        description: final description,
        assetId: final assetId,
        assetInfo: final assetInfo,
        lnurlInfo: final lnurlInfo,
        bip353Address: final bip353Address,
        payerNote: final payerNote,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(destination, serializer);
        sse_encode_String(description, serializer);
        sse_encode_String(assetId, serializer);
        sse_encode_opt_box_autoadd_asset_info(assetInfo, serializer);
        sse_encode_opt_box_autoadd_ln_url_info(lnurlInfo, serializer);
        sse_encode_opt_String(bip353Address, serializer);
        sse_encode_opt_String(payerNote, serializer);
      case PaymentDetails_Bitcoin(
        swapId: final swapId,
        bitcoinAddress: final bitcoinAddress,
        description: final description,
        autoAcceptedFees: final autoAcceptedFees,
        liquidExpirationBlockheight: final liquidExpirationBlockheight,
        bitcoinExpirationBlockheight: final bitcoinExpirationBlockheight,
        lockupTxId: final lockupTxId,
        claimTxId: final claimTxId,
        refundTxId: final refundTxId,
        refundTxAmountSat: final refundTxAmountSat,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_String(swapId, serializer);
        sse_encode_String(bitcoinAddress, serializer);
        sse_encode_String(description, serializer);
        sse_encode_bool(autoAcceptedFees, serializer);
        sse_encode_u_32(liquidExpirationBlockheight, serializer);
        sse_encode_u_32(bitcoinExpirationBlockheight, serializer);
        sse_encode_opt_String(lockupTxId, serializer);
        sse_encode_opt_String(claimTxId, serializer);
        sse_encode_opt_String(refundTxId, serializer);
        sse_encode_opt_box_autoadd_u_64(refundTxAmountSat, serializer);
    }
  }

  @protected
  void sse_encode_payment_error(PaymentError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentError_AlreadyClaimed():
        sse_encode_i_32(0, serializer);
      case PaymentError_AlreadyPaid():
        sse_encode_i_32(1, serializer);
      case PaymentError_PaymentInProgress():
        sse_encode_i_32(2, serializer);
      case PaymentError_AmountOutOfRange(min: final min, max: final max):
        sse_encode_i_32(3, serializer);
        sse_encode_u_64(min, serializer);
        sse_encode_u_64(max, serializer);
      case PaymentError_AmountMissing(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_AssetError(err: final err):
        sse_encode_i_32(5, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidNetwork(err: final err):
        sse_encode_i_32(6, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_Generic(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidOrExpiredFees():
        sse_encode_i_32(8, serializer);
      case PaymentError_InsufficientFunds():
        sse_encode_i_32(9, serializer);
      case PaymentError_InvalidDescription(err: final err):
        sse_encode_i_32(10, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidInvoice(err: final err):
        sse_encode_i_32(11, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidPreimage():
        sse_encode_i_32(12, serializer);
      case PaymentError_PairsNotFound():
        sse_encode_i_32(13, serializer);
      case PaymentError_PaymentTimeout():
        sse_encode_i_32(14, serializer);
      case PaymentError_PersistError():
        sse_encode_i_32(15, serializer);
      case PaymentError_ReceiveError(err: final err):
        sse_encode_i_32(16, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_Refunded(err: final err, refundTxId: final refundTxId):
        sse_encode_i_32(17, serializer);
        sse_encode_String(err, serializer);
        sse_encode_String(refundTxId, serializer);
      case PaymentError_SelfTransferNotSupported():
        sse_encode_i_32(18, serializer);
      case PaymentError_SendError(err: final err):
        sse_encode_i_32(19, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_SignerError(err: final err):
        sse_encode_i_32(20, serializer);
        sse_encode_String(err, serializer);
    }
  }

  @protected
  void sse_encode_payment_method(PaymentMethod self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_state(PaymentState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type(PaymentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_prepare_buy_bitcoin_request(PrepareBuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_provider(self.provider, serializer);
    sse_encode_u_64(self.amountSat, serializer);
  }

  @protected
  void sse_encode_prepare_buy_bitcoin_response(PrepareBuyBitcoinResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_provider(self.provider, serializer);
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
  }

  @protected
  void sse_encode_prepare_ln_url_pay_request(PrepareLnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self.data, serializer);
    sse_encode_pay_amount(self.amount, serializer);
    sse_encode_opt_String(self.bip353Address, serializer);
    sse_encode_opt_String(self.comment, serializer);
    sse_encode_opt_box_autoadd_bool(self.validateSuccessActionUrl, serializer);
  }

  @protected
  void sse_encode_prepare_ln_url_pay_response(PrepareLnUrlPayResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_destination(self.destination, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_ln_url_pay_request_data(self.data, serializer);
    sse_encode_pay_amount(self.amount, serializer);
    sse_encode_opt_String(self.comment, serializer);
    sse_encode_opt_box_autoadd_success_action(self.successAction, serializer);
  }

  @protected
  void sse_encode_prepare_pay_onchain_request(PreparePayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pay_amount(self.amount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.feeRateSatPerVbyte, serializer);
  }

  @protected
  void sse_encode_prepare_pay_onchain_response(PreparePayOnchainResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.receiverAmountSat, serializer);
    sse_encode_u_64(self.claimFeesSat, serializer);
    sse_encode_u_64(self.totalFeesSat, serializer);
  }

  @protected
  void sse_encode_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_method(self.paymentMethod, serializer);
    sse_encode_opt_box_autoadd_receive_amount(self.amount, serializer);
  }

  @protected
  void sse_encode_prepare_receive_response(PrepareReceiveResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_method(self.paymentMethod, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_opt_box_autoadd_receive_amount(self.amount, serializer);
    sse_encode_opt_box_autoadd_u_64(self.minPayerAmountSat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.maxPayerAmountSat, serializer);
    sse_encode_opt_box_autoadd_f_64(self.swapperFeerate, serializer);
  }

  @protected
  void sse_encode_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.refundAddress, serializer);
    sse_encode_u_32(self.feeRateSatPerVbyte, serializer);
  }

  @protected
  void sse_encode_prepare_refund_response(PrepareRefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.txVsize, serializer);
    sse_encode_u_64(self.txFeeSat, serializer);
    sse_encode_opt_String(self.lastRefundTxId, serializer);
  }

  @protected
  void sse_encode_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.destination, serializer);
    sse_encode_opt_box_autoadd_pay_amount(self.amount, serializer);
  }

  @protected
  void sse_encode_prepare_send_response(PrepareSendResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_destination(self.destination, serializer);
    sse_encode_opt_box_autoadd_pay_amount(self.amount, serializer);
    sse_encode_opt_box_autoadd_u_64(self.feesSat, serializer);
    sse_encode_opt_box_autoadd_f_64(self.estimatedAssetFees, serializer);
    sse_encode_opt_box_autoadd_u_64(self.exchangeAmountSat, serializer);
  }

  @protected
  void sse_encode_rate(Rate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.coin, serializer);
    sse_encode_f_64(self.value, serializer);
  }

  @protected
  void sse_encode_receive_amount(ReceiveAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ReceiveAmount_Bitcoin(payerAmountSat: final payerAmountSat):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(payerAmountSat, serializer);
      case ReceiveAmount_Asset(assetId: final assetId, payerAmount: final payerAmount):
        sse_encode_i_32(1, serializer);
        sse_encode_String(assetId, serializer);
        sse_encode_opt_box_autoadd_f_64(payerAmount, serializer);
    }
  }

  @protected
  void sse_encode_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_response(self.prepareResponse, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_box_autoadd_bool(self.useDescriptionHash, serializer);
    sse_encode_opt_String(self.payerNote, serializer);
  }

  @protected
  void sse_encode_receive_payment_response(ReceivePaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.destination, serializer);
    sse_encode_opt_box_autoadd_u_32(self.liquidExpirationBlockheight, serializer);
    sse_encode_opt_box_autoadd_u_32(self.bitcoinExpirationBlockheight, serializer);
  }

  @protected
  void sse_encode_recommended_fees(RecommendedFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.fastestFee, serializer);
    sse_encode_u_64(self.halfHourFee, serializer);
    sse_encode_u_64(self.hourFee, serializer);
    sse_encode_u_64(self.economyFee, serializer);
    sse_encode_u_64(self.minimumFee, serializer);
  }

  @protected
  void sse_encode_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.refundAddress, serializer);
    sse_encode_u_32(self.feeRateSatPerVbyte, serializer);
  }

  @protected
  void sse_encode_refund_response(RefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.refundTxId, serializer);
  }

  @protected
  void sse_encode_refundable_swap(RefundableSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.lastRefundTxId, serializer);
  }

  @protected
  void sse_encode_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_route_hint(RouteHint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_route_hint_hop(self.hops, serializer);
  }

  @protected
  void sse_encode_route_hint_hop(RouteHintHop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcNodeId, serializer);
    sse_encode_String(self.shortChannelId, serializer);
    sse_encode_u_32(self.feesBaseMsat, serializer);
    sse_encode_u_32(self.feesProportionalMillionths, serializer);
    sse_encode_u_64(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMaximumMsat, serializer);
  }

  @protected
  void sse_encode_sdk_error(SdkError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SdkError_AlreadyStarted():
        sse_encode_i_32(0, serializer);
      case SdkError_Generic(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case SdkError_NotStarted():
        sse_encode_i_32(2, serializer);
      case SdkError_ServiceConnectivity(err: final err):
        sse_encode_i_32(3, serializer);
        sse_encode_String(err, serializer);
    }
  }

  @protected
  void sse_encode_sdk_event(SdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SdkEvent_PaymentFailed(details: final details):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentPending(details: final details):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentRefundable(details: final details):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentRefunded(details: final details):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentRefundPending(details: final details):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentSucceeded(details: final details):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentWaitingConfirmation(details: final details):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_PaymentWaitingFeeAcceptance(details: final details):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case SdkEvent_Synced():
        sse_encode_i_32(8, serializer);
      case SdkEvent_DataSynced(didPullNewRecords: final didPullNewRecords):
        sse_encode_i_32(9, serializer);
        sse_encode_bool(didPullNewRecords, serializer);
    }
  }

  @protected
  void sse_encode_send_destination(SendDestination self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SendDestination_LiquidAddress(addressData: final addressData, bip353Address: final bip353Address):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_liquid_address_data(addressData, serializer);
        sse_encode_opt_String(bip353Address, serializer);
      case SendDestination_Bolt11(invoice: final invoice, bip353Address: final bip353Address):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_invoice(invoice, serializer);
        sse_encode_opt_String(bip353Address, serializer);
      case SendDestination_Bolt12(
        offer: final offer,
        receiverAmountSat: final receiverAmountSat,
        bip353Address: final bip353Address,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_offer(offer, serializer);
        sse_encode_u_64(receiverAmountSat, serializer);
        sse_encode_opt_String(bip353Address, serializer);
    }
  }

  @protected
  void sse_encode_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_response(self.prepareResponse, serializer);
    sse_encode_opt_box_autoadd_bool(self.useAssetFees, serializer);
    sse_encode_opt_String(self.payerNote, serializer);
  }

  @protected
  void sse_encode_send_payment_response(SendPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_sign_message_response(SignMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_success_action(SuccessAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SuccessAction_Aes(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data(data, serializer);
      case SuccessAction_Message(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_message_success_action_data(data, serializer);
      case SuccessAction_Url(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_url_success_action_data(data, serializer);
    }
  }

  @protected
  void sse_encode_success_action_processed(SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SuccessActionProcessed_Aes(result: final result):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_result(result, serializer);
      case SuccessActionProcessed_Message(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_message_success_action_data(data, serializer);
      case SuccessActionProcessed_Url(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_url_success_action_data(data, serializer);
    }
  }

  @protected
  void sse_encode_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.grapheme, serializer);
    sse_encode_opt_String(self.template, serializer);
    sse_encode_opt_box_autoadd_bool(self.rtl, serializer);
    sse_encode_opt_box_autoadd_u_32(self.position, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_bool(self.matchesCallbackDomain, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wallet_info(WalletInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.balanceSat, serializer);
    sse_encode_u_64(self.pendingSendSat, serializer);
    sse_encode_u_64(self.pendingReceiveSat, serializer);
    sse_encode_String(self.fingerprint, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_list_asset_balance(self.assetBalances, serializer);
  }
}

@sealed
class BindingLiquidSdkImpl extends RustOpaque implements BindingLiquidSdk {
  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdkPtr,
  );

  Future<void> acceptPaymentProposedFees({required AcceptPaymentProposedFeesRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkAcceptPaymentProposedFees(that: this, req: req);

  Stream<SdkEvent> addEventListener() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkAddEventListener(that: this);

  void backup({required BackupRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkBackup(that: this, req: req);

  Future<String> buyBitcoin({required BuyBitcoinRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkBuyBitcoin(that: this, req: req);

  CheckMessageResponse checkMessage({required CheckMessageRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkCheckMessage(that: this, req: req);

  Future<CreateBolt12InvoiceResponse> createBolt12Invoice({required CreateBolt12InvoiceRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkCreateBolt12Invoice(that: this, req: req);

  Future<void> disconnect() => RustLib.instance.api.crateBindingsBindingLiquidSdkDisconnect(that: this);

  void emptyWalletCache() => RustLib.instance.api.crateBindingsBindingLiquidSdkEmptyWalletCache(that: this);

  Future<List<Rate>> fetchFiatRates() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkFetchFiatRates(that: this);

  Future<LightningPaymentLimitsResponse> fetchLightningLimits() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkFetchLightningLimits(that: this);

  Future<OnchainPaymentLimitsResponse> fetchOnchainLimits() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkFetchOnchainLimits(that: this);

  Future<FetchPaymentProposedFeesResponse> fetchPaymentProposedFees({
    required FetchPaymentProposedFeesRequest req,
  }) => RustLib.instance.api.crateBindingsBindingLiquidSdkFetchPaymentProposedFees(that: this, req: req);

  Future<GetInfoResponse> getInfo() => RustLib.instance.api.crateBindingsBindingLiquidSdkGetInfo(that: this);

  Future<Payment?> getPayment({required GetPaymentRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkGetPayment(that: this, req: req);

  Future<List<FiatCurrency>> listFiatCurrencies() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkListFiatCurrencies(that: this);

  Future<List<Payment>> listPayments({required ListPaymentsRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkListPayments(that: this, req: req);

  Future<List<RefundableSwap>> listRefundables() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkListRefundables(that: this);

  Future<LnUrlCallbackStatus> lnurlAuth({required LnUrlAuthRequestData reqData}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkLnurlAuth(that: this, reqData: reqData);

  Future<LnUrlPayResult> lnurlPay({required LnUrlPayRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkLnurlPay(that: this, req: req);

  Future<LnUrlWithdrawResult> lnurlWithdraw({required LnUrlWithdrawRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkLnurlWithdraw(that: this, req: req);

  Future<InputType> parse({required String input}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkParse(that: this, input: input);

  Future<SendPaymentResponse> payOnchain({required PayOnchainRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPayOnchain(that: this, req: req);

  Future<PrepareBuyBitcoinResponse> prepareBuyBitcoin({required PrepareBuyBitcoinRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareBuyBitcoin(that: this, req: req);

  Future<PrepareLnUrlPayResponse> prepareLnurlPay({required PrepareLnUrlPayRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareLnurlPay(that: this, req: req);

  Future<PreparePayOnchainResponse> preparePayOnchain({required PreparePayOnchainRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPreparePayOnchain(that: this, req: req);

  Future<PrepareReceiveResponse> prepareReceivePayment({required PrepareReceiveRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareReceivePayment(that: this, req: req);

  Future<PrepareRefundResponse> prepareRefund({required PrepareRefundRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareRefund(that: this, req: req);

  Future<PrepareSendResponse> prepareSendPayment({required PrepareSendRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareSendPayment(that: this, req: req);

  Future<ReceivePaymentResponse> receivePayment({required ReceivePaymentRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkReceivePayment(that: this, req: req);

  Future<RecommendedFees> recommendedFees() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRecommendedFees(that: this);

  Future<RefundResponse> refund({required RefundRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRefund(that: this, req: req);

  Future<void> registerWebhook({required String webhookUrl}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRegisterWebhook(that: this, webhookUrl: webhookUrl);

  Future<void> rescanOnchainSwaps() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRescanOnchainSwaps(that: this);

  void restore({required RestoreRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRestore(that: this, req: req);

  Future<SendPaymentResponse> sendPayment({required SendPaymentRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkSendPayment(that: this, req: req);

  SignMessageResponse signMessage({required SignMessageRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkSignMessage(that: this, req: req);

  Future<void> sync() => RustLib.instance.api.crateBindingsBindingLiquidSdkSync(that: this);

  Future<void> unregisterWebhook() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkUnregisterWebhook(that: this);
}
