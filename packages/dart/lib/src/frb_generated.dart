// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'bindings.dart';
import 'dart:async';
import 'dart:convert';
import 'error.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'model.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.38';

  @override
  int get rustContentHash => 308302012;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'breez_liquid_sdk',
    ioDirectory: '../../lib/core/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Stream<LiquidSdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req});

  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that});

  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that});

  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({required BindingLiquidSdk that});

  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveRequest req});

  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment(
      {required BindingLiquidSdk that, required PrepareSendRequest req});

  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveResponse req});

  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req});

  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment(
      {required BindingLiquidSdk that, required PrepareSendResponse req});

  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that});

  Future<void> crateBindingsBindingEventListenerOnEvent(
      {required BindingEventListener that, required LiquidSdkEvent e});

  Stream<LogEntry> crateBindingsBreezLogStream();

  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req});

  Config crateBindingsDefaultConfig({required Network network});

  LNInvoice crateBindingsParseInvoice({required String input});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BindingLiquidSdkPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Stream<LiquidSdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that}) {
    final listener = RustStreamSink<LiquidSdkEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_StreamSink_liquid_sdk_event_Dco(listener);
        return wire.wire__crate__bindings__BindingLiquidSdk_add_event_listener(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta,
      argValues: [that, listener],
      apiImpl: this,
    )));
    return listener.stream;
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_add_event_listener",
        argNames: ["that", "listener"],
      );

  @override
  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_backup_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_backup(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkBackupConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkBackupConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_backup",
        argNames: ["that", "req"],
      );

  @override
  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_disconnect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkDisconnectConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkDisconnectConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_disconnect",
        argNames: ["that"],
      );

  @override
  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_empty_wallet_cache(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_empty_wallet_cache",
        argNames: ["that"],
      );

  @override
  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_get_info(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_get_info_response,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkGetInfoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkGetInfoConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_get_info",
        argNames: ["that"],
      );

  @override
  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkListPaymentsConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_list_payments",
        argNames: ["that"],
      );

  @override
  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_receive_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_prepare_receive_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_receive_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_prepare_receive_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment(
      {required BindingLiquidSdk that, required PrepareSendRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_send_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_prepare_send_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_send_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_prepare_send_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveResponse req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_receive_response(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_receive_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_receive_payment_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_receive_payment",
        argNames: ["that", "req"],
      );

  @override
  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_restore_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_restore(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkRestoreConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRestoreConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_restore",
        argNames: ["that", "req"],
      );

  @override
  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment(
      {required BindingLiquidSdk that, required PrepareSendResponse req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_send_response(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_send_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_send_payment_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkSendPaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSendPaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_send_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_sync(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSyncConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_sync",
        argNames: ["that"],
      );

  @override
  Future<void> crateBindingsBindingEventListenerOnEvent(
      {required BindingEventListener that, required LiquidSdkEvent e}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_binding_event_listener(that);
        var arg1 = cst_encode_box_autoadd_liquid_sdk_event(e);
        return wire.wire__crate__bindings__binding_event_listener_on_event(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingsBindingEventListenerOnEventConstMeta,
      argValues: [that, e],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingEventListenerOnEventConstMeta => const TaskConstMeta(
        debugName: "binding_event_listener_on_event",
        argNames: ["that", "e"],
      );

  @override
  Stream<LogEntry> crateBindingsBreezLogStream() {
    final s = RustStreamSink<LogEntry>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_log_entry_Dco(s);
        return wire.wire__crate__bindings__breez_log_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingsBreezLogStreamConstMeta,
      argValues: [s],
      apiImpl: this,
    )));
    return s.stream;
  }

  TaskConstMeta get kCrateBindingsBreezLogStreamConstMeta => const TaskConstMeta(
        debugName: "breez_log_stream",
        argNames: ["s"],
      );

  @override
  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_connect_request(req);
        return wire.wire__crate__bindings__connect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsConnectConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsConnectConstMeta => const TaskConstMeta(
        debugName: "connect",
        argNames: ["req"],
      );

  @override
  Config crateBindingsDefaultConfig({required Network network}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_network(network);
        return wire.wire__crate__bindings__default_config(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingsDefaultConfigConstMeta,
      argValues: [network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsDefaultConfigConstMeta => const TaskConstMeta(
        debugName: "default_config",
        argNames: ["network"],
      );

  @override
  LNInvoice crateBindingsParseInvoice({required String input}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(input);
        return wire.wire__crate__bindings__parse_invoice(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_invoice,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsParseInvoiceConstMeta,
      argValues: [input],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsParseInvoiceConstMeta => const TaskConstMeta(
        debugName: "parse_invoice",
        argNames: ["input"],
      );

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  BindingLiquidSdk
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<LiquidSdkEvent> dco_decode_StreamSink_liquid_sdk_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  BackupRequest dco_decode_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BackupRequest(
      backupPath: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  BindingEventListener dco_decode_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BindingEventListener(
      stream: dco_decode_StreamSink_liquid_sdk_event_Dco(arr[0]),
    );
  }

  @protected
  BackupRequest dco_decode_box_autoadd_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_backup_request(raw);
  }

  @protected
  BindingEventListener dco_decode_box_autoadd_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_binding_event_listener(raw);
  }

  @protected
  ConnectRequest dco_decode_box_autoadd_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connect_request(raw);
  }

  @protected
  LiquidSdkEvent dco_decode_box_autoadd_liquid_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquid_sdk_event(raw);
  }

  @protected
  Payment dco_decode_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment(raw);
  }

  @protected
  PrepareReceiveRequest dco_decode_box_autoadd_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_receive_request(raw);
  }

  @protected
  PrepareReceiveResponse dco_decode_box_autoadd_prepare_receive_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_receive_response(raw);
  }

  @protected
  PrepareSendRequest dco_decode_box_autoadd_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_send_request(raw);
  }

  @protected
  PrepareSendResponse dco_decode_box_autoadd_prepare_send_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_send_response(raw);
  }

  @protected
  RestoreRequest dco_decode_box_autoadd_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_restore_request(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Config(
      boltzUrl: dco_decode_String(arr[0]),
      electrumUrl: dco_decode_String(arr[1]),
      workingDir: dco_decode_String(arr[2]),
      network: dco_decode_network(arr[3]),
      paymentTimeoutSec: dco_decode_u_64(arr[4]),
      zeroConfMinFeeRate: dco_decode_f_32(arr[5]),
      zeroConfMaxAmountSat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  ConnectRequest dco_decode_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ConnectRequest(
      mnemonic: dco_decode_String(arr[0]),
      config: dco_decode_config(arr[1]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetInfoResponse dco_decode_get_info_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GetInfoResponse(
      balanceSat: dco_decode_u_64(arr[0]),
      pendingSendSat: dco_decode_u_64(arr[1]),
      pendingReceiveSat: dco_decode_u_64(arr[2]),
      pubkey: dco_decode_String(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LiquidSdkError dco_decode_liquid_sdk_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LiquidSdkError_AlreadyStarted();
      case 1:
        return LiquidSdkError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 2:
        return LiquidSdkError_NotStarted();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquidSdkEvent dco_decode_liquid_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LiquidSdkEvent_PaymentFailed(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 1:
        return LiquidSdkEvent_PaymentPending(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 2:
        return LiquidSdkEvent_PaymentRefunded(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 3:
        return LiquidSdkEvent_PaymentRefundPending(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 4:
        return LiquidSdkEvent_PaymentSucceeded(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 5:
        return LiquidSdkEvent_PaymentWaitingConfirmation(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 6:
        return LiquidSdkEvent_Synced();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<Payment> dco_decode_list_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<RouteHint> dco_decode_list_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint).toList();
  }

  @protected
  List<RouteHintHop> dco_decode_list_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint_hop).toList();
  }

  @protected
  LNInvoice dco_decode_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LNInvoice(
      bolt11: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      payeePubkey: dco_decode_String(arr[2]),
      paymentHash: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      descriptionHash: dco_decode_opt_String(arr[5]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      expiry: dco_decode_u_64(arr[8]),
      routingHints: dco_decode_list_route_hint(arr[9]),
      paymentSecret: dco_decode_list_prim_u_8_strict(arr[10]),
      minFinalCltvExpiryDelta: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LogEntry(
      line: dco_decode_String(arr[0]),
      level: dco_decode_String(arr[1]),
    );
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Payment dco_decode_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Payment(
      txId: dco_decode_opt_String(arr[0]),
      swapId: dco_decode_opt_String(arr[1]),
      timestamp: dco_decode_u_32(arr[2]),
      amountSat: dco_decode_u_64(arr[3]),
      feesSat: dco_decode_u_64(arr[4]),
      preimage: dco_decode_opt_String(arr[5]),
      bolt11: dco_decode_opt_String(arr[6]),
      refundTxId: dco_decode_opt_String(arr[7]),
      refundTxAmountSat: dco_decode_opt_box_autoadd_u_64(arr[8]),
      paymentType: dco_decode_payment_type(arr[9]),
      status: dco_decode_payment_state(arr[10]),
    );
  }

  @protected
  PaymentError dco_decode_payment_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        return PaymentError_AmountOutOfRange();
      case 4:
        return PaymentError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 5:
        return PaymentError_InvalidOrExpiredFees();
      case 6:
        return PaymentError_InsufficientFunds();
      case 7:
        return PaymentError_InvalidInvoice(
          err: dco_decode_String(raw[1]),
        );
      case 8:
        return PaymentError_InvalidPreimage();
      case 9:
        return PaymentError_LwkError(
          err: dco_decode_String(raw[1]),
        );
      case 10:
        return PaymentError_PairsNotFound();
      case 11:
        return PaymentError_PaymentTimeout();
      case 12:
        return PaymentError_PersistError();
      case 13:
        return PaymentError_ReceiveError(
          err: dco_decode_String(raw[1]),
        );
      case 14:
        return PaymentError_Refunded(
          err: dco_decode_String(raw[1]),
          refundTxId: dco_decode_String(raw[2]),
        );
      case 15:
        return PaymentError_SelfTransferNotSupported();
      case 16:
        return PaymentError_SendError(
          err: dco_decode_String(raw[1]),
        );
      case 17:
        return PaymentError_SignerError(
          err: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentState dco_decode_payment_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentState.values[raw as int];
  }

  @protected
  PaymentType dco_decode_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentType.values[raw as int];
  }

  @protected
  PrepareReceiveRequest dco_decode_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PrepareReceiveRequest(
      payerAmountSat: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  PrepareReceiveResponse dco_decode_prepare_receive_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareReceiveResponse(
      payerAmountSat: dco_decode_u_64(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PrepareSendRequest dco_decode_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PrepareSendRequest(
      invoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  PrepareSendResponse dco_decode_prepare_send_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareSendResponse(
      invoice: dco_decode_String(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  ReceivePaymentResponse dco_decode_receive_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReceivePaymentResponse(
      id: dco_decode_String(arr[0]),
      invoice: dco_decode_String(arr[1]),
    );
  }

  @protected
  RestoreRequest dco_decode_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RestoreRequest(
      backupPath: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  RouteHint dco_decode_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RouteHint(
      hops: dco_decode_list_route_hint_hop(arr[0]),
    );
  }

  @protected
  RouteHintHop dco_decode_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RouteHintHop(
      srcNodeId: dco_decode_String(arr[0]),
      shortChannelId: dco_decode_u_64(arr[1]),
      feesBaseMsat: dco_decode_u_32(arr[2]),
      feesProportionalMillionths: dco_decode_u_32(arr[3]),
      cltvExpiryDelta: dco_decode_u_64(arr[4]),
      htlcMinimumMsat: dco_decode_opt_box_autoadd_u_64(arr[5]),
      htlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  SendPaymentResponse dco_decode_send_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendPaymentResponse(
      payment: dco_decode_payment(arr[0]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  BindingLiquidSdk
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BindingLiquidSdk
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BindingLiquidSdk sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<LiquidSdkEvent> sse_decode_StreamSink_liquid_sdk_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  BackupRequest sse_decode_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return BackupRequest(backupPath: var_backupPath);
  }

  @protected
  BindingEventListener sse_decode_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_stream = sse_decode_StreamSink_liquid_sdk_event_Dco(deserializer);
    return BindingEventListener(stream: var_stream);
  }

  @protected
  BackupRequest sse_decode_box_autoadd_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_backup_request(deserializer));
  }

  @protected
  BindingEventListener sse_decode_box_autoadd_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_binding_event_listener(deserializer));
  }

  @protected
  ConnectRequest sse_decode_box_autoadd_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connect_request(deserializer));
  }

  @protected
  LiquidSdkEvent sse_decode_box_autoadd_liquid_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquid_sdk_event(deserializer));
  }

  @protected
  Payment sse_decode_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment(deserializer));
  }

  @protected
  PrepareReceiveRequest sse_decode_box_autoadd_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_receive_request(deserializer));
  }

  @protected
  PrepareReceiveResponse sse_decode_box_autoadd_prepare_receive_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_receive_response(deserializer));
  }

  @protected
  PrepareSendRequest sse_decode_box_autoadd_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_send_request(deserializer));
  }

  @protected
  PrepareSendResponse sse_decode_box_autoadd_prepare_send_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_send_response(deserializer));
  }

  @protected
  RestoreRequest sse_decode_box_autoadd_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_restore_request(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_workingDir = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_paymentTimeoutSec = sse_decode_u_64(deserializer);
    var var_zeroConfMinFeeRate = sse_decode_f_32(deserializer);
    var var_zeroConfMaxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return Config(
        boltzUrl: var_boltzUrl,
        electrumUrl: var_electrumUrl,
        workingDir: var_workingDir,
        network: var_network,
        paymentTimeoutSec: var_paymentTimeoutSec,
        zeroConfMinFeeRate: var_zeroConfMinFeeRate,
        zeroConfMaxAmountSat: var_zeroConfMaxAmountSat);
  }

  @protected
  ConnectRequest sse_decode_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mnemonic = sse_decode_String(deserializer);
    var var_config = sse_decode_config(deserializer);
    return ConnectRequest(mnemonic: var_mnemonic, config: var_config);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  GetInfoResponse sse_decode_get_info_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_balanceSat = sse_decode_u_64(deserializer);
    var var_pendingSendSat = sse_decode_u_64(deserializer);
    var var_pendingReceiveSat = sse_decode_u_64(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    return GetInfoResponse(
        balanceSat: var_balanceSat,
        pendingSendSat: var_pendingSendSat,
        pendingReceiveSat: var_pendingReceiveSat,
        pubkey: var_pubkey);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LiquidSdkError sse_decode_liquid_sdk_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LiquidSdkError_AlreadyStarted();
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LiquidSdkError_Generic(err: var_err);
      case 2:
        return LiquidSdkError_NotStarted();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquidSdkEvent sse_decode_liquid_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentFailed(details: var_details);
      case 1:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentPending(details: var_details);
      case 2:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentRefunded(details: var_details);
      case 3:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentRefundPending(details: var_details);
      case 4:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentSucceeded(details: var_details);
      case 5:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentWaitingConfirmation(details: var_details);
      case 6:
        return LiquidSdkEvent_Synced();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<Payment> sse_decode_list_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Payment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<RouteHint> sse_decode_list_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHintHop> sse_decode_list_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHintHop>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint_hop(deserializer));
    }
    return ans_;
  }

  @protected
  LNInvoice sse_decode_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_payeePubkey = sse_decode_String(deserializer);
    var var_paymentHash = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionHash = sse_decode_opt_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_routingHints = sse_decode_list_route_hint(deserializer);
    var var_paymentSecret = sse_decode_list_prim_u_8_strict(deserializer);
    var var_minFinalCltvExpiryDelta = sse_decode_u_64(deserializer);
    return LNInvoice(
        bolt11: var_bolt11,
        network: var_network,
        payeePubkey: var_payeePubkey,
        paymentHash: var_paymentHash,
        description: var_description,
        descriptionHash: var_descriptionHash,
        amountMsat: var_amountMsat,
        timestamp: var_timestamp,
        expiry: var_expiry,
        routingHints: var_routingHints,
        paymentSecret: var_paymentSecret,
        minFinalCltvExpiryDelta: var_minFinalCltvExpiryDelta);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_line = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    return LogEntry(line: var_line, level: var_level);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Payment sse_decode_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_opt_String(deserializer);
    var var_swapId = sse_decode_opt_String(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_preimage = sse_decode_opt_String(deserializer);
    var var_bolt11 = sse_decode_opt_String(deserializer);
    var var_refundTxId = sse_decode_opt_String(deserializer);
    var var_refundTxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_paymentType = sse_decode_payment_type(deserializer);
    var var_status = sse_decode_payment_state(deserializer);
    return Payment(
        txId: var_txId,
        swapId: var_swapId,
        timestamp: var_timestamp,
        amountSat: var_amountSat,
        feesSat: var_feesSat,
        preimage: var_preimage,
        bolt11: var_bolt11,
        refundTxId: var_refundTxId,
        refundTxAmountSat: var_refundTxAmountSat,
        paymentType: var_paymentType,
        status: var_status);
  }

  @protected
  PaymentError sse_decode_payment_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        return PaymentError_AmountOutOfRange();
      case 4:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_Generic(err: var_err);
      case 5:
        return PaymentError_InvalidOrExpiredFees();
      case 6:
        return PaymentError_InsufficientFunds();
      case 7:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_InvalidInvoice(err: var_err);
      case 8:
        return PaymentError_InvalidPreimage();
      case 9:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_LwkError(err: var_err);
      case 10:
        return PaymentError_PairsNotFound();
      case 11:
        return PaymentError_PaymentTimeout();
      case 12:
        return PaymentError_PersistError();
      case 13:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_ReceiveError(err: var_err);
      case 14:
        var var_err = sse_decode_String(deserializer);
        var var_refundTxId = sse_decode_String(deserializer);
        return PaymentError_Refunded(err: var_err, refundTxId: var_refundTxId);
      case 15:
        return PaymentError_SelfTransferNotSupported();
      case 16:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SendError(err: var_err);
      case 17:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SignerError(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentState sse_decode_payment_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentState.values[inner];
  }

  @protected
  PaymentType sse_decode_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentType.values[inner];
  }

  @protected
  PrepareReceiveRequest sse_decode_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payerAmountSat = sse_decode_u_64(deserializer);
    return PrepareReceiveRequest(payerAmountSat: var_payerAmountSat);
  }

  @protected
  PrepareReceiveResponse sse_decode_prepare_receive_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payerAmountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    return PrepareReceiveResponse(payerAmountSat: var_payerAmountSat, feesSat: var_feesSat);
  }

  @protected
  PrepareSendRequest sse_decode_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_String(deserializer);
    return PrepareSendRequest(invoice: var_invoice);
  }

  @protected
  PrepareSendResponse sse_decode_prepare_send_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_String(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    return PrepareSendResponse(invoice: var_invoice, feesSat: var_feesSat);
  }

  @protected
  ReceivePaymentResponse sse_decode_receive_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    return ReceivePaymentResponse(id: var_id, invoice: var_invoice);
  }

  @protected
  RestoreRequest sse_decode_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return RestoreRequest(backupPath: var_backupPath);
  }

  @protected
  RouteHint sse_decode_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hops = sse_decode_list_route_hint_hop(deserializer);
    return RouteHint(hops: var_hops);
  }

  @protected
  RouteHintHop sse_decode_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcNodeId = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_u_64(deserializer);
    var var_feesBaseMsat = sse_decode_u_32(deserializer);
    var var_feesProportionalMillionths = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_64(deserializer);
    var var_htlcMinimumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return RouteHintHop(
        srcNodeId: var_srcNodeId,
        shortChannelId: var_shortChannelId,
        feesBaseMsat: var_feesBaseMsat,
        feesProportionalMillionths: var_feesProportionalMillionths,
        cltvExpiryDelta: var_cltvExpiryDelta,
        htlcMinimumMsat: var_htlcMinimumMsat,
        htlcMaximumMsat: var_htlcMaximumMsat);
  }

  @protected
  SendPaymentResponse sse_decode_send_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    return SendPaymentResponse(payment: var_payment);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode();
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_state(PaymentState raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type(PaymentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_StreamSink_liquid_sdk_event_Dco(
      RustStreamSink<LiquidSdkEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(decodeSuccessData: dco_decode_liquid_sdk_event, decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Dco(RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(decodeSuccessData: dco_decode_log_entry, decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_StreamSink_liquid_sdk_event_Dco(self.stream, serializer);
  }

  @protected
  void sse_encode_box_autoadd_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_backup_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_binding_event_listener(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connect_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquid_sdk_event(LiquidSdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquid_sdk_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_receive_response(
      PrepareReceiveResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_response(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_send_response(PrepareSendResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_response(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_restore_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.workingDir, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_u_64(self.paymentTimeoutSec, serializer);
    sse_encode_f_32(self.zeroConfMinFeeRate, serializer);
    sse_encode_opt_box_autoadd_u_64(self.zeroConfMaxAmountSat, serializer);
  }

  @protected
  void sse_encode_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.mnemonic, serializer);
    sse_encode_config(self.config, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_get_info_response(GetInfoResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.balanceSat, serializer);
    sse_encode_u_64(self.pendingSendSat, serializer);
    sse_encode_u_64(self.pendingReceiveSat, serializer);
    sse_encode_String(self.pubkey, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_liquid_sdk_error(LiquidSdkError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LiquidSdkError_AlreadyStarted():
        sse_encode_i_32(0, serializer);
      case LiquidSdkError_Generic(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LiquidSdkError_NotStarted():
        sse_encode_i_32(2, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquid_sdk_event(LiquidSdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LiquidSdkEvent_PaymentFailed(details: final details):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentPending(details: final details):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentRefunded(details: final details):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentRefundPending(details: final details):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentSucceeded(details: final details):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentWaitingConfirmation(details: final details):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_Synced():
        sse_encode_i_32(6, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_list_payment(List<Payment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_route_hint(List<RouteHint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint_hop(List<RouteHintHop> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint_hop(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.payeePubkey, serializer);
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_list_route_hint(self.routingHints, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentSecret, serializer);
    sse_encode_u_64(self.minFinalCltvExpiryDelta, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.level, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.txId, serializer);
    sse_encode_opt_String(self.swapId, serializer);
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_opt_String(self.preimage, serializer);
    sse_encode_opt_String(self.bolt11, serializer);
    sse_encode_opt_String(self.refundTxId, serializer);
    sse_encode_opt_box_autoadd_u_64(self.refundTxAmountSat, serializer);
    sse_encode_payment_type(self.paymentType, serializer);
    sse_encode_payment_state(self.status, serializer);
  }

  @protected
  void sse_encode_payment_error(PaymentError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentError_AlreadyClaimed():
        sse_encode_i_32(0, serializer);
      case PaymentError_AlreadyPaid():
        sse_encode_i_32(1, serializer);
      case PaymentError_PaymentInProgress():
        sse_encode_i_32(2, serializer);
      case PaymentError_AmountOutOfRange():
        sse_encode_i_32(3, serializer);
      case PaymentError_Generic(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidOrExpiredFees():
        sse_encode_i_32(5, serializer);
      case PaymentError_InsufficientFunds():
        sse_encode_i_32(6, serializer);
      case PaymentError_InvalidInvoice(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidPreimage():
        sse_encode_i_32(8, serializer);
      case PaymentError_LwkError(err: final err):
        sse_encode_i_32(9, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_PairsNotFound():
        sse_encode_i_32(10, serializer);
      case PaymentError_PaymentTimeout():
        sse_encode_i_32(11, serializer);
      case PaymentError_PersistError():
        sse_encode_i_32(12, serializer);
      case PaymentError_ReceiveError(err: final err):
        sse_encode_i_32(13, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_Refunded(err: final err, refundTxId: final refundTxId):
        sse_encode_i_32(14, serializer);
        sse_encode_String(err, serializer);
        sse_encode_String(refundTxId, serializer);
      case PaymentError_SelfTransferNotSupported():
        sse_encode_i_32(15, serializer);
      case PaymentError_SendError(err: final err):
        sse_encode_i_32(16, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_SignerError(err: final err):
        sse_encode_i_32(17, serializer);
        sse_encode_String(err, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_payment_state(PaymentState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type(PaymentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.payerAmountSat, serializer);
  }

  @protected
  void sse_encode_prepare_receive_response(PrepareReceiveResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.payerAmountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
  }

  @protected
  void sse_encode_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_prepare_send_response(PrepareSendResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.invoice, serializer);
    sse_encode_u_64(self.feesSat, serializer);
  }

  @protected
  void sse_encode_receive_payment_response(ReceivePaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_route_hint(RouteHint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_route_hint_hop(self.hops, serializer);
  }

  @protected
  void sse_encode_route_hint_hop(RouteHintHop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcNodeId, serializer);
    sse_encode_u_64(self.shortChannelId, serializer);
    sse_encode_u_32(self.feesBaseMsat, serializer);
    sse_encode_u_32(self.feesProportionalMillionths, serializer);
    sse_encode_u_64(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMaximumMsat, serializer);
  }

  @protected
  void sse_encode_send_payment_response(SendPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}

@sealed
class BindingLiquidSdkImpl extends RustOpaque implements BindingLiquidSdk {
  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdkPtr,
  );

  Stream<LiquidSdkEvent> addEventListener() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkAddEventListener(
        that: this,
      );

  void backup({required BackupRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkBackup(that: this, req: req);

  Future<void> disconnect() => RustLib.instance.api.crateBindingsBindingLiquidSdkDisconnect(
        that: this,
      );

  void emptyWalletCache() => RustLib.instance.api.crateBindingsBindingLiquidSdkEmptyWalletCache(
        that: this,
      );

  Future<GetInfoResponse> getInfo() => RustLib.instance.api.crateBindingsBindingLiquidSdkGetInfo(
        that: this,
      );

  Future<List<Payment>> listPayments() => RustLib.instance.api.crateBindingsBindingLiquidSdkListPayments(
        that: this,
      );

  Future<PrepareReceiveResponse> prepareReceivePayment({required PrepareReceiveRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareReceivePayment(that: this, req: req);

  Future<PrepareSendResponse> prepareSendPayment({required PrepareSendRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareSendPayment(that: this, req: req);

  Future<ReceivePaymentResponse> receivePayment({required PrepareReceiveResponse req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkReceivePayment(that: this, req: req);

  void restore({required RestoreRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRestore(that: this, req: req);

  Future<SendPaymentResponse> sendPayment({required PrepareSendResponse req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkSendPayment(that: this, req: req);

  Future<void> sync() => RustLib.instance.api.crateBindingsBindingLiquidSdkSync(
        that: this,
      );
}
