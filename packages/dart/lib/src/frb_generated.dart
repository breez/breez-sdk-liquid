// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'bindings.dart';
import 'bindings/duplicates.dart';
import 'dart:async';
import 'dart:convert';
import 'error.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'lib.dart';
import 'model.dart';
import 'model/lnurl.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.38';

  @override
  int get rustContentHash => -2033859719;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'breez_liquid_sdk',
    ioDirectory: '../../lib/core/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Stream<LiquidSdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req});

  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that});

  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that});

  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that});

  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({required BindingLiquidSdk that});

  Future<WrappedLnUrlPayResult> crateBindingsBindingLiquidSdkLnurlPay(
      {required BindingLiquidSdk that, required LnUrlPayRequest req});

  Future<LnUrlWithdrawResult> crateBindingsBindingLiquidSdkLnurlWithdraw(
      {required BindingLiquidSdk that, required LnUrlWithdrawRequest req});

  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveRequest req});

  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment(
      {required BindingLiquidSdk that, required PrepareSendRequest req});

  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveResponse req});

  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req});

  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment(
      {required BindingLiquidSdk that, required PrepareSendResponse req});

  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that});

  Future<void> crateBindingsBindingEventListenerOnEvent(
      {required BindingEventListener that, required LiquidSdkEvent e});

  Stream<LogEntry> crateBindingsBreezLogStream();

  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req});

  Config crateBindingsDefaultConfig({required LiquidSdkNetwork network});

  Future<InputType> crateBindingsParse({required String input});

  LNInvoice crateBindingsParseInvoice({required String input});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BindingLiquidSdkPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Stream<LiquidSdkEvent> crateBindingsBindingLiquidSdkAddEventListener({required BindingLiquidSdk that}) {
    final listener = RustStreamSink<LiquidSdkEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_StreamSink_liquid_sdk_event_Dco(listener);
        return wire.wire__crate__bindings__BindingLiquidSdk_add_event_listener(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta,
      argValues: [that, listener],
      apiImpl: this,
    )));
    return listener.stream;
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkAddEventListenerConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_add_event_listener",
        argNames: ["that", "listener"],
      );

  @override
  void crateBindingsBindingLiquidSdkBackup({required BindingLiquidSdk that, required BackupRequest req}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_backup_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_backup(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkBackupConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkBackupConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_backup",
        argNames: ["that", "req"],
      );

  @override
  Future<void> crateBindingsBindingLiquidSdkDisconnect({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_disconnect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkDisconnectConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkDisconnectConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_disconnect",
        argNames: ["that"],
      );

  @override
  void crateBindingsBindingLiquidSdkEmptyWalletCache({required BindingLiquidSdk that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_empty_wallet_cache(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkEmptyWalletCacheConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_empty_wallet_cache",
        argNames: ["that"],
      );

  @override
  Future<GetInfoResponse> crateBindingsBindingLiquidSdkGetInfo({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_get_info(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_get_info_response,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkGetInfoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkGetInfoConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_get_info",
        argNames: ["that"],
      );

  @override
  Future<List<Payment>> crateBindingsBindingLiquidSdkListPayments({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkListPaymentsConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_list_payments",
        argNames: ["that"],
      );

  @override
  Future<WrappedLnUrlPayResult> crateBindingsBindingLiquidSdkLnurlPay(
      {required BindingLiquidSdk that, required LnUrlPayRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_ln_url_pay_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_lnurl_pay(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wrapped_ln_url_pay_result,
        decodeErrorData: dco_decode_ln_url_pay_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkLnurlPayConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkLnurlPayConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_lnurl_pay",
        argNames: ["that", "req"],
      );

  @override
  Future<LnUrlWithdrawResult> crateBindingsBindingLiquidSdkLnurlWithdraw(
      {required BindingLiquidSdk that, required LnUrlWithdrawRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_ln_url_withdraw_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_lnurl_withdraw(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_url_withdraw_result,
        decodeErrorData: dco_decode_ln_url_withdraw_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkLnurlWithdrawConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkLnurlWithdrawConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_lnurl_withdraw",
        argNames: ["that", "req"],
      );

  @override
  Future<PrepareReceiveResponse> crateBindingsBindingLiquidSdkPrepareReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_receive_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_prepare_receive_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_receive_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_prepare_receive_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<PrepareSendResponse> crateBindingsBindingLiquidSdkPrepareSendPayment(
      {required BindingLiquidSdk that, required PrepareSendRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_send_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_prepare_send_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_send_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkPrepareSendPaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_prepare_send_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<ReceivePaymentResponse> crateBindingsBindingLiquidSdkReceivePayment(
      {required BindingLiquidSdk that, required PrepareReceiveResponse req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_receive_response(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_receive_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_receive_payment_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_receive_payment",
        argNames: ["that", "req"],
      );

  @override
  void crateBindingsBindingLiquidSdkRestore({required BindingLiquidSdk that, required RestoreRequest req}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_restore_request(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_restore(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkRestoreConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkRestoreConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_restore",
        argNames: ["that", "req"],
      );

  @override
  Future<SendPaymentResponse> crateBindingsBindingLiquidSdkSendPayment(
      {required BindingLiquidSdk that, required PrepareSendResponse req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        var arg1 = cst_encode_box_autoadd_prepare_send_response(req);
        return wire.wire__crate__bindings__BindingLiquidSdk_send_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_send_payment_response,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkSendPaymentConstMeta,
      argValues: [that, req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSendPaymentConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_send_payment",
        argNames: ["that", "req"],
      );

  @override
  Future<void> crateBindingsBindingLiquidSdkSync({required BindingLiquidSdk that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
                that);
        return wire.wire__crate__bindings__BindingLiquidSdk_sync(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsBindingLiquidSdkSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingLiquidSdkSyncConstMeta => const TaskConstMeta(
        debugName: "BindingLiquidSdk_sync",
        argNames: ["that"],
      );

  @override
  Future<void> crateBindingsBindingEventListenerOnEvent(
      {required BindingEventListener that, required LiquidSdkEvent e}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_binding_event_listener(that);
        var arg1 = cst_encode_box_autoadd_liquid_sdk_event(e);
        return wire.wire__crate__bindings__binding_event_listener_on_event(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingsBindingEventListenerOnEventConstMeta,
      argValues: [that, e],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsBindingEventListenerOnEventConstMeta => const TaskConstMeta(
        debugName: "binding_event_listener_on_event",
        argNames: ["that", "e"],
      );

  @override
  Stream<LogEntry> crateBindingsBreezLogStream() {
    final s = RustStreamSink<LogEntry>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_log_entry_Dco(s);
        return wire.wire__crate__bindings__breez_log_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingsBreezLogStreamConstMeta,
      argValues: [s],
      apiImpl: this,
    )));
    return s.stream;
  }

  TaskConstMeta get kCrateBindingsBreezLogStreamConstMeta => const TaskConstMeta(
        debugName: "breez_log_stream",
        argNames: ["s"],
      );

  @override
  Future<BindingLiquidSdk> crateBindingsConnect({required ConnectRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_connect_request(req);
        return wire.wire__crate__bindings__connect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk,
        decodeErrorData: dco_decode_liquid_sdk_error,
      ),
      constMeta: kCrateBindingsConnectConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsConnectConstMeta => const TaskConstMeta(
        debugName: "connect",
        argNames: ["req"],
      );

  @override
  Config crateBindingsDefaultConfig({required LiquidSdkNetwork network}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_liquid_sdk_network(network);
        return wire.wire__crate__bindings__default_config(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingsDefaultConfigConstMeta,
      argValues: [network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsDefaultConfigConstMeta => const TaskConstMeta(
        debugName: "default_config",
        argNames: ["network"],
      );

  @override
  Future<InputType> crateBindingsParse({required String input}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(input);
        return wire.wire__crate__bindings__parse(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_input_type,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsParseConstMeta,
      argValues: [input],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsParseConstMeta => const TaskConstMeta(
        debugName: "parse",
        argNames: ["input"],
      );

  @override
  LNInvoice crateBindingsParseInvoice({required String input}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(input);
        return wire.wire__crate__bindings__parse_invoice(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_invoice,
        decodeErrorData: dco_decode_payment_error,
      ),
      constMeta: kCrateBindingsParseInvoiceConstMeta,
      argValues: [input],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingsParseInvoiceConstMeta => const TaskConstMeta(
        debugName: "parse_invoice",
        argNames: ["input"],
      );

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BindingLiquidSdk => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BindingLiquidSdk => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  BindingLiquidSdk
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BindingLiquidSdk dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<LiquidSdkEvent> dco_decode_StreamSink_liquid_sdk_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AesSuccessActionDataDecrypted(
      description: dco_decode_String(arr[0]),
      plaintext: dco_decode_String(arr[1]),
    );
  }

  @protected
  AesSuccessActionDataResult dco_decode_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AesSuccessActionDataResult_Decrypted(
          data: dco_decode_box_autoadd_aes_success_action_data_decrypted(raw[1]),
        );
      case 1:
        return AesSuccessActionDataResult_ErrorStatus(
          reason: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BackupRequest dco_decode_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BackupRequest(
      backupPath: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  BindingEventListener dco_decode_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BindingEventListener(
      stream: dco_decode_StreamSink_liquid_sdk_event_Dco(arr[0]),
    );
  }

  @protected
  BitcoinAddressData dco_decode_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BitcoinAddressData(
      address: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      amountSat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      message: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_box_autoadd_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_decrypted(raw);
  }

  @protected
  AesSuccessActionDataResult dco_decode_box_autoadd_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_result(raw);
  }

  @protected
  BackupRequest dco_decode_box_autoadd_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_backup_request(raw);
  }

  @protected
  BindingEventListener dco_decode_box_autoadd_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_binding_event_listener(raw);
  }

  @protected
  BitcoinAddressData dco_decode_box_autoadd_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bitcoin_address_data(raw);
  }

  @protected
  ConnectRequest dco_decode_box_autoadd_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connect_request(raw);
  }

  @protected
  LiquidSdkEvent dco_decode_box_autoadd_liquid_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquid_sdk_event(raw);
  }

  @protected
  LNInvoice dco_decode_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_invoice(raw);
  }

  @protected
  LnUrlAuthRequestData dco_decode_box_autoadd_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_auth_request_data(raw);
  }

  @protected
  LnUrlErrorData dco_decode_box_autoadd_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_error_data(raw);
  }

  @protected
  LnUrlPayErrorData dco_decode_box_autoadd_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_error_data(raw);
  }

  @protected
  LnUrlPayRequest dco_decode_box_autoadd_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request(raw);
  }

  @protected
  LnUrlPayRequestData dco_decode_box_autoadd_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request_data(raw);
  }

  @protected
  LnUrlWithdrawRequest dco_decode_box_autoadd_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request(raw);
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_box_autoadd_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request_data(raw);
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_box_autoadd_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_success_data(raw);
  }

  @protected
  MessageSuccessActionData dco_decode_box_autoadd_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_message_success_action_data(raw);
  }

  @protected
  Payment dco_decode_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment(raw);
  }

  @protected
  PrepareReceiveRequest dco_decode_box_autoadd_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_receive_request(raw);
  }

  @protected
  PrepareReceiveResponse dco_decode_box_autoadd_prepare_receive_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_receive_response(raw);
  }

  @protected
  PrepareSendRequest dco_decode_box_autoadd_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_send_request(raw);
  }

  @protected
  PrepareSendResponse dco_decode_box_autoadd_prepare_send_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_send_response(raw);
  }

  @protected
  RestoreRequest dco_decode_box_autoadd_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_restore_request(raw);
  }

  @protected
  SuccessActionProcessed dco_decode_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_success_action_processed(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UrlSuccessActionData dco_decode_box_autoadd_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_url_success_action_data(raw);
  }

  @protected
  WrappedLnUrlPaySuccessData dco_decode_box_autoadd_wrapped_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wrapped_ln_url_pay_success_data(raw);
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Config(
      boltzUrl: dco_decode_String(arr[0]),
      electrumUrl: dco_decode_String(arr[1]),
      workingDir: dco_decode_String(arr[2]),
      network: dco_decode_liquid_sdk_network(arr[3]),
      paymentTimeoutSec: dco_decode_u_64(arr[4]),
      zeroConfMinFeeRate: dco_decode_f_32(arr[5]),
      zeroConfMaxAmountSat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  ConnectRequest dco_decode_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ConnectRequest(
      mnemonic: dco_decode_String(arr[0]),
      config: dco_decode_config(arr[1]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetInfoResponse dco_decode_get_info_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GetInfoResponse(
      balanceSat: dco_decode_u_64(arr[0]),
      pendingSendSat: dco_decode_u_64(arr[1]),
      pendingReceiveSat: dco_decode_u_64(arr[2]),
      pubkey: dco_decode_String(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  InputType dco_decode_input_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return InputType_BitcoinAddress(
          address: dco_decode_box_autoadd_bitcoin_address_data(raw[1]),
        );
      case 1:
        return InputType_Bolt11(
          invoice: dco_decode_box_autoadd_ln_invoice(raw[1]),
        );
      case 2:
        return InputType_NodeId(
          nodeId: dco_decode_String(raw[1]),
        );
      case 3:
        return InputType_Url(
          url: dco_decode_String(raw[1]),
        );
      case 4:
        return InputType_LnUrlPay(
          data: dco_decode_box_autoadd_ln_url_pay_request_data(raw[1]),
        );
      case 5:
        return InputType_LnUrlWithdraw(
          data: dco_decode_box_autoadd_ln_url_withdraw_request_data(raw[1]),
        );
      case 6:
        return InputType_LnUrlAuth(
          data: dco_decode_box_autoadd_ln_url_auth_request_data(raw[1]),
        );
      case 7:
        return InputType_LnUrlError(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquidSdkError dco_decode_liquid_sdk_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LiquidSdkError_AlreadyStarted();
      case 1:
        return LiquidSdkError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 2:
        return LiquidSdkError_NotStarted();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquidSdkEvent dco_decode_liquid_sdk_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LiquidSdkEvent_PaymentFailed(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 1:
        return LiquidSdkEvent_PaymentPending(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 2:
        return LiquidSdkEvent_PaymentRefunded(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 3:
        return LiquidSdkEvent_PaymentRefundPending(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 4:
        return LiquidSdkEvent_PaymentSucceeded(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 5:
        return LiquidSdkEvent_PaymentWaitingConfirmation(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 6:
        return LiquidSdkEvent_Synced();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquidSdkNetwork dco_decode_liquid_sdk_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LiquidSdkNetwork.values[raw as int];
  }

  @protected
  List<Payment> dco_decode_list_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<RouteHint> dco_decode_list_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint).toList();
  }

  @protected
  List<RouteHintHop> dco_decode_list_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint_hop).toList();
  }

  @protected
  LNInvoice dco_decode_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LNInvoice(
      bolt11: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      payeePubkey: dco_decode_String(arr[2]),
      paymentHash: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      descriptionHash: dco_decode_opt_String(arr[5]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      expiry: dco_decode_u_64(arr[8]),
      routingHints: dco_decode_list_route_hint(arr[9]),
      paymentSecret: dco_decode_list_prim_u_8_strict(arr[10]),
      minFinalCltvExpiryDelta: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  LnUrlAuthRequestData dco_decode_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlAuthRequestData(
      k1: dco_decode_String(arr[0]),
      action: dco_decode_opt_String(arr[1]),
      domain: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  LnUrlErrorData dco_decode_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlErrorData(
      reason: dco_decode_String(arr[0]),
    );
  }

  @protected
  LnUrlPayError dco_decode_ln_url_pay_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlPayError_AlreadyPaid();
      case 1:
        return LnUrlPayError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 2:
        return LnUrlPayError_InvalidAmount(
          err: dco_decode_String(raw[1]),
        );
      case 3:
        return LnUrlPayError_InvalidInvoice(
          err: dco_decode_String(raw[1]),
        );
      case 4:
        return LnUrlPayError_InvalidNetwork(
          err: dco_decode_String(raw[1]),
        );
      case 5:
        return LnUrlPayError_InvalidUri(
          err: dco_decode_String(raw[1]),
        );
      case 6:
        return LnUrlPayError_InvoiceExpired(
          err: dco_decode_String(raw[1]),
        );
      case 7:
        return LnUrlPayError_PaymentFailed(
          err: dco_decode_String(raw[1]),
        );
      case 8:
        return LnUrlPayError_PaymentTimeout(
          err: dco_decode_String(raw[1]),
        );
      case 9:
        return LnUrlPayError_RouteNotFound(
          err: dco_decode_String(raw[1]),
        );
      case 10:
        return LnUrlPayError_RouteTooExpensive(
          err: dco_decode_String(raw[1]),
        );
      case 11:
        return LnUrlPayError_ServiceConnectivity(
          err: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlPayErrorData dco_decode_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPayErrorData(
      paymentHash: dco_decode_String(arr[0]),
      reason: dco_decode_String(arr[1]),
    );
  }

  @protected
  LnUrlPayRequest dco_decode_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlPayRequest(
      data: dco_decode_ln_url_pay_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      comment: dco_decode_opt_String(arr[2]),
      paymentLabel: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  LnUrlPayRequestData dco_decode_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9) throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return LnUrlPayRequestData(
      callback: dco_decode_String(arr[0]),
      minSendable: dco_decode_u_64(arr[1]),
      maxSendable: dco_decode_u_64(arr[2]),
      metadataStr: dco_decode_String(arr[3]),
      commentAllowed: dco_decode_u_16(arr[4]),
      domain: dco_decode_String(arr[5]),
      allowsNostr: dco_decode_bool(arr[6]),
      nostrPubkey: dco_decode_opt_String(arr[7]),
      lnAddress: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  LnUrlWithdrawError dco_decode_ln_url_withdraw_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 1:
        return LnUrlWithdrawError_InvalidAmount(
          err: dco_decode_String(raw[1]),
        );
      case 2:
        return LnUrlWithdrawError_InvalidInvoice(
          err: dco_decode_String(raw[1]),
        );
      case 3:
        return LnUrlWithdrawError_InvalidUri(
          err: dco_decode_String(raw[1]),
        );
      case 4:
        return LnUrlWithdrawError_InvoiceNoRoutingHints(
          err: dco_decode_String(raw[1]),
        );
      case 5:
        return LnUrlWithdrawError_ServiceConnectivity(
          err: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawRequest dco_decode_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LnUrlWithdrawRequest(
      data: dco_decode_ln_url_withdraw_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LnUrlWithdrawRequestData(
      callback: dco_decode_String(arr[0]),
      k1: dco_decode_String(arr[1]),
      defaultDescription: dco_decode_String(arr[2]),
      minWithdrawable: dco_decode_u_64(arr[3]),
      maxWithdrawable: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  LnUrlWithdrawResult dco_decode_ln_url_withdraw_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawResult_Ok(
          data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]),
        );
      case 1:
        return LnUrlWithdrawResult_ErrorStatus(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlWithdrawSuccessData(
      invoice: dco_decode_ln_invoice(arr[0]),
    );
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LogEntry(
      line: dco_decode_String(arr[0]),
      level: dco_decode_String(arr[1]),
    );
  }

  @protected
  MessageSuccessActionData dco_decode_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MessageSuccessActionData(
      message: dco_decode_String(arr[0]),
    );
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  SuccessActionProcessed? dco_decode_opt_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_success_action_processed(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Payment dco_decode_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Payment(
      txId: dco_decode_opt_String(arr[0]),
      swapId: dco_decode_opt_String(arr[1]),
      timestamp: dco_decode_u_32(arr[2]),
      amountSat: dco_decode_u_64(arr[3]),
      feesSat: dco_decode_u_64(arr[4]),
      preimage: dco_decode_opt_String(arr[5]),
      refundTxId: dco_decode_opt_String(arr[6]),
      refundTxAmountSat: dco_decode_opt_box_autoadd_u_64(arr[7]),
      paymentType: dco_decode_payment_type(arr[8]),
      status: dco_decode_payment_state(arr[9]),
    );
  }

  @protected
  PaymentError dco_decode_payment_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        return PaymentError_AmountOutOfRange();
      case 4:
        return PaymentError_Generic(
          err: dco_decode_String(raw[1]),
        );
      case 5:
        return PaymentError_InvalidOrExpiredFees();
      case 6:
        return PaymentError_InsufficientFunds();
      case 7:
        return PaymentError_InvalidInvoice(
          err: dco_decode_String(raw[1]),
        );
      case 8:
        return PaymentError_InvalidPreimage();
      case 9:
        return PaymentError_LwkError(
          err: dco_decode_String(raw[1]),
        );
      case 10:
        return PaymentError_PairsNotFound();
      case 11:
        return PaymentError_PaymentTimeout();
      case 12:
        return PaymentError_PersistError();
      case 13:
        return PaymentError_ReceiveError(
          err: dco_decode_String(raw[1]),
        );
      case 14:
        return PaymentError_Refunded(
          err: dco_decode_String(raw[1]),
          refundTxId: dco_decode_String(raw[2]),
        );
      case 15:
        return PaymentError_SelfTransferNotSupported();
      case 16:
        return PaymentError_SendError(
          err: dco_decode_String(raw[1]),
        );
      case 17:
        return PaymentError_SignerError(
          err: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentState dco_decode_payment_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentState.values[raw as int];
  }

  @protected
  PaymentType dco_decode_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentType.values[raw as int];
  }

  @protected
  PrepareReceiveRequest dco_decode_prepare_receive_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PrepareReceiveRequest(
      payerAmountSat: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  PrepareReceiveResponse dco_decode_prepare_receive_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareReceiveResponse(
      payerAmountSat: dco_decode_u_64(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PrepareSendRequest dco_decode_prepare_send_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PrepareSendRequest(
      invoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  PrepareSendResponse dco_decode_prepare_send_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareSendResponse(
      invoice: dco_decode_String(arr[0]),
      feesSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  ReceivePaymentResponse dco_decode_receive_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReceivePaymentResponse(
      id: dco_decode_String(arr[0]),
      invoice: dco_decode_String(arr[1]),
    );
  }

  @protected
  RestoreRequest dco_decode_restore_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RestoreRequest(
      backupPath: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  RouteHint dco_decode_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RouteHint(
      hops: dco_decode_list_route_hint_hop(arr[0]),
    );
  }

  @protected
  RouteHintHop dco_decode_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RouteHintHop(
      srcNodeId: dco_decode_String(arr[0]),
      shortChannelId: dco_decode_u_64(arr[1]),
      feesBaseMsat: dco_decode_u_32(arr[2]),
      feesProportionalMillionths: dco_decode_u_32(arr[3]),
      cltvExpiryDelta: dco_decode_u_64(arr[4]),
      htlcMinimumMsat: dco_decode_opt_box_autoadd_u_64(arr[5]),
      htlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  SendPaymentResponse dco_decode_send_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendPaymentResponse(
      payment: dco_decode_payment(arr[0]),
    );
  }

  @protected
  SuccessActionProcessed dco_decode_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SuccessActionProcessed_Aes(
          result: dco_decode_box_autoadd_aes_success_action_data_result(raw[1]),
        );
      case 1:
        return SuccessActionProcessed_Message(
          data: dco_decode_box_autoadd_message_success_action_data(raw[1]),
        );
      case 2:
        return SuccessActionProcessed_Url(
          data: dco_decode_box_autoadd_url_success_action_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UrlSuccessActionData dco_decode_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UrlSuccessActionData(
      description: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WrappedLnUrlPayResult dco_decode_wrapped_ln_url_pay_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WrappedLnUrlPayResult_EndpointSuccess(
          data: dco_decode_box_autoadd_wrapped_ln_url_pay_success_data(raw[1]),
        );
      case 1:
        return WrappedLnUrlPayResult_EndpointError(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      case 2:
        return WrappedLnUrlPayResult_PayError(
          data: dco_decode_box_autoadd_ln_url_pay_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WrappedLnUrlPaySuccessData dco_decode_wrapped_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WrappedLnUrlPaySuccessData(
      payment: dco_decode_payment(arr[0]),
      successAction: dco_decode_opt_box_autoadd_success_action_processed(arr[1]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  BindingLiquidSdk
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BindingLiquidSdk
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BindingLiquidSdk sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingLiquidSdkImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<LiquidSdkEvent> sse_decode_StreamSink_liquid_sdk_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_aes_success_action_data_decrypted(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_plaintext = sse_decode_String(deserializer);
    return AesSuccessActionDataDecrypted(description: var_description, plaintext: var_plaintext);
  }

  @protected
  AesSuccessActionDataResult sse_decode_aes_success_action_data_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_aes_success_action_data_decrypted(deserializer);
        return AesSuccessActionDataResult_Decrypted(data: var_data);
      case 1:
        var var_reason = sse_decode_String(deserializer);
        return AesSuccessActionDataResult_ErrorStatus(reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BackupRequest sse_decode_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return BackupRequest(backupPath: var_backupPath);
  }

  @protected
  BindingEventListener sse_decode_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_stream = sse_decode_StreamSink_liquid_sdk_event_Dco(deserializer);
    return BindingEventListener(stream: var_stream);
  }

  @protected
  BitcoinAddressData sse_decode_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_amountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_message = sse_decode_opt_String(deserializer);
    return BitcoinAddressData(
        address: var_address,
        network: var_network,
        amountSat: var_amountSat,
        label: var_label,
        message: var_message);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_box_autoadd_aes_success_action_data_decrypted(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_decrypted(deserializer));
  }

  @protected
  AesSuccessActionDataResult sse_decode_box_autoadd_aes_success_action_data_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_result(deserializer));
  }

  @protected
  BackupRequest sse_decode_box_autoadd_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_backup_request(deserializer));
  }

  @protected
  BindingEventListener sse_decode_box_autoadd_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_binding_event_listener(deserializer));
  }

  @protected
  BitcoinAddressData sse_decode_box_autoadd_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bitcoin_address_data(deserializer));
  }

  @protected
  ConnectRequest sse_decode_box_autoadd_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connect_request(deserializer));
  }

  @protected
  LiquidSdkEvent sse_decode_box_autoadd_liquid_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquid_sdk_event(deserializer));
  }

  @protected
  LNInvoice sse_decode_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_invoice(deserializer));
  }

  @protected
  LnUrlAuthRequestData sse_decode_box_autoadd_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_auth_request_data(deserializer));
  }

  @protected
  LnUrlErrorData sse_decode_box_autoadd_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_error_data(deserializer));
  }

  @protected
  LnUrlPayErrorData sse_decode_box_autoadd_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_error_data(deserializer));
  }

  @protected
  LnUrlPayRequest sse_decode_box_autoadd_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request(deserializer));
  }

  @protected
  LnUrlPayRequestData sse_decode_box_autoadd_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request_data(deserializer));
  }

  @protected
  LnUrlWithdrawRequest sse_decode_box_autoadd_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request(deserializer));
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_box_autoadd_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request_data(deserializer));
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_box_autoadd_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_success_data(deserializer));
  }

  @protected
  MessageSuccessActionData sse_decode_box_autoadd_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_message_success_action_data(deserializer));
  }

  @protected
  Payment sse_decode_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment(deserializer));
  }

  @protected
  PrepareReceiveRequest sse_decode_box_autoadd_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_receive_request(deserializer));
  }

  @protected
  PrepareReceiveResponse sse_decode_box_autoadd_prepare_receive_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_receive_response(deserializer));
  }

  @protected
  PrepareSendRequest sse_decode_box_autoadd_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_send_request(deserializer));
  }

  @protected
  PrepareSendResponse sse_decode_box_autoadd_prepare_send_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_send_response(deserializer));
  }

  @protected
  RestoreRequest sse_decode_box_autoadd_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_restore_request(deserializer));
  }

  @protected
  SuccessActionProcessed sse_decode_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_success_action_processed(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UrlSuccessActionData sse_decode_box_autoadd_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_url_success_action_data(deserializer));
  }

  @protected
  WrappedLnUrlPaySuccessData sse_decode_box_autoadd_wrapped_ln_url_pay_success_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wrapped_ln_url_pay_success_data(deserializer));
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_workingDir = sse_decode_String(deserializer);
    var var_network = sse_decode_liquid_sdk_network(deserializer);
    var var_paymentTimeoutSec = sse_decode_u_64(deserializer);
    var var_zeroConfMinFeeRate = sse_decode_f_32(deserializer);
    var var_zeroConfMaxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return Config(
        boltzUrl: var_boltzUrl,
        electrumUrl: var_electrumUrl,
        workingDir: var_workingDir,
        network: var_network,
        paymentTimeoutSec: var_paymentTimeoutSec,
        zeroConfMinFeeRate: var_zeroConfMinFeeRate,
        zeroConfMaxAmountSat: var_zeroConfMaxAmountSat);
  }

  @protected
  ConnectRequest sse_decode_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mnemonic = sse_decode_String(deserializer);
    var var_config = sse_decode_config(deserializer);
    return ConnectRequest(mnemonic: var_mnemonic, config: var_config);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  GetInfoResponse sse_decode_get_info_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_balanceSat = sse_decode_u_64(deserializer);
    var var_pendingSendSat = sse_decode_u_64(deserializer);
    var var_pendingReceiveSat = sse_decode_u_64(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    return GetInfoResponse(
        balanceSat: var_balanceSat,
        pendingSendSat: var_pendingSendSat,
        pendingReceiveSat: var_pendingReceiveSat,
        pubkey: var_pubkey);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  InputType sse_decode_input_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_address = sse_decode_box_autoadd_bitcoin_address_data(deserializer);
        return InputType_BitcoinAddress(address: var_address);
      case 1:
        var var_invoice = sse_decode_box_autoadd_ln_invoice(deserializer);
        return InputType_Bolt11(invoice: var_invoice);
      case 2:
        var var_nodeId = sse_decode_String(deserializer);
        return InputType_NodeId(nodeId: var_nodeId);
      case 3:
        var var_url = sse_decode_String(deserializer);
        return InputType_Url(url: var_url);
      case 4:
        var var_data = sse_decode_box_autoadd_ln_url_pay_request_data(deserializer);
        return InputType_LnUrlPay(data: var_data);
      case 5:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_request_data(deserializer);
        return InputType_LnUrlWithdraw(data: var_data);
      case 6:
        var var_data = sse_decode_box_autoadd_ln_url_auth_request_data(deserializer);
        return InputType_LnUrlAuth(data: var_data);
      case 7:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return InputType_LnUrlError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquidSdkError sse_decode_liquid_sdk_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LiquidSdkError_AlreadyStarted();
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LiquidSdkError_Generic(err: var_err);
      case 2:
        return LiquidSdkError_NotStarted();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquidSdkEvent sse_decode_liquid_sdk_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentFailed(details: var_details);
      case 1:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentPending(details: var_details);
      case 2:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentRefunded(details: var_details);
      case 3:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentRefundPending(details: var_details);
      case 4:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentSucceeded(details: var_details);
      case 5:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return LiquidSdkEvent_PaymentWaitingConfirmation(details: var_details);
      case 6:
        return LiquidSdkEvent_Synced();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquidSdkNetwork sse_decode_liquid_sdk_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LiquidSdkNetwork.values[inner];
  }

  @protected
  List<Payment> sse_decode_list_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Payment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<RouteHint> sse_decode_list_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHintHop> sse_decode_list_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHintHop>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint_hop(deserializer));
    }
    return ans_;
  }

  @protected
  LNInvoice sse_decode_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_payeePubkey = sse_decode_String(deserializer);
    var var_paymentHash = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionHash = sse_decode_opt_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_routingHints = sse_decode_list_route_hint(deserializer);
    var var_paymentSecret = sse_decode_list_prim_u_8_strict(deserializer);
    var var_minFinalCltvExpiryDelta = sse_decode_u_64(deserializer);
    return LNInvoice(
        bolt11: var_bolt11,
        network: var_network,
        payeePubkey: var_payeePubkey,
        paymentHash: var_paymentHash,
        description: var_description,
        descriptionHash: var_descriptionHash,
        amountMsat: var_amountMsat,
        timestamp: var_timestamp,
        expiry: var_expiry,
        routingHints: var_routingHints,
        paymentSecret: var_paymentSecret,
        minFinalCltvExpiryDelta: var_minFinalCltvExpiryDelta);
  }

  @protected
  LnUrlAuthRequestData sse_decode_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_k1 = sse_decode_String(deserializer);
    var var_action = sse_decode_opt_String(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return LnUrlAuthRequestData(k1: var_k1, action: var_action, domain: var_domain, url: var_url);
  }

  @protected
  LnUrlErrorData sse_decode_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reason = sse_decode_String(deserializer);
    return LnUrlErrorData(reason: var_reason);
  }

  @protected
  LnUrlPayError sse_decode_ln_url_pay_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LnUrlPayError_AlreadyPaid();
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_Generic(err: var_err);
      case 2:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidAmount(err: var_err);
      case 3:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidInvoice(err: var_err);
      case 4:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidNetwork(err: var_err);
      case 5:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvalidUri(err: var_err);
      case 6:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_InvoiceExpired(err: var_err);
      case 7:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_PaymentFailed(err: var_err);
      case 8:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_PaymentTimeout(err: var_err);
      case 9:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_RouteNotFound(err: var_err);
      case 10:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_RouteTooExpensive(err: var_err);
      case 11:
        var var_err = sse_decode_String(deserializer);
        return LnUrlPayError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlPayErrorData sse_decode_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_reason = sse_decode_String(deserializer);
    return LnUrlPayErrorData(paymentHash: var_paymentHash, reason: var_reason);
  }

  @protected
  LnUrlPayRequest sse_decode_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_pay_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    var var_paymentLabel = sse_decode_opt_String(deserializer);
    return LnUrlPayRequest(
        data: var_data, amountMsat: var_amountMsat, comment: var_comment, paymentLabel: var_paymentLabel);
  }

  @protected
  LnUrlPayRequestData sse_decode_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_minSendable = sse_decode_u_64(deserializer);
    var var_maxSendable = sse_decode_u_64(deserializer);
    var var_metadataStr = sse_decode_String(deserializer);
    var var_commentAllowed = sse_decode_u_16(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_allowsNostr = sse_decode_bool(deserializer);
    var var_nostrPubkey = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    return LnUrlPayRequestData(
        callback: var_callback,
        minSendable: var_minSendable,
        maxSendable: var_maxSendable,
        metadataStr: var_metadataStr,
        commentAllowed: var_commentAllowed,
        domain: var_domain,
        allowsNostr: var_allowsNostr,
        nostrPubkey: var_nostrPubkey,
        lnAddress: var_lnAddress);
  }

  @protected
  LnUrlWithdrawError sse_decode_ln_url_withdraw_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_Generic(err: var_err);
      case 1:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidAmount(err: var_err);
      case 2:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidInvoice(err: var_err);
      case 3:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvalidUri(err: var_err);
      case 4:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_InvoiceNoRoutingHints(err: var_err);
      case 5:
        var var_err = sse_decode_String(deserializer);
        return LnUrlWithdrawError_ServiceConnectivity(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawRequest sse_decode_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_withdraw_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return LnUrlWithdrawRequest(data: var_data, amountMsat: var_amountMsat, description: var_description);
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_k1 = sse_decode_String(deserializer);
    var var_defaultDescription = sse_decode_String(deserializer);
    var var_minWithdrawable = sse_decode_u_64(deserializer);
    var var_maxWithdrawable = sse_decode_u_64(deserializer);
    return LnUrlWithdrawRequestData(
        callback: var_callback,
        k1: var_k1,
        defaultDescription: var_defaultDescription,
        minWithdrawable: var_minWithdrawable,
        maxWithdrawable: var_maxWithdrawable);
  }

  @protected
  LnUrlWithdrawResult sse_decode_ln_url_withdraw_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Ok(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlWithdrawResult_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_ln_invoice(deserializer);
    return LnUrlWithdrawSuccessData(invoice: var_invoice);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_line = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    return LogEntry(line: var_line, level: var_level);
  }

  @protected
  MessageSuccessActionData sse_decode_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return MessageSuccessActionData(message: var_message);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SuccessActionProcessed? sse_decode_opt_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_success_action_processed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Payment sse_decode_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_opt_String(deserializer);
    var var_swapId = sse_decode_opt_String(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    var var_preimage = sse_decode_opt_String(deserializer);
    var var_refundTxId = sse_decode_opt_String(deserializer);
    var var_refundTxAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_paymentType = sse_decode_payment_type(deserializer);
    var var_status = sse_decode_payment_state(deserializer);
    return Payment(
        txId: var_txId,
        swapId: var_swapId,
        timestamp: var_timestamp,
        amountSat: var_amountSat,
        feesSat: var_feesSat,
        preimage: var_preimage,
        refundTxId: var_refundTxId,
        refundTxAmountSat: var_refundTxAmountSat,
        paymentType: var_paymentType,
        status: var_status);
  }

  @protected
  PaymentError sse_decode_payment_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentError_AlreadyClaimed();
      case 1:
        return PaymentError_AlreadyPaid();
      case 2:
        return PaymentError_PaymentInProgress();
      case 3:
        return PaymentError_AmountOutOfRange();
      case 4:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_Generic(err: var_err);
      case 5:
        return PaymentError_InvalidOrExpiredFees();
      case 6:
        return PaymentError_InsufficientFunds();
      case 7:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_InvalidInvoice(err: var_err);
      case 8:
        return PaymentError_InvalidPreimage();
      case 9:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_LwkError(err: var_err);
      case 10:
        return PaymentError_PairsNotFound();
      case 11:
        return PaymentError_PaymentTimeout();
      case 12:
        return PaymentError_PersistError();
      case 13:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_ReceiveError(err: var_err);
      case 14:
        var var_err = sse_decode_String(deserializer);
        var var_refundTxId = sse_decode_String(deserializer);
        return PaymentError_Refunded(err: var_err, refundTxId: var_refundTxId);
      case 15:
        return PaymentError_SelfTransferNotSupported();
      case 16:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SendError(err: var_err);
      case 17:
        var var_err = sse_decode_String(deserializer);
        return PaymentError_SignerError(err: var_err);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentState sse_decode_payment_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentState.values[inner];
  }

  @protected
  PaymentType sse_decode_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentType.values[inner];
  }

  @protected
  PrepareReceiveRequest sse_decode_prepare_receive_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payerAmountSat = sse_decode_u_64(deserializer);
    return PrepareReceiveRequest(payerAmountSat: var_payerAmountSat);
  }

  @protected
  PrepareReceiveResponse sse_decode_prepare_receive_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payerAmountSat = sse_decode_u_64(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    return PrepareReceiveResponse(payerAmountSat: var_payerAmountSat, feesSat: var_feesSat);
  }

  @protected
  PrepareSendRequest sse_decode_prepare_send_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_String(deserializer);
    return PrepareSendRequest(invoice: var_invoice);
  }

  @protected
  PrepareSendResponse sse_decode_prepare_send_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_String(deserializer);
    var var_feesSat = sse_decode_u_64(deserializer);
    return PrepareSendResponse(invoice: var_invoice, feesSat: var_feesSat);
  }

  @protected
  ReceivePaymentResponse sse_decode_receive_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    return ReceivePaymentResponse(id: var_id, invoice: var_invoice);
  }

  @protected
  RestoreRequest sse_decode_restore_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backupPath = sse_decode_opt_String(deserializer);
    return RestoreRequest(backupPath: var_backupPath);
  }

  @protected
  RouteHint sse_decode_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hops = sse_decode_list_route_hint_hop(deserializer);
    return RouteHint(hops: var_hops);
  }

  @protected
  RouteHintHop sse_decode_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcNodeId = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_u_64(deserializer);
    var var_feesBaseMsat = sse_decode_u_32(deserializer);
    var var_feesProportionalMillionths = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_64(deserializer);
    var var_htlcMinimumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return RouteHintHop(
        srcNodeId: var_srcNodeId,
        shortChannelId: var_shortChannelId,
        feesBaseMsat: var_feesBaseMsat,
        feesProportionalMillionths: var_feesProportionalMillionths,
        cltvExpiryDelta: var_cltvExpiryDelta,
        htlcMinimumMsat: var_htlcMinimumMsat,
        htlcMaximumMsat: var_htlcMaximumMsat);
  }

  @protected
  SendPaymentResponse sse_decode_send_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    return SendPaymentResponse(payment: var_payment);
  }

  @protected
  SuccessActionProcessed sse_decode_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_result = sse_decode_box_autoadd_aes_success_action_data_result(deserializer);
        return SuccessActionProcessed_Aes(result: var_result);
      case 1:
        var var_data = sse_decode_box_autoadd_message_success_action_data(deserializer);
        return SuccessActionProcessed_Message(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_url_success_action_data(deserializer);
        return SuccessActionProcessed_Url(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UrlSuccessActionData sse_decode_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return UrlSuccessActionData(description: var_description, url: var_url);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WrappedLnUrlPayResult sse_decode_wrapped_ln_url_pay_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_wrapped_ln_url_pay_success_data(deserializer);
        return WrappedLnUrlPayResult_EndpointSuccess(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return WrappedLnUrlPayResult_EndpointError(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_pay_error_data(deserializer);
        return WrappedLnUrlPayResult_PayError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WrappedLnUrlPaySuccessData sse_decode_wrapped_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    var var_successAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    return WrappedLnUrlPaySuccessData(payment: var_payment, successAction: var_successAction);
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BindingLiquidSdkImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_liquid_sdk_network(LiquidSdkNetwork raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_state(PaymentState raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type(PaymentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBindingLiquidSdk(
      BindingLiquidSdk self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as BindingLiquidSdkImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_StreamSink_liquid_sdk_event_Dco(
      RustStreamSink<LiquidSdkEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(decodeSuccessData: dco_decode_liquid_sdk_event, decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Dco(RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(decodeSuccessData: dco_decode_log_entry, decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_decrypted(
      AesSuccessActionDataDecrypted self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.plaintext, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_result(AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AesSuccessActionDataResult_Decrypted(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_decrypted(data, serializer);
      case AesSuccessActionDataResult_ErrorStatus(reason: final reason):
        sse_encode_i_32(1, serializer);
        sse_encode_String(reason, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_StreamSink_liquid_sdk_event_Dco(self.stream, serializer);
  }

  @protected
  void sse_encode_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_opt_String(self.message, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_decrypted(
      AesSuccessActionDataDecrypted self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_decrypted(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_result(
      AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_result(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_backup_request(BackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_backup_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_binding_event_listener(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_address_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connect_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquid_sdk_event(LiquidSdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquid_sdk_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_auth_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request_data(
      LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_success_data(
      LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_message_success_action_data(
      MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_message_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_receive_response(
      PrepareReceiveResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_receive_response(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_send_response(PrepareSendResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_send_response(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_restore_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_success_action_processed(
      SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_success_action_processed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_url_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wrapped_ln_url_pay_success_data(
      WrappedLnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wrapped_ln_url_pay_success_data(self, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.workingDir, serializer);
    sse_encode_liquid_sdk_network(self.network, serializer);
    sse_encode_u_64(self.paymentTimeoutSec, serializer);
    sse_encode_f_32(self.zeroConfMinFeeRate, serializer);
    sse_encode_opt_box_autoadd_u_64(self.zeroConfMaxAmountSat, serializer);
  }

  @protected
  void sse_encode_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.mnemonic, serializer);
    sse_encode_config(self.config, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_get_info_response(GetInfoResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.balanceSat, serializer);
    sse_encode_u_64(self.pendingSendSat, serializer);
    sse_encode_u_64(self.pendingReceiveSat, serializer);
    sse_encode_String(self.pubkey, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_input_type(InputType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case InputType_BitcoinAddress(address: final address):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_bitcoin_address_data(address, serializer);
      case InputType_Bolt11(invoice: final invoice):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_invoice(invoice, serializer);
      case InputType_NodeId(nodeId: final nodeId):
        sse_encode_i_32(2, serializer);
        sse_encode_String(nodeId, serializer);
      case InputType_Url(url: final url):
        sse_encode_i_32(3, serializer);
        sse_encode_String(url, serializer);
      case InputType_LnUrlPay(data: final data):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_ln_url_pay_request_data(data, serializer);
      case InputType_LnUrlWithdraw(data: final data):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_request_data(data, serializer);
      case InputType_LnUrlAuth(data: final data):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_ln_url_auth_request_data(data, serializer);
      case InputType_LnUrlError(data: final data):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquid_sdk_error(LiquidSdkError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LiquidSdkError_AlreadyStarted():
        sse_encode_i_32(0, serializer);
      case LiquidSdkError_Generic(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LiquidSdkError_NotStarted():
        sse_encode_i_32(2, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquid_sdk_event(LiquidSdkEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LiquidSdkEvent_PaymentFailed(details: final details):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentPending(details: final details):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentRefunded(details: final details):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentRefundPending(details: final details):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentSucceeded(details: final details):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_PaymentWaitingConfirmation(details: final details):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case LiquidSdkEvent_Synced():
        sse_encode_i_32(6, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquid_sdk_network(LiquidSdkNetwork self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_payment(List<Payment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_route_hint(List<RouteHint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint_hop(List<RouteHintHop> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint_hop(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.payeePubkey, serializer);
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_list_route_hint(self.routingHints, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentSecret, serializer);
    sse_encode_u_64(self.minFinalCltvExpiryDelta, serializer);
  }

  @protected
  void sse_encode_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.k1, serializer);
    sse_encode_opt_String(self.action, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_error(LnUrlPayError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlPayError_AlreadyPaid():
        sse_encode_i_32(0, serializer);
      case LnUrlPayError_Generic(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidAmount(err: final err):
        sse_encode_i_32(2, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidInvoice(err: final err):
        sse_encode_i_32(3, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidNetwork(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvalidUri(err: final err):
        sse_encode_i_32(5, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_InvoiceExpired(err: final err):
        sse_encode_i_32(6, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_PaymentFailed(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_PaymentTimeout(err: final err):
        sse_encode_i_32(8, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_RouteNotFound(err: final err):
        sse_encode_i_32(9, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_RouteTooExpensive(err: final err):
        sse_encode_i_32(10, serializer);
        sse_encode_String(err, serializer);
      case LnUrlPayError_ServiceConnectivity(err: final err):
        sse_encode_i_32(11, serializer);
        sse_encode_String(err, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.comment, serializer);
    sse_encode_opt_String(self.paymentLabel, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_u_64(self.minSendable, serializer);
    sse_encode_u_64(self.maxSendable, serializer);
    sse_encode_String(self.metadataStr, serializer);
    sse_encode_u_16(self.commentAllowed, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_bool(self.allowsNostr, serializer);
    sse_encode_opt_String(self.nostrPubkey, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_error(LnUrlWithdrawError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawError_Generic(err: final err):
        sse_encode_i_32(0, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidAmount(err: final err):
        sse_encode_i_32(1, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidInvoice(err: final err):
        sse_encode_i_32(2, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvalidUri(err: final err):
        sse_encode_i_32(3, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_InvoiceNoRoutingHints(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case LnUrlWithdrawError_ServiceConnectivity(err: final err):
        sse_encode_i_32(5, serializer);
        sse_encode_String(err, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request_data(LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_String(self.k1, serializer);
    sse_encode_String(self.defaultDescription, serializer);
    sse_encode_u_64(self.minWithdrawable, serializer);
    sse_encode_u_64(self.maxWithdrawable, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_result(LnUrlWithdrawResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawResult_Ok(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_ErrorStatus(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_success_data(LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.invoice, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.level, serializer);
  }

  @protected
  void sse_encode_message_success_action_data(MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_success_action_processed(
      SuccessActionProcessed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_success_action_processed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.txId, serializer);
    sse_encode_opt_String(self.swapId, serializer);
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
    sse_encode_opt_String(self.preimage, serializer);
    sse_encode_opt_String(self.refundTxId, serializer);
    sse_encode_opt_box_autoadd_u_64(self.refundTxAmountSat, serializer);
    sse_encode_payment_type(self.paymentType, serializer);
    sse_encode_payment_state(self.status, serializer);
  }

  @protected
  void sse_encode_payment_error(PaymentError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentError_AlreadyClaimed():
        sse_encode_i_32(0, serializer);
      case PaymentError_AlreadyPaid():
        sse_encode_i_32(1, serializer);
      case PaymentError_PaymentInProgress():
        sse_encode_i_32(2, serializer);
      case PaymentError_AmountOutOfRange():
        sse_encode_i_32(3, serializer);
      case PaymentError_Generic(err: final err):
        sse_encode_i_32(4, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidOrExpiredFees():
        sse_encode_i_32(5, serializer);
      case PaymentError_InsufficientFunds():
        sse_encode_i_32(6, serializer);
      case PaymentError_InvalidInvoice(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_InvalidPreimage():
        sse_encode_i_32(8, serializer);
      case PaymentError_LwkError(err: final err):
        sse_encode_i_32(9, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_PairsNotFound():
        sse_encode_i_32(10, serializer);
      case PaymentError_PaymentTimeout():
        sse_encode_i_32(11, serializer);
      case PaymentError_PersistError():
        sse_encode_i_32(12, serializer);
      case PaymentError_ReceiveError(err: final err):
        sse_encode_i_32(13, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_Refunded(err: final err, refundTxId: final refundTxId):
        sse_encode_i_32(14, serializer);
        sse_encode_String(err, serializer);
        sse_encode_String(refundTxId, serializer);
      case PaymentError_SelfTransferNotSupported():
        sse_encode_i_32(15, serializer);
      case PaymentError_SendError(err: final err):
        sse_encode_i_32(16, serializer);
        sse_encode_String(err, serializer);
      case PaymentError_SignerError(err: final err):
        sse_encode_i_32(17, serializer);
        sse_encode_String(err, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_payment_state(PaymentState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type(PaymentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_prepare_receive_request(PrepareReceiveRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.payerAmountSat, serializer);
  }

  @protected
  void sse_encode_prepare_receive_response(PrepareReceiveResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.payerAmountSat, serializer);
    sse_encode_u_64(self.feesSat, serializer);
  }

  @protected
  void sse_encode_prepare_send_request(PrepareSendRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_prepare_send_response(PrepareSendResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.invoice, serializer);
    sse_encode_u_64(self.feesSat, serializer);
  }

  @protected
  void sse_encode_receive_payment_response(ReceivePaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.invoice, serializer);
  }

  @protected
  void sse_encode_restore_request(RestoreRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.backupPath, serializer);
  }

  @protected
  void sse_encode_route_hint(RouteHint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_route_hint_hop(self.hops, serializer);
  }

  @protected
  void sse_encode_route_hint_hop(RouteHintHop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcNodeId, serializer);
    sse_encode_u_64(self.shortChannelId, serializer);
    sse_encode_u_32(self.feesBaseMsat, serializer);
    sse_encode_u_32(self.feesProportionalMillionths, serializer);
    sse_encode_u_64(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMaximumMsat, serializer);
  }

  @protected
  void sse_encode_send_payment_response(SendPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_success_action_processed(SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SuccessActionProcessed_Aes(result: final result):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_result(result, serializer);
      case SuccessActionProcessed_Message(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_message_success_action_data(data, serializer);
      case SuccessActionProcessed_Url(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_url_success_action_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wrapped_ln_url_pay_result(WrappedLnUrlPayResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WrappedLnUrlPayResult_EndpointSuccess(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_wrapped_ln_url_pay_success_data(data, serializer);
      case WrappedLnUrlPayResult_EndpointError(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      case WrappedLnUrlPayResult_PayError(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_pay_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_wrapped_ln_url_pay_success_data(WrappedLnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.successAction, serializer);
  }
}

@sealed
class BindingLiquidSdkImpl extends RustOpaque implements BindingLiquidSdk {
  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BindingLiquidSdkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdk,
    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_BindingLiquidSdkPtr,
  );

  Stream<LiquidSdkEvent> addEventListener() =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkAddEventListener(
        that: this,
      );

  void backup({required BackupRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkBackup(that: this, req: req);

  Future<void> disconnect() => RustLib.instance.api.crateBindingsBindingLiquidSdkDisconnect(
        that: this,
      );

  void emptyWalletCache() => RustLib.instance.api.crateBindingsBindingLiquidSdkEmptyWalletCache(
        that: this,
      );

  Future<GetInfoResponse> getInfo() => RustLib.instance.api.crateBindingsBindingLiquidSdkGetInfo(
        that: this,
      );

  Future<List<Payment>> listPayments() => RustLib.instance.api.crateBindingsBindingLiquidSdkListPayments(
        that: this,
      );

  Future<WrappedLnUrlPayResult> lnurlPay({required LnUrlPayRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkLnurlPay(that: this, req: req);

  Future<LnUrlWithdrawResult> lnurlWithdraw({required LnUrlWithdrawRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkLnurlWithdraw(that: this, req: req);

  Future<PrepareReceiveResponse> prepareReceivePayment({required PrepareReceiveRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareReceivePayment(that: this, req: req);

  Future<PrepareSendResponse> prepareSendPayment({required PrepareSendRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkPrepareSendPayment(that: this, req: req);

  Future<ReceivePaymentResponse> receivePayment({required PrepareReceiveResponse req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkReceivePayment(that: this, req: req);

  void restore({required RestoreRequest req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkRestore(that: this, req: req);

  Future<SendPaymentResponse> sendPayment({required PrepareSendResponse req}) =>
      RustLib.instance.api.crateBindingsBindingLiquidSdkSendPayment(that: this, req: req);

  Future<void> sync() => RustLib.instance.api.crateBindingsBindingLiquidSdkSync(
        that: this,
      );
}
